diff -Naur ns-2.35-orig/common/packet.h ns-2.35/common/packet.h
--- ns-2.35-orig/common/packet.h	2010-05-10 00:28:41.000000000 +0200
+++ ns-2.35/common/packet.h	2017-04-01 01:59:30.959080928 +0200
@@ -198,9 +198,12 @@
 
         // M-DART packets
 static const packet_t PT_MDART = 72;
+
+	// DYMOUM packet
+static const packet_t PT_DYMOUM = 73;
 	
         // insert new packet types here
-static packet_t       PT_NTYPE = 73; // This MUST be the LAST one
+static packet_t       PT_NTYPE = 74; // This MUST be the LAST one
 
 enum packetClass
 {
@@ -267,7 +270,8 @@
 		    type == PT_TORA ||
 		    type == PT_PUMA ||
 		    type == PT_AODV ||
-		    type == PT_MDART)
+		    type == PT_MDART ||
+		    type == PT_DYMOUM)
 			return ROUTING;		
 		if (type == PT_TCP || 
 		    type == PT_TELNET || 
@@ -417,6 +421,10 @@
 		name_[PT_DCCP_CLOSEREQ]="DCCP_CloseReq";
 		name_[PT_DCCP_RESET]="DCCP_Reset";
 
+
+		name_[PT_DYMOUM] = "DYMOUM";
+
+		
 		name_[PT_NTYPE]= "undefined";
 	}
 	static int addPacket(char *name);
diff -Naur ns-2.35-orig/dymoum/blacklist.c ns-2.35/dymoum/blacklist.c
--- ns-2.35-orig/dymoum/blacklist.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/blacklist.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,75 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#include <errno.h>
+#else
+#include "blacklist.h"
+#include "debug.h"
+
+#include <stdlib.h>
+#include <errno.h>
+
+static DLIST_HEAD(BLACKLIST);
+#endif	/* NS_PORT */
+
+blacklist_t *NS_CLASS blacklist_add(struct in_addr addr)
+{
+	blacklist_t *entry;
+	
+	if ((entry = (blacklist_t *)malloc(sizeof(blacklist_t))) == NULL)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "failed malloc()");
+		exit(EXIT_FAILURE);
+	}
+	
+	entry->addr.s_addr	= addr.s_addr;
+	dlist_add(&entry->list_head, &BLACKLIST);
+	
+	return entry;
+}
+
+int NS_CLASS blacklist_remove(blacklist_t *entry)
+{
+	if (!entry)
+		return 0;
+	
+	dlist_del(&entry->list_head);
+	timer_remove(&entry->timer);
+	
+	free(entry);
+	
+	return 1;
+}
+
+blacklist_t *NS_CLASS blacklist_find(struct in_addr addr)
+{
+	dlist_head_t *pos;
+	
+	dlist_for_each(pos, &BLACKLIST)
+	{
+		blacklist_t *entry = (blacklist_t *) pos;
+		if (entry->addr.s_addr == addr.s_addr)
+			return entry;
+	}
+	
+	return NULL;
+}
diff -Naur ns-2.35-orig/dymoum/blacklist.h ns-2.35/dymoum/blacklist.h
--- ns-2.35-orig/dymoum/blacklist.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/blacklist.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,60 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __BLACKLIST_H__
+#define __BLACKLIST_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include "dlist.h"
+#include "timer_queue.h"
+
+#include <netinet/in.h>
+#include <sys/types.h>
+
+/* Here we maintain a list of those next hops which didn't reply with a unicast
+   packet when S-bit was enabled in a RREP. We won't forward RREQs which come
+   from these nodes. */
+
+#define BLACKLIST_TIMEOUT	5000
+
+typedef struct blacklist
+{
+	dlist_head_t	list_head;
+	struct in_addr	addr;
+	struct timer	timer;
+} blacklist_t;
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Add a new entry to the list */
+blacklist_t *blacklist_add(struct in_addr addr);
+
+/* Remove an entry from the list */
+int blacklist_remove(blacklist_t *entry);
+
+/* Find an entry in the list with the given address */
+blacklist_t *blacklist_find(struct in_addr addr);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __BLACKLIST_H__ */
diff -Naur ns-2.35-orig/dymoum/CHANGELOG ns-2.35/dymoum/CHANGELOG
--- ns-2.35-orig/dymoum/CHANGELOG	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/CHANGELOG	2006-08-30 19:38:48.000000000 +0200
@@ -0,0 +1,39 @@
+==================
+ DYMOUM CHANGELOG
+==================
+
+
+ v0.2 --> v0.3
+===============
+
+* Sequence numbers stuff has been changed to comply with draft 05.
+
+* RERRs are only sent when the broken route has been used.
+
+* Added simple link monitoring via HELLO messages. Just set a hello_ival
+  greater than 0 to enable it.
+
+* Now routes to the previous hop when a RE is received are only set if the
+  S bit is active. See an explanation in dymo_re.c.
+
+* DYMO_MAX_NR_INTERFACES is now the same in kdymo_main.c and in defs.h.
+
+* Route updates were never happening in Linux version because there was an
+  unregistered netfilter hook. Fixed.
+
+
+ v0.1 --> v0.2
+===============
+
+* RE processing has been changed to support draft-03 spec.
+
+* S-bit stuff is introduced to avoid unidirectional links. It's implemented
+  via ICMP ECHOREPLY messages.
+
+* Other several minor changes.
+
+
+
+Francisco J. Ros     <fjrm@dif.um.es>
+University of Murcia (Spain)
+
diff -Naur ns-2.35-orig/dymoum/debug.c ns-2.35/dymoum/debug.c
--- ns-2.35-orig/dymoum/debug.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/debug.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,86 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "debug.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+
+
+extern int debug, daemonize;
+#endif	/* NS_PORT */
+
+void NS_CLASS dlog_init()
+{
+#ifndef NS_PORT
+	int option = 0;
+	
+	if (debug && !daemonize)
+		option = LOG_PERROR;
+	
+	openlog("dymod", option, LOG_DAEMON);
+#endif	/* NS_PORT */
+}
+
+void NS_CLASS dlog_fini()
+{
+#ifndef NS_PORT
+	closelog();
+#endif	/* NS_PORT */
+}
+
+void NS_CLASS dlog(int pri, int errnum, const char *func, char *format, ...)
+{
+	va_list ap;
+	char msg[256];
+	
+	memset(msg, 0, sizeof(msg));
+	
+	va_start(ap, format);
+	vsprintf(msg, format, ap);
+	va_end(ap);
+	
+#ifndef NS_PORT
+	if (errnum != 0)
+		syslog(pri, "%s: %s: %s", func, msg, strerror(errnum));
+	else
+		syslog(pri, "%s: %s", func, msg);
+#else
+	debug("node %s: %s: %s\n", ip2str(ra_addr_), func, msg);
+#endif
+}
+
+char *NS_CLASS ip2str(u_int32_t ipaddr)
+{
+#ifndef NS_PORT
+	struct in_addr addr;
+	
+	addr.s_addr = ipaddr;
+	return inet_ntoa(addr);
+#else
+	return Address::instance().print_nodeaddr(ipaddr);
+#endif
+}
diff -Naur ns-2.35-orig/dymoum/debug.h ns-2.35/dymoum/debug.h
--- ns-2.35-orig/dymoum/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/debug.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,52 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#ifndef NS_NO_GLOBALS
+#include "defs.h"
+#include <syslog.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Open DYMOUM log */
+void dlog_init();
+
+/* Close DYMOUM log */
+void dlog_fini();
+
+/* Log a message given its priority, error number (if needed) and the function
+   where it occurred */
+void dlog(int pri, int errnum, const char *func, char *format, ...);
+
+/* Return a string representing a given IP address */
+char *ip2str(u_int32_t ipaddr);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __DEBUG_H__ */
diff -Naur ns-2.35-orig/dymoum/defs.h ns-2.35/dymoum/defs.h
--- ns-2.35-orig/dymoum/defs.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/defs.h	2006-08-30 19:15:03.000000000 +0200
@@ -0,0 +1,147 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DEFS_H__
+#define __DEFS_H__
+
+#ifndef NS_NO_GLOBALS
+
+#ifndef NS_PORT
+#include <net/if.h>
+#include <netinet/in.h>
+#define NS_CLASS
+#define NS_STATIC	static
+#define NS_INLINE	inline
+#else
+#define NS_CLASS	DYMOUM::
+#define NS_STATIC
+#define NS_INLINE	inline
+#define NS_DEV_NR	0
+#define NS_IFINDEX	0
+#endif	/* NS_PORT */
+
+/* Version information */
+#define DYMO_UM_VERSION "0.3"
+#define DYMO_DRAFT_VERSION "Draft-05"
+
+/* Misc defines */
+#ifndef MAX
+#define MAX(a,b) ((a) > (b) ? (a) : (b))
+#endif	/* MAX */
+
+#ifndef MIN
+#define MIN(a,b) ((a) < (b) ? (a) : (b))
+#endif	/* MIN */
+
+#ifndef NULL
+#define NULL ((void *) 0)
+#endif	/* NULL */
+
+#ifndef IFNAMSIZ
+#define IFNAMSIZ 16
+#endif	/* IFNAMSIZ */
+
+/* Maximum number of interfaces per node */
+#define DYMO_MAX_NR_INTERFACES 4
+
+/* Returns a dev_info struct given its corresponding iface index */
+#define DEV_IFINDEX(ifindex) (this_host.devs[ifindex2devindex(ifindex)])
+
+/* Returns a dev_info struct given its corresponding device number */
+#define DEV_NR(n) (this_host.devs[n])
+
+/* Data for a network device */
+struct dev_info {
+    int			enabled;	 /* 1 if struct is used, else 0 */
+    int			sock;		 /* DYMO socket associated with this device */
+    int			icmp_sock;	 /* Raw socket used to send/receive ICMP messages */
+    u_int32_t		ifindex;	 /* Index for this interface */
+    char		ifname[IFNAMSIZ];/* Interface name */
+    struct in_addr	ipaddr;		 /* The local IP address */
+    struct in_addr	bcast;		 /* Broadcast address */
+};
+
+/* Data for a host */
+struct host_info {
+    u_int32_t		seqnum;		/* Sequence number */
+    u_int8_t		prefix : 7;	/* Prefix */
+    u_int8_t		is_gw : 1;	/* Is this host a gateway? */
+    int			nif;		/* Number of interfaces to broadcast on */
+    struct dev_info	devs[DYMO_MAX_NR_INTERFACES];
+};
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Information about this host */
+struct host_info this_host;
+
+/* Array of interface indices */
+u_int32_t dev_indices[DYMO_MAX_NR_INTERFACES];
+
+/* Given a network interface index, returns the index into the
+   devs array */
+NS_STATIC NS_INLINE int ifindex2devindex(u_int32_t ifindex)
+{
+	int i;
+	for (i = 0; i < this_host.nif; i++)
+		if (dev_indices[i] == ifindex)
+			return i;
+	return -1;
+}
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#ifndef NS_PORT
+
+/* Callback functions */
+typedef void (*callback_func_t) (int);
+int attach_callback_func(int fd, callback_func_t func);
+
+/* Given a socket descriptor, returns the corresponding dev_info
+   struct */
+static inline struct dev_info *devfromsock(int sock)
+{
+	int i;
+	
+	for (i = 0; i < this_host.nif; i++)
+		if (this_host.devs[i].sock == sock)
+			return &this_host.devs[i];
+	
+	return NULL;
+}
+
+/* Given an ICMP socket descriptor, returns the corresponding dev_info
+   struct */
+static inline struct dev_info *devfromicmpsock(int icmp_sock)
+{
+	int i;
+	
+	for (i = 0; i < this_host.nif; i++)
+		if (this_host.devs[i].icmp_sock == icmp_sock)
+			return &this_host.devs[i];
+	
+	return NULL;
+}
+
+#endif	/* NS_PORT */
+
+#endif	/* __DEFS_H__ */
diff -Naur ns-2.35-orig/dymoum/dlist.h ns-2.35/dymoum/dlist.h
--- ns-2.35-orig/dymoum/dlist.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dlist.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,124 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DLIST_H__
+#define __DLIST_H__
+
+#include "defs.h"
+
+/* Doubly linked list based on the Linux kernel implementation */
+
+#define DLIST_SUCCESS	0
+#define DLIST_FAILURE	-1
+
+typedef struct dlist_head
+{
+	struct dlist_head *next, *prev;
+} dlist_head_t;
+
+#define DLIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define DLIST_HEAD(name) \
+	struct dlist_head name = DLIST_HEAD_INIT(name)
+
+#define INIT_DLIST_ELEM(e) do { \
+	(e)->prev = NULL; (e)->next = NULL; \
+} while (0)
+
+#define INIT_DLIST_HEAD(h) do { \
+	(h)->prev = (h); (h)->next = (h); \
+} while (0)
+
+/* Internal use only */
+static inline void __dlist_add(struct dlist_head *n,
+				struct dlist_head *prev,
+				struct dlist_head *next)
+{
+	next->prev = n;
+	n->next = next;
+	n->prev = prev;
+	prev->next = n;
+}
+
+/* Useful for implementing stacks */
+static inline int dlist_add(struct dlist_head *n, struct dlist_head *head)
+{
+	if (n && head)
+	{
+		__dlist_add(n, head, head->next);
+		return DLIST_SUCCESS;
+	}
+	return DLIST_FAILURE;
+}
+
+/* Useful for implementing queues */
+static inline int dlist_add_tail(struct dlist_head *n, struct dlist_head *head)
+{
+	if (n && head)
+	{
+		__dlist_add(n, head->prev, head);
+		return DLIST_SUCCESS;
+	}
+	return DLIST_FAILURE;
+}
+
+/* Isn't the element attached to a list? */
+static inline int dlist_unattached(struct dlist_head *head)
+{
+	return (head->prev == NULL && head->next == NULL);
+}
+
+/* Internal use only */
+static inline void __dlist_del(struct dlist_head * prev, struct dlist_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/* Dettaches the entry from the list */
+static inline int dlist_del(struct dlist_head *entry)
+{
+	if (entry)
+	{
+		__dlist_del(entry->prev, entry->next);
+		entry->next = NULL;
+		entry->prev = NULL;
+		return DLIST_SUCCESS;
+	}
+	return DLIST_FAILURE;
+}
+
+/* Is an empty list? */
+static inline int dlist_empty(const struct dlist_head *head)
+{
+	return (head->next == head);
+}
+
+/* Iterate over the list */
+#define dlist_for_each(pos, head) \
+        for (pos = (head)->next; pos != (head); pos = pos->next)
+
+/* Iterate over the list when you want to delete some element(s) during the
+   loop */
+#define dlist_for_each_safe(pos, n, head) \
+        for (pos = (head)->next, n = pos->next; pos != (head); \
+                pos = n, n = pos->next)
+
+#endif	/* __DLIST_H__ */
diff -Naur ns-2.35-orig/dymoum/Doxyfile ns-2.35/dymoum/Doxyfile
--- ns-2.35-orig/dymoum/Doxyfile	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/Doxyfile	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,275 @@
+# Doxyfile 1.4.1-KDevelop
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+PROJECT_NAME           = dymo_um.kdevelop
+PROJECT_NUMBER         = 0.1
+OUTPUT_DIRECTORY       = 
+CREATE_SUBDIRS         = NO
+OUTPUT_LANGUAGE        = English
+USE_WINDOWS_ENCODING   = NO
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = YES
+STRIP_FROM_PATH        = /home/fran/devel/sntraced/
+STRIP_FROM_INC_PATH    = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = NO
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = NO
+INHERIT_DOCS           = YES
+DISTRIBUTE_GROUP_DOC   = NO
+TAB_SIZE               = 8
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = NO
+OPTIMIZE_OUTPUT_JAVA   = NO
+SUBGROUPING            = YES
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = NO
+EXTRACT_PRIVATE        = NO
+EXTRACT_STATIC         = NO
+EXTRACT_LOCAL_CLASSES  = YES
+EXTRACT_LOCAL_METHODS  = NO
+HIDE_UNDOC_MEMBERS     = NO
+HIDE_UNDOC_CLASSES     = NO
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = YES
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = NO
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = YES
+SHOW_DIRECTORIES       = YES
+FILE_VERSION_FILTER    = 
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = YES
+WARN_IF_DOC_ERROR      = YES
+WARN_NO_PARAMDOC       = NO
+WARN_FORMAT            = "$file:$line: $text"
+WARN_LOGFILE           = 
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = /home/fran/devel/dymoum-0.2
+FILE_PATTERNS          = *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.idl \
+                         *.odl \
+                         *.cs \
+                         *.php \
+                         *.php3 \
+                         *.inc \
+                         *.m \
+                         *.mm \
+                         *.dox \
+                         *.C \
+                         *.CC \
+                         *.C++ \
+                         *.II \
+                         *.I++ \
+                         *.H \
+                         *.HH \
+                         *.H++ \
+                         *.CS \
+                         *.PHP \
+                         *.PHP3 \
+                         *.M \
+                         *.MM \
+                         *.C \
+                         *.H \
+                         *.tlh \
+                         *.diff \
+                         *.patch \
+                         *.moc \
+                         *.xpm \
+                         *.dox
+RECURSIVE              = yes
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXAMPLE_PATH           = 
+EXAMPLE_PATTERNS       = *
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = 
+INPUT_FILTER           = 
+FILTER_PATTERNS        = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+SOURCE_BROWSER         = NO
+INLINE_SOURCES         = NO
+STRIP_CODE_COMMENTS    = YES
+REFERENCED_BY_RELATION = YES
+REFERENCES_RELATION    = YES
+VERBATIM_HEADERS       = YES
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+ALPHABETICAL_INDEX     = NO
+COLS_IN_ALPHA_INDEX    = 5
+IGNORE_PREFIX          = 
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+GENERATE_HTML          = YES
+HTML_OUTPUT            = html
+HTML_FILE_EXTENSION    = .html
+HTML_HEADER            = 
+HTML_FOOTER            = 
+HTML_STYLESHEET        = 
+HTML_ALIGN_MEMBERS     = YES
+GENERATE_HTMLHELP      = NO
+CHM_FILE               = 
+HHC_LOCATION           = 
+GENERATE_CHI           = NO
+BINARY_TOC             = NO
+TOC_EXPAND             = NO
+DISABLE_INDEX          = NO
+ENUM_VALUES_PER_LINE   = 4
+GENERATE_TREEVIEW      = NO
+TREEVIEW_WIDTH         = 250
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+GENERATE_LATEX         = YES
+LATEX_OUTPUT           = latex
+LATEX_CMD_NAME         = latex
+MAKEINDEX_CMD_NAME     = makeindex
+COMPACT_LATEX          = NO
+PAPER_TYPE             = a4wide
+EXTRA_PACKAGES         = 
+LATEX_HEADER           = 
+PDF_HYPERLINKS         = NO
+USE_PDFLATEX           = NO
+LATEX_BATCHMODE        = NO
+LATEX_HIDE_INDICES     = NO
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+GENERATE_RTF           = NO
+RTF_OUTPUT             = rtf
+COMPACT_RTF            = NO
+RTF_HYPERLINKS         = NO
+RTF_STYLESHEET_FILE    = 
+RTF_EXTENSIONS_FILE    = 
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+GENERATE_MAN           = NO
+MAN_OUTPUT             = man
+MAN_EXTENSION          = .3
+MAN_LINKS              = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = yes
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = YES
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+GENERATE_AUTOGEN_DEF   = NO
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+GENERATE_PERLMOD       = NO
+PERLMOD_LATEX          = NO
+PERLMOD_PRETTY         = YES
+PERLMOD_MAKEVAR_PREFIX = 
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = NO
+EXPAND_ONLY_PREDEF     = NO
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = 
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+TAGFILES               = 
+GENERATE_TAGFILE       = dymo_um.tag
+ALLEXTERNALS           = NO
+EXTERNAL_GROUPS        = YES
+PERL_PATH              = /usr/bin/perl
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+CLASS_DIAGRAMS         = YES
+HIDE_UNDOC_RELATIONS   = YES
+HAVE_DOT               = NO
+CLASS_GRAPH            = YES
+COLLABORATION_GRAPH    = YES
+GROUP_GRAPHS           = YES
+UML_LOOK               = NO
+TEMPLATE_RELATIONS     = NO
+INCLUDE_GRAPH          = YES
+INCLUDED_BY_GRAPH      = YES
+CALL_GRAPH             = NO
+GRAPHICAL_HIERARCHY    = YES
+DIRECTORY_GRAPH        = YES
+DOT_IMAGE_FORMAT       = png
+DOT_PATH               = 
+DOTFILE_DIRS           = 
+MAX_DOT_GRAPH_WIDTH    = 1024
+MAX_DOT_GRAPH_HEIGHT   = 1024
+MAX_DOT_GRAPH_DEPTH    = 1000
+DOT_TRANSPARENT        = NO
+DOT_MULTI_TARGETS      = NO
+GENERATE_LEGEND        = YES
+DOT_CLEANUP            = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO
diff -Naur ns-2.35-orig/dymoum/draft-ietf-manet-dymo-05.txt ns-2.35/dymoum/draft-ietf-manet-dymo-05.txt
--- ns-2.35-orig/dymoum/draft-ietf-manet-dymo-05.txt	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/draft-ietf-manet-dymo-05.txt	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,1680 @@
+
+
+
+Mobile Ad hoc Networks Working                               I. Chakeres
+Group                                                             Boeing
+Internet-Draft                                                C. Perkins
+Expires: December 22, 2006                                         Nokia
+                                                           June 20, 2006
+
+
+                 Dynamic MANET On-demand (DYMO) Routing
+                        draft-ietf-manet-dymo-05
+
+Status of this Memo
+
+   By submitting this Internet-Draft, each author represents that any
+   applicable patent or other IPR claims of which he or she is aware
+   have been or will be disclosed, and any of which he or she becomes
+   aware will be disclosed, in accordance with Section 6 of BCP 79.
+
+   Internet-Drafts are working documents of the Internet Engineering
+   Task Force (IETF), its areas, and its working groups.  Note that
+   other groups may also distribute working documents as Internet-
+   Drafts.
+
+   Internet-Drafts are draft documents valid for a maximum of six months
+   and may be updated, replaced, or obsoleted by other documents at any
+   time.  It is inappropriate to use Internet-Drafts as reference
+   material or to cite them other than as "work in progress."
+
+   The list of current Internet-Drafts can be accessed at
+   http://www.ietf.org/ietf/1id-abstracts.txt.
+
+   The list of Internet-Draft Shadow Directories can be accessed at
+   http://www.ietf.org/shadow.html.
+
+   This Internet-Draft will expire on December 22, 2006.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2006).
+
+Abstract
+
+   The Dynamic MANET On-demand (DYMO) routing protocol is intended for
+   use by mobile nodes in wireless multihop networks.  It offers
+   adaptation to changing network topology and determines unicast routes
+   between nodes within the network on-demand.
+
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006               [Page 1]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+Table of Contents
+
+   1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  4
+   2.  Applicability  . . . . . . . . . . . . . . . . . . . . . . . .  4
+   3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  5
+   4.  Data Structures  . . . . . . . . . . . . . . . . . . . . . . .  6
+     4.1.  Route Table Entry  . . . . . . . . . . . . . . . . . . . .  6
+     4.2.  DYMO Messages  . . . . . . . . . . . . . . . . . . . . . .  7
+       4.2.1.  Generalized MANET Packet and Message Structure . . . .  7
+       4.2.2.  Routing Message (RM) . . . . . . . . . . . . . . . . .  8
+       4.2.3.  Route Error (RERR) . . . . . . . . . . . . . . . . . . 10
+   5.  Detailed Operation . . . . . . . . . . . . . . . . . . . . . . 12
+     5.1.  DYMO Sequence Numbers  . . . . . . . . . . . . . . . . . . 12
+       5.1.1.  Maintaining A Node's Own Sequence Number . . . . . . . 12
+       5.1.2.  Incrementing a Sequence Number . . . . . . . . . . . . 13
+       5.1.3.  Sequence Number Rollover . . . . . . . . . . . . . . . 13
+       5.1.4.  Actions After Sequence Number Loss . . . . . . . . . . 13
+     5.2.  DYMO Routing Table Operations  . . . . . . . . . . . . . . 13
+       5.2.1.  Judging New Routing Information's Usefulness . . . . . 13
+       5.2.2.  Updating a Route Table Entry with Fresh Routing
+               Information  . . . . . . . . . . . . . . . . . . . . . 14
+       5.2.3.  Route Table Entry Timeouts . . . . . . . . . . . . . . 15
+     5.3.  Routing Message  . . . . . . . . . . . . . . . . . . . . . 15
+       5.3.1.  RREQ Creation  . . . . . . . . . . . . . . . . . . . . 15
+       5.3.2.  RREP Creation  . . . . . . . . . . . . . . . . . . . . 16
+       5.3.3.  RM Processing  . . . . . . . . . . . . . . . . . . . . 16
+       5.3.4.  Adding Additional Routing Information to a RM  . . . . 18
+     5.4.  Route Discovery  . . . . . . . . . . . . . . . . . . . . . 18
+     5.5.  Route Maintenance  . . . . . . . . . . . . . . . . . . . . 19
+       5.5.1.  Active Link Monitoring . . . . . . . . . . . . . . . . 19
+       5.5.2.  Updating Route Lifetimes during Packet Forwarding  . . 20
+       5.5.3.  Route Error Generation . . . . . . . . . . . . . . . . 20
+       5.5.4.  Route Error Processing . . . . . . . . . . . . . . . . 21
+     5.6.  General DYMO Packet and Message Processing . . . . . . . . 21
+       5.6.1.  Receiving Packets  . . . . . . . . . . . . . . . . . . 21
+       5.6.2.  Processing Unknown Message and TLV Types . . . . . . . 21
+     5.7.  Network Addresses  . . . . . . . . . . . . . . . . . . . . 22
+     5.8.  Simple Internet Attachment and Gatewaying  . . . . . . . . 22
+     5.9.  Multiple Interfaces  . . . . . . . . . . . . . . . . . . . 23
+     5.10. Packet Generation Limits . . . . . . . . . . . . . . . . . 24
+   6.  Configuration Parameters . . . . . . . . . . . . . . . . . . . 24
+   7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 24
+     7.1.  DYMO Message Type Specification  . . . . . . . . . . . . . 25
+     7.2.  Packet TLV Type Specification  . . . . . . . . . . . . . . 25
+     7.3.  Address Block TLV Specification  . . . . . . . . . . . . . 26
+   8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 26
+   9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 27
+   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 27
+
+
+
+Chakeres & Perkins      Expires December 22, 2006               [Page 2]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+     10.1. Normative References . . . . . . . . . . . . . . . . . . . 27
+     10.2. Informative References . . . . . . . . . . . . . . . . . . 28
+   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 29
+   Intellectual Property and Copyright Statements . . . . . . . . . . 30
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006               [Page 3]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+1.  Overview
+
+   The Dynamic MANET On-demand (DYMO) routing protocol enables reactive,
+   multihop routing between participating nodes that wish to
+   communicate.  The basic operations of the DYMO protocol are route
+   discovery and route management.  During route discovery the
+   originating node initiates dissemination of a Route Request (RREQ)
+   throughout the network to find the target node.  During this
+   dissemination process, each intermediate node records a route to the
+   originating node.  When the target node receives the RREQ, it
+   responds with a Route Reply (RREP) unicast toward the originating
+   node.  Each node that receives the RREP records a route to the target
+   node, and then the RREP is unicast toward the originating node.  When
+   the originating node receives the RREP, routes have then been
+   established between the originating node and the target node in both
+   directions.
+
+   In order to react to changes in the network topology nodes maintain
+   their routes and monitor their links.  When a data packet is received
+   for a route or link that is no longer available the source of the
+   packet is notified.  A Route Error (RERR) is sent to the packet
+   source to indicate the current route is broken.  Once the source
+   receives the RERR, it can perform route discovery if it still has
+   packets to deliver.
+
+   DYMO uses sequence numbers as they have been proven to ensure loop
+   freedom [Perkins99].  Sequence numbers enable nodes to determine the
+   order of DYMO route discovery messages, thereby avoiding use of stale
+   routing information.
+
+
+2.  Applicability
+
+   The DYMO routing protocol is designed for mobile ad hoc networks in
+   small, medium, and large node populations.  DYMO handles all mobility
+   ranges.  DYMO can handle various traffic patterns, but is most suited
+   for sparse traffic sources and destinations.  DYMO is designed for
+   network where trust is assumed, since it depends on nodes properly
+   forwarding traffic to the next hop toward the destination on behalf
+   of the source.
+
+   DYMO is applicable to memory constrained devices, since little
+   routing state needs to be maintained.  Only routing information
+   related to active destinations must be maintained, as opposed to
+   other routing protocols where routing information to all destinations
+   or a large population destinations must be maintained.
+
+   The routing algorithm in DYMO may be operated at layers other than
+
+
+
+Chakeres & Perkins      Expires December 22, 2006               [Page 4]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   the network layer, using layer-appropriate addresses.  Only
+   modification of the packet format is required.  The routing algorithm
+   need not change.
+
+
+3.  Terminology
+
+   The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
+   NOT","SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in
+   this document are to be interpreted as described in RFC2119
+   [RFC2119].
+
+   This document defines the following terminology:
+
+   DYMO Sequence Number (SeqNum)
+      A DYMO Sequence Number is maintained by each node.  This sequence
+      number is used to identify the freshness of related routing
+      information and to ensure loop-free routes.
+
+   Hop Count (HopCnt)
+      The number of IP hops a message or piece of information must
+      traverse to reach the node holding this information.
+
+   Originator (Orig)
+      The originator is the node that created a DYMO Message in an
+      effort to disseminate information.
+
+   Route Error (RERR)
+      A node generates a RERR to disseminate that it does not have valid
+      route to a particular destination, or set of destinations.
+
+   Route Reply (RREP)
+      Upon receiving a RREQ during route discovery, the target node
+      generates a Route Reply (RREP).  A RREP is used to disseminate
+      routing information, on how to reach the target, to nodes between
+      the target and the RREQ originator.
+
+   Route Request (RREQ)
+      A node generates a RREQ to discover a valid route to a particular
+      destination, called the target.  A RREQ also disseminates routing
+      information on how to reach the originator of the RREQ.
+
+   Target
+      The target node is the ultimate destination of a message.  For
+      RREQ the target is the desired destination.  For RREP the target
+      is the originator of the RREQ.
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006               [Page 5]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   Valid Route
+      A valid route is a known route where the Route.ValidTimeout is
+      greater than the current time.  Valid routes may be used to
+      forward data.
+
+   When describing DYMO messages, information found in the:
+
+   IP header is proceeded with 'IP.'
+
+   UDP header is proceeded with 'UDP.'
+
+   packetbb message header is proceeded with 'MsgHdr.'
+
+   packetbb message TLVs is proceeded with 'MsgTLV.'
+
+   packetbb address blocks is proceeded with 'AddBlk.'
+
+   packetbb address block TLVs is proceeded with 'AddTLV.'
+
+
+4.  Data Structures
+
+4.1.  Route Table Entry
+
+   The route table entry is a conceptual data structure.
+   Implementations may use any internal representation that conforms to
+   the semantics of a route as specified in this document.  The number
+   zero (0) is reserved and can be used to indicate that the field value
+   for this routing entry is unknown or invalid.
+
+   A routing table entry has the following fields:
+
+   Route.Address
+      The IP destination address of the node associated with the routing
+      table entry.
+
+   Route.SeqNum
+      The DYMO SeqNum associated with this routing information.
+
+   Route.NextHopAddress
+      The IP address of the next node on the path toward the
+      Route.Address.
+
+   Route.NextHopInterface
+      The interface used to send packets toward the Route.Address.
+
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006               [Page 6]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   Route.ValidTimeout
+      The time at which a route table entry is no longer valid.
+
+   Route.DeleteTimeout
+      If the current time is after Route.DeleteTimeout the corresponding
+      routing table entry MUST be deleted.
+
+   The following fields are optional:
+
+   Route.HopCnt
+      The number of intermediate node hops traversed before reaching the
+      Route.Address node.
+
+   Route.IsInternetGateway
+      1-bit selector indicating whether the Route.Address is a an
+      Internet gateway, see Section 5.8.
+
+   Route.Prefix
+      Indicates that the associated address is a network address, rather
+      than a host address.  The value is the length of the netmask/
+      prefix.  If prefix is set to zero (0), unknown, or equal to the
+      address length in bits, this address is a host address.  The
+      definition of Route.Prefix is different for gateways; entries with
+      Route.IsInternetGateway set to one (1), seeSection 5.8.
+
+   Route.Used
+      1-bit selector indicating whether this Route has been used to
+      forward data toward the destination.
+
+   Not including this optional information may result in sub-optimal
+   performance, but it is not required for correct protocol operation.
+
+4.2.  DYMO Messages
+
+4.2.1.  Generalized MANET Packet and Message Structure
+
+   All DYMO messages conform to the generalized packet and message
+   format as described in[I-D.ietf-manet-packetbb].
+
+   All DYMO messages are sent using UDP to the destination port TBD.
+
+   All DYMO messages are sent with the IP destination address set to the
+   link local multicast address LL_ALL_MANET_ROUTER unless otherwise
+   stated.
+
+   The IP TTL (IP Hop Limit) field for all DYMO messages is set to one
+   (1).
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006               [Page 7]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   The length of IP addresses (32-bits for IPv4 and 128-bits for IPv6)
+   inside DYMO messages are dependent on the IP packet header.  For
+   example, if the IP header uses IPv6 addresses then all messages and
+   addresses contained in the payload use IPv6 addresses.  In the case
+   of mixed IPv6 and IPv4 addresses, IPv4 addresses are carried in IPv6
+   as specified in [RFC3513].
+
+4.2.2.  Routing Message (RM)
+
+   Routing Messages (RM) are used to disseminate routing information.
+   There are two DYMO message types that are RM, RREQ and RREP.  They
+   contain the same information, but have slightly different processing
+   rules.  The fundamental difference between the two messages are that
+   RREQ messages require a response; while a RREP is the response to
+   RREQ.
+
+   RM creation and processing are described in Section 5.3.
+
+   A RM requires the following information:
+
+   IP.DestinationAddress
+      The IP address of the packet destination.
+
+   MsgHdr.HopLimit
+      The remaining number of hops this message may traverse.
+
+   AddBlk.Target.Address
+      The IP address of the message target.  In RREQ the target is the
+      unknown destination.  In RREP the target is the RREQ originator.
+      Only one address can be marked as the target.
+
+   AddBlk.Orig.Address
+      The IP address of the message originator.  This address is in an
+      address block and not in the message header to allow for address
+      compression and additional AddTLVs.
+
+   AddTLV.Orig.SeqNum
+      The DYMO sequence number of the message originator.
+
+   A RM may optionally include the following information:
+
+   AddTLV.Target.SeqNum
+      The last known DYMO sequence number of the target.  If the
+      AddTLV.Target.SeqNum is set to zero (0), then only the destination
+      may respond to this RREQ.
+
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006               [Page 8]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   AddBlk.AdditionalNode.Address
+      The IP address of an additional node that can be reached via the
+      node adding this information.  Each AdditionalNode.Address must
+      have an associated SeqNum in the message.
+
+   AddTLV.AdditionalNode.SeqNum
+      The DYMO sequence number of the additional node's routing
+      information.
+
+   AddTLV.Node.HopCnt
+      The number of IP hops to reach the associated Node.Address.
+
+   AddTLV.Node.Prefix
+      The Node.Address is a network address ([I-D.ietf-manet-packetbb]).
+
+   AddTLV.Node.IsGateway
+      This AddTLV indicates that the Internet is reachable via this
+      node.  That is, all nodes outside this Node's prefix are reachable
+      via the advertising Node.
+
+   AddTLV.Node.IsTarget
+      If the target is not the first address in the address blocks, this
+      AddTLV is used to indicate the target.
+
+   AddTLV.Node.IsOriginator
+      In the event that the originator is not the second address in the
+      address blocks, this AddTLV is used to indicate the originator.
+
+   AddTLV.AdditionalNode.IsOffPath
+      This AddTLV is used to indicate that a node is not on the path
+      between the originator and the target.
+
+   AddTLV.Node.Ignore
+      If the information associated with this Node.Address should not be
+      used create or update a route, this flag is set.
+
+   Not including this optional information may result in sub-optimal
+   performance, but it is not required for correct protocol operation.
+
+
+
+
+
+
+
+
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006               [Page 9]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   Example IPv4 RREQ
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+
+   IP Header
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |         IP.DestinationAddress=LL_ALL_MANET_ROUTERS            |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   ...
+
+   UDP Header
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |     Destination Port=TBD      |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   ...
+   Message Header
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |   RREQ-type   |  Resv   |0|0|1|         msg-size=24           |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       | msg-hoplimit  |  msg-hopcnt   |      msg-tlv-block-size=0     |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   ...
+   Address Block
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |Number Addrs=2 |0|HeadLength=24|             Head              :
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       :  Head (cont)  |  Target.Tail  |   Orig.Tail   |  TLV-blk-size :
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       : size=7 (cont) |
+       +-+-+-+-+-+-+-+-+
+   ...
+   Address TLVs
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |DYMOSeqNum-type| Resv  |1|0|0|0| Index Start=1 | Index Stop=1  |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       | tlv-length=16 |          Orig.SeqNum          |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+
+   Figure 1
+
+4.2.3.  Route Error (RERR)
+
+   RERR are used to disseminate that a valid route is not available for
+   a particular destination, or set of destinations.
+
+   RERR creation and processing are described in Section 5.5.3 and
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 10]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   Section 5.5.4.
+
+   A RERR requires the following information:
+
+   IP.DestinationAddress
+      The IP address of the packet destination.
+
+   MsgHdr.HopLimit
+      The remaining number of hops this message may traverse.
+
+   AddBlk.Unreachable.Address
+      The IP address of an Unreachable Node.  Multiple Unreachable
+      Addresses may be included.  If a SeqNum for this address is not
+      included, it is assumed to be unknown.
+
+   A Route Error may optionally include the following information:
+
+   AddTLV.Unreachable.SeqNum
+      The DYMO sequence number of the Unreachable Node.
+
+   AddTLV.Node.Ignore
+      If the information associated with Node.Address should not be used
+      to invalidate routes, this flag is set.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 11]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   Example IPv4 RERR
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+
+   IP Header
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |         IP.DestinationAddress=LL_ALL_MANET_ROUTERS            |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   ...
+
+   UDP Header
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |     Destination Port=TBD      |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   ...
+   Message Header
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |   RERR-type   |  Resv   |0|0|1|         msg-size=16           |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       | msg-hoplimit  |  msg-hopcnt   |      msg-tlv-block-size=0     |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   ...
+   Address Block
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |Number Addrs=1 |0|HeadLength=0 |       Unreachable.Addr        :
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       :    Unreachable.Addr (cont)    |        TLV-blk-size=0         |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+
+   Figure 2
+
+
+5.  Detailed Operation
+
+5.1.  DYMO Sequence Numbers
+
+   DYMO sequence numbers allow nodes to judge the freshness of routing
+   information, and ensure loop freedom.
+
+5.1.1.  Maintaining A Node's Own Sequence Number
+
+   DYMO requires a each node in the network to maintain its own DYMO
+   sequence number (OwnSeqNum), a 16-bit unsigned integer.  The
+   circumstances for a node to incrementing its OwnSeqNum are described
+   in Section 5.3.
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 12]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+5.1.2.  Incrementing a Sequence Number
+
+   When a node increments its OwnSeqNum (as described in Section 5.3) it
+   MUST do so by treating the sequence number value as if it was an
+   unsigned number.  The sequence number zero (0) is reserved and is
+   used in several DYMO data structures to represent an unknown sequence
+   number.
+
+5.1.3.  Sequence Number Rollover
+
+   If the sequence number has been assigned to be the largest possible
+   number representable as a 16-bit unsigned integer (i.e., 65535), then
+   the sequence number MUST be set to 256 when incremented.  Setting the
+   sequence number to 256 allows other nodes to detect that the number
+   has rolled over and the node has not lost its sequence number.
+
+5.1.4.  Actions After Sequence Number Loss
+
+   A node can maintain its sequence number in persistent storage,
+   between reboots.
+
+   If a node's OwnSeqNum is lost, it must take certain actions to avoid
+   creating routing loops.  To prevent this possibility after OwnSeqNum
+   loss a node MUST wait for at least ROUTE_DELETE_PERIOD before fully
+   participating in the DYMO routing protocol.  If a DYMO control
+   message is received during this waiting period, the node SHOULD
+   process it normally but MUST not transmit or retransmit any DYMO
+   messages.  If a data packet is received for forwarding to another
+   destination during this waiting period, the node MUST generate a RERR
+   message indicating that this route is not available and reset its
+   waiting period.  RERR generation is described in Section 5.5.3.  At
+   the end of the waiting period a node sets its OwnSeqNum to one (1).
+
+5.2.  DYMO Routing Table Operations
+
+5.2.1.  Judging New Routing Information's Usefulness
+
+   Given a routing table entry (Route.SeqNum, Route.HopCnt, and
+   Route.ValidTimeout) and new routing information for a particular node
+   in a RM (Node.SeqNum, Node.HopCnt, and RM message type - RREQ/RREP),
+   the quality of the new routing information is evaluated to determine
+   its usefulness.  The following comparisons are performed in order:
+
+   1. Stale
+      If Node.SeqNum - Route.SeqNum < 0 (using signed 16-bit arithmetic)
+      the information is stale.  Using stale routing information is not
+      allowed, since doing so might result in routing loops.
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 13]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   2. Loop-prone
+      If Node.SeqNum == Route.SeqNum the information maybe loop-prone,
+      additional information must be examined.  If Route.HopCnt is
+      unknown or set to zero (0), then the routing information is loop-
+      prone.  Likewise, if Node.HopCnt is unknown or set to zero (0),
+      then the routing information is loop-prone.  If Node.HopCnt >
+      Route.HopCnt + 1, then the routing information is loop-prone.
+      Using loop-prone routing information is not allowed, since doing
+      so might result in routing loops.
+
+   3. Inferior
+      If Node.SeqNum == Route.SeqNum the information may be inferior,
+      additional information must be examined.  If the route is valid
+      (by examining Route.ValidTimeout and the current time), then the
+      new information is inferior if Node.HopCnt > Route.HopCnt.  If the
+      route is valid, then the new information is also inferior if
+      Node.HopCnt == Route.HopCnt AND this RM is a RREQ.
+
+   4. Fresh
+      Routing information that does not match any of the above criteria
+      is loop-free and better than the information existing in the
+      routing table.  Only this type of information is used to update
+      the routing table.
+
+5.2.2.  Updating a Route Table Entry with Fresh Routing Information
+
+   If fresh routing information is received, the routing table entry is
+   populated with the following information:
+
+   1.  the Route.Address is set to Node.Address,
+
+   2.  the Route.SeqNum is set to the Node.SeqNum,
+
+   3.  the Route.NextHopAddress is set to the node that transmitted this
+       DYMO packet (IP.SourceAddress),
+
+   4.  the Route.NextHopInterface is set to the interface that this DYMO
+       packet was received on,
+
+   5.  the Route.ValidTimeout is set to the current time +
+       ROUTE_VALID_TIMEOUT,
+
+   6.  the Route.HopCnt is set to the Node.HopCnt,
+
+   7.  the Route.Prefix is set to the Node.Prefix,
+
+   8.  the Route.IsInternetGateway is set if address is an Internet
+       Gateway.
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 14]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   Unknown values are set to zero (0).
+
+   If a valid route exists to Node.Address at this point, the route can
+   be used to send any queued data packets and to fulfill any
+   outstanding RREQ.
+
+5.2.3.  Route Table Entry Timeouts
+
+   Before using a routing table entry its timeouts must be examined.
+
+   If the current time is after Route.DeleteTimeout the corresponding
+   routing table entry MUST be deleted.
+
+   If the current time is later than a routing entry's
+   Route.ValidTimeout, the route is stale and cannot be used to route
+   packets.  The information in invalid entries is still used for
+   filling fields in outgoing RM with last known values.
+
+5.3.  Routing Message
+
+5.3.1.  RREQ Creation
+
+   When a node creates a RREQ it SHOULD increment its OwnSeqNum by one
+   (1) according to the rules specified in (Section 5.1.2).
+
+   Fist, the node adds the AddBlk.Target.Address to the RM.
+
+   If a previous value of the Target.SeqNum is known (from an existing
+   routing table entry), it SHOULD be placed in AddTLV.Target.SeqNum.
+   If a Target.SeqNum is not included, it is assumed to be unknown by
+   processing nodes and only the target is allowed to respond.  A
+   Target.SeqNum of zero (0) MAY be set to indicate that any node with
+   valid routing information about this destination can respond to this
+   RREQ if the node is so enabled, though the process for doing so is
+   not described in this document.
+
+   Similarly, if a previous value of the Target.HopCnt is known, it
+   SHOULD be placed in AddTLV.Target.HopCnt.  Otherwise, the HopCnt is
+   not included and assumed unknown by processing nodes.
+
+   These AddTLVs associated with the target SHOULD be set to maximum
+   protocol efficiency, but they may be omitted to reduce message size.
+
+   Next, the node adds AddBlk.Orig.Address to the RM and the
+   AddTLV.Orig.SeqNum (OwnSeqNum) in an address block TLV.  The
+   Orig.Address is this node's primary addresses/identifier.  The
+   Orig.Address must be a routable IP address.
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 15]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   Other AddTLVs for the originator SHOULD be set to maximum protocol
+   efficiency, but they may be omitted to reduce message size.
+
+   The MsgHdr.HopCnt is set to zero (0).  The MsgHdr.HopLimit SHOULD be
+   set to NET_DIAMETER, but MAY be set smaller.  For RREQ, the
+   MsgHdr.HopLimit MAY be set in accordance with an expanding ring
+   search as described in [RFC3561] to limit the RREQ propagation to a
+   subset of the network and possibly reduce route discovery overhead.
+
+5.3.2.  RREP Creation
+
+   When a node creates a RREP in response to a RREQ, it MUST increment
+   its OwnSeqNum under the following conditions:
+
+   o  Target.SeqNum is not included in the message, OR
+
+   o  Target.SeqNum is zero (0), OR
+
+   o  Target.SeqNum - OwnSeqNum > 0 (using 16-bit signed arithmetic), OR
+
+   o  Target.SeqNum == OwnSeqNum AND Target.HopCnt is unknown, OR
+
+   o  Target.SeqNum == OwnSeqNum AND Orig.HopCnt is unknown, OR
+
+   o  Target.SeqNum == OwnSeqNum AND Target.HopCnt (the last know hop
+      count value) < Orig.HopCnt (the number of hops traversed by this
+      RREQ to reach the target).
+
+   First, the node adds the AddBlk.Target.Address to the RM.  The
+   Target.Address is copied from the incoming RREQ AddBlk.Orig.Address.
+
+   Next, the node adds the AddBlk.Orig.Address to the RM and the
+   AddTLV.Orig.SeqNum (OwnSeqNum) in an address block TLV.  The
+   Orig.Address is copied from the incoming RREQ AddBlk.Target.Address.
+
+   Other AddTLVs for the originator and target SHOULD be set to maximum
+   protocol efficiency, but they may be omitted to reduce message size.
+
+   The MsgHdr.HopCnt is set to zero (0).  The MsgHdr.HopLimit is set to
+   NET_DIAMETER.
+
+5.3.3.  RM Processing
+
+   When a RM is received the MsgHdr.HopLimit is decremented by one (1)
+   and MsgHdr.HopCnt is incremented by one (1).
+
+   For each address in the RM that includes AddTLV-HopCnt information
+   except the target and those addresses tagged with the AddTLV-Ignore,
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 16]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   the AddTLV-HopCnt information is incremented by one (1).
+
+   Next, this node checks whether its routing table has an entry to the
+   AddBlk.Orig.Address using longest-prefix matching [RFC1812].  If a
+   route does not exist, the new routing information is considered fresh
+   and a new route table entry is created and updated as described in
+   Section 5.2.2.  If a routing table entry exists, the new node's
+   information is compared with the route table entry following the
+   procedure described in Section 5.2.1.  If the new node's routing
+   information is considered fresh, the route table entry is updated as
+   described in Section 5.2.2.
+
+   If the routing information for the originator is not fresh then this
+   RM must be discarded and no further processing of this message is
+   performed.
+
+   If the originator's routing information was considered fresh, then
+   each address that is not the target and is not flagged with the
+   Ignore address-block-tlv SHOULD considered for creating and updating
+   routes.  If routing table space is limited, only the routing
+   information about the originator is required.  Creating and updating
+   routes for other locations can eliminate RREQ for those destination,
+   in the event that data needs to be forwarded to these destinations in
+   the near future.
+
+   For each of these addresses considered, if the routing table does not
+   have a matching route using longest-prefix matching, then a route is
+   created and updated as described in Section 5.2.2.  If a routing
+   table entry exists, the new node's information is compared with the
+   route table entry following the procedure described in Section 5.2.1.
+   If the new node's routing information is considered fresh, the route
+   table entry is updated as described in Section 5.2.2.
+
+   If the routing information for an Node.Address is not considered
+   fresh, then if MUST be removed from the RM.  Removing this
+   information ensures that non-fresh information is not propagated.
+
+   If this node is the target AND this RM is a RREQ, this node responds
+   with a RREP.  This node creates a new RREP as described in
+   Section 5.3.2.
+
+   After processing a RM or creating a new RM, a node MAY append
+   additional routing information to the RM, according to the process
+   described in Section 5.3.4.  The additional routing information will
+   help reduce route discoveries at the expense of increased message
+   size.
+
+   If this RM's MsgHdr.HopLimit is greater than one (1), this node is
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 17]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   not the target, AND this RM is a RREQ, then the current RM (altered
+   by the process defined above) SHOULD be sent to the
+   LL_ALL_MANET_ROUTERS IP.DestinationAddress.
+
+   If this RM's MsgHdr.HopLimit is greater than one (1), this node is
+   not the target, AND this RM is a RREP, then the new RM SHOULD be sent
+   to the Route.NextHopAddress for the RREP's Target.Address.
+
+   If this node is the target, the current RM's information is not
+   retransmitted.
+
+5.3.4.  Adding Additional Routing Information to a RM
+
+   Appending routing information will alleviate route discovery attempts
+   to the nodes whose information is included, if other nodes use this
+   information to update their routing tables.
+
+   Nodes MAY append routing information to a RM, if the node believe
+   that this additional routing information will alleviate future RREQ.
+   This option should be administratively controlled.
+
+   Prior to appending their own address to a RM, a node MUST increment
+   its OwnSeqNum as defined in Section 5.1.2.  Then the node appends its
+   IP address (AddBlk-Address) and OwnSeqNum (AddTLV-SeqNum).  It MAY
+   also append other information to its address, such as prefix and/or
+   that it is an Internet Gateway.  If included, the Node.HopCnt is set
+   to one (1).
+
+   Routing information about other nodes MAY also be added.  If this
+   information is included, it must be flagged with the
+   AddTLV.AdditionalNode.IsOffPath.
+
+   Note an address may appear only once in a message's address blocks.
+   Prior to adding any address, the message is searched for existing
+   entries.  If an existing entry exists, this entry will have the
+   information as this node's routing table information (created or
+   updated while processing the RM) and therefore no update is
+   necessary.
+
+   In the event a newly appended address already has an AddTLV-Ignore
+   flag set, it is removed.
+
+5.4.  Route Discovery
+
+   A node creates a RREQ (described in Section 5.3.1) to discover a
+   route to a particular destination (target).  The
+   IP.DestinationAddress for this RREQ is set to the
+   LL_ALL_MANET_ROUTERS.  Then the RM is transmitted.
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 18]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   After issuing a RREQ, the originating node waits for a route to be
+   created to the target.  If a route is not found within RREQ_WAIT_TIME
+   milliseconds, this node MAY again try to discover a route by issuing
+   another RREQ.
+
+   To reduce congestion in a network, repeated attempts at route
+   discovery for a particular target SHOULD utilize a binary exponential
+   backoff.  The first time a node issues a RREQ, it waits
+   RREQ_WAIT_TIME milliseconds for a route to the target.  If a route is
+   not found within that time, the node MAY send another RREQ.  If a
+   route is not found within two (2) times the current waiting time,
+   another RREQ may be sent, up to a total of RREQ_TRIES.  For each
+   additional attempt, the waiting time for the previous RREQ is
+   multiplied by two (2) so that the waiting time conforms to a binary
+   exponential backoff.
+
+   Data packets awaiting a route SHOULD be buffered.  This buffer SHOULD
+   have a fixed limited size and discard older data packets first.
+
+   If a route discovery has been attempted RREQ_TRIES times without
+   receiving a route to the target, all data packets destined for the
+   corresponding target are dropped from the buffer and a Destination
+   Unreachable ICMP message SHOULD be delivered to the application.
+
+5.5.  Route Maintenance
+
+   A RERR MUST be issued if a data packet is received and it cannot be
+   delivered to the next hop, RERR generation is described in
+   Section 5.5.3.  A RERR MAY be issued immediately after detecting a
+   broken link of an active route to quickly notify nodes that a link
+   break occurred and certain routes are no longer available.  If a
+   route has not been used, a RERR SHOULD NOT be generated unless
+   generation is expected to reduce future traffic.
+
+5.5.1.  Active Link Monitoring
+
+   Nodes MUST monitor links on active routes that are being used.  This
+   may be accomplished by one or several mechanisms.  Including:
+
+   o  Link layer feedback
+
+   o  Neighborhood discovery [I-D.ietf-manet-nhdp]
+
+   o  Route timeout
+
+   o  Other monitoring mechanisms or heuristics
+
+   Upon detecting a link break the detecting node MUST set the
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 19]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   Route.ValidTimeout to the current time for all active routes
+   utilizing the broken link.
+
+5.5.2.  Updating Route Lifetimes during Packet Forwarding
+
+   To avoid route timeouts for active routes, a node SHOULD update the
+   Route.ValidTimeout for the IP.SourceAddress to be the current time +
+   ROUTE_VALID_TIMEOUT upon receiving a data packet.  This route's
+   Route.Used bit is also set, if implemented.
+
+   To avoid route timeouts for active routes, a node SHOULD update the
+   Route.ValidTimeout for the IP.DestinationAddress to be the current
+   time + ROUTE_VALID_TIMEOUT upon successfully transmitting a packet to
+   the next hop.  This route's Route.Used bit is also set.
+
+5.5.3.  Route Error Generation
+
+   When a data packet is received for a destination without a valid
+   routing table entry, a RERR MUST be generated.  When a RREP is being
+   transmitted and no active route to the target exists, a RERR MUST be
+   generated.  A RERR informs the IP.SourceAddress that the route does
+   not exist, is no longer available, or is now invalid.
+
+   In a new RERR, the address of first unreachable node
+   (IP.DestinationAddress from the data packet) is inserted.  If a value
+   for the unreachable node's SeqNum (AddTLV-SeqNum) is known, it SHOULD
+   be placed in the RERR.  The MsgHdr.HopLimit is set to NET_DIAMETER.
+   The MsgHdr.HopCnt is set to one (1).
+
+   Additional unreachable nodes that required the same unavailable link
+   (routes with the same Route.NextHopAddress and
+   Route.NextHopInterface) MAY be added to the RERR.  The SeqNum if know
+   SHOULD also be included.  Appending unreachable node information
+   notifies each processing node of additional routes that are no longer
+   available.
+
+   If SeqNum information is not known or not included all nodes
+   processing the routing information will assume their routing
+   information associated with the unreachable node is no longer valid.
+
+   The RERR is sent to the IP.DestinationAddress LL_ALL_MANET_ROUTERS.
+   Sending the RERR to the LL_ALL_MANET_ROUTERS address notifies the
+   maximum number of nodes of the broken link.
+
+   The packet or message that forced generation of this RERR is
+   discarded.
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 20]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+5.5.4.  Route Error Processing
+
+   When a node processes a RERR, it processes each unreachable node
+   address.  It sets the Route.ValidTimeout to the current time for each
+   Address found using longest prefix matching that meet all of the
+   following conditions:
+
+   1.  The Route.NextHopAddress is the same as the RERR
+       IP.SourceAddress.
+
+   2.  The Route.NextHopInterface is the same as the interface on which
+       the RERR was received.
+
+   3.  The Route.SeqNum is zero (0), unknown, OR the Node.SeqNum is zero
+       (0), unknown, OR Node.SeqNum - Route.SeqNum <= 0 (using signed
+       16-bit arithmetic).
+
+   Each unreachable node that did not result in a change to
+   Route.ValidTimeout is removed from the RERR, since propagation of
+   this information will not result in any benefit.  Any information
+   associated with the removed addresses is also removed.
+
+   If no unreachable node addresses remain, no further processing is
+   performed.
+
+   If this RERR's MsgHdr.HopLimit is greater than one (1) and at least
+   one unreachable node address remains in the RERR, then the RERR is
+   sent to the IP.DestinationAddress LL_ALL_MANET_ROUTERS.
+
+   Addresses marked with AddTLV-Ignore should remain in the RERR.
+
+5.6.  General DYMO Packet and Message Processing
+
+5.6.1.  Receiving Packets
+
+   When a packet is received, its PktTLV are first examined.  Next each
+   message is examined and processed in order.
+
+   Each message's headers are first examined.  Next, the MsgTLV are
+   examined.  Finally, each message is processed according to its
+   MsgHdr.type.
+
+5.6.2.  Processing Unknown Message and TLV Types
+
+   To allow future extensions, DYMO uses bits from the semantics fields
+   of PktTLV, Message, MsgTLV, and AddTLV [I-D.ietf-manet-packetbb].
+   Note [I-D.ietf-manet-packetbb] does not currently support this
+   functionality.
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 21]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   The semantic bits have the following names and characteristics for
+   nodes that do not understand the type.
+
+   Remove
+      If the Semantics.Remove-bit is set, this information SHOULD be
+      removed from the message.
+
+   Discard
+      If the Semantics.Discard-bit is set, this message SHOULD not be
+      processed further and it should not be propagated.  In the case of
+      PktTLVs if the Semantics.Discard-bit is set, no messages from the
+      packet should be processed or propagated.
+
+5.7.  Network Addresses
+
+   Any node MAY advertise a network address by using a Prefix tlv
+   [I-D.ietf-manet-packetbb].  Any nodes (other than the advertising
+   node) within the advertised Prefix SHOULD NOT participate in the
+   MANET and these nodes MUST be reachable by forwarding packets to the
+   node advertising connectivity.  For example, A.B.C.1 with a prefix
+   length of 24 indicates all nodes with the matching A.B.C.X are
+   reachable through the node with address A.B.C.1.
+
+   The meaning of the Prefix field is altered for theroute to an
+   Internet gateway; Route.IsInternetGateway is one (1).  If the route
+   refers to an Internet gateway, its Prefix in association with the IP
+   address indicates that all nodes outside that subnet are reachable
+   via the Internet gateway node.  For example, a route to a Internet
+   gateway with IP address A.B.C.1 and a prefix of 24 indicates that all
+   nodes with an IP address NOT matching A.B.C.X are reachable via this
+   node.
+
+5.8.  Simple Internet Attachment and Gatewaying
+
+   Simple Internet attachment consists of a network of MANET nodes
+   connected to the Internet via a single Internet gateway node.  The
+   gateway is responsible for responding to RREQs for targets outside
+   its configured MANET subnet, as well as delivering packets to
+   destinations outside the MANET.
+
+
+
+
+
+
+
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 22]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+         /--------------------------\
+        /          Internet          \
+        \                            /
+         \------------+-------------/
+         MANET Subnet | A.B.C.X
+                +-----+-----+
+                |   MANET   |
+         /------|  Internet |------\
+        /       |  Gateway  |       \
+       /        |  A.B.C.1  |        \
+       |        +-----------+        |
+       |            MANET            |
+       |                             |
+       | +------------+              |
+       | | MANET Node |              |
+       | |  A.B.C.2   |              |
+       | +------------+              |
+       |              +------------+ |
+       |              | MANET Node | |
+       |              |   A.B.C.3  | |
+       \              +------------+ /
+        \                           /
+         \-------------------------/
+
+   Figure 3: Simple Internet Attachament Example
+
+   MANET nodes wishing to be reachable from nodes in the Internet MUST
+   have IP addresses within the gateway's configured and advertised
+   MANET subnet.  Given a node with a globally routeable address or
+   care-of address handled by the gateway, the gateway is responsible
+   for routing and forwarding packets received from the Internet
+   destined for nodes inside its MANET subnet.
+
+   Since many nodes may commonly wish to communicate with the gateway,
+   the gateway SHOULD indicate to nodes that it is a gateway by using
+   the gateway tlv in any RM transmitted.  The Internet Gateway tlv
+   indicates to nodes in the MANET that the Node.Address is attached to
+   the Internet and is capable of routing data packets to all nodes
+   outside of the configured MANET subnet, defined by the Node.Address
+   and Node.Prefix fields.
+
+5.9.  Multiple Interfaces
+
+   It is likely that DYMO will be used with multiple wireless
+   interfaces; therefore, the particular interface over which packets
+   arrive must be known whenever a packet is received.  Whenever a new
+   route is created, the interface through which the Route.Address can
+   be reached is also recorded in the route table entry.
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 23]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   When multiple interfaces are available, a node transmitting a packet
+   with IP.DestinationAddress set to LL_ALL_MANET_ROUTERS SHOULD send
+   the packet on all interfaces that have been configured for DYMO
+   operation.
+
+5.10.  Packet Generation Limits
+
+   To avoid congestion, a node SHOULD NOT transmit more than RATE_LIMIT
+   control messages per second.  RREQ packets SHOULD be discarded before
+   RREP or RERR packets.
+
+
+6.  Configuration Parameters
+
+                        Suggested Parameter Values
+
+           +------------------------+-------------------------+
+           |          Name          |          Value          |
+           +------------------------+-------------------------+
+           |      NET_DIAMETER      |            10           |
+           |       RATE_LIMIT       |            10           |
+           |   ROUTE_VALID_TIMEOUT  |    5000 milliseconds    |
+           |  ROUTE_DELETE_TIMEOUT  | 5 * ROUTE_VALID_TIMEOUT |
+           |   ROUTE_DELETE_PERIOD  | 6 * ROUTE_VALID_TIMEOUT |
+           |  ROUTE_RREQ_WAIT_TIME  |    1000 milliseconds    |
+           |       RREQ_TRIES       |            3            |
+           +------------------------+-------------------------+
+
+                                  Table 1
+
+   These suggested values work well for small and medium well connected
+   networks with infrequence topology changes.  For larger networks or
+   networks with frequent topology changes the default DYMO parameters
+   should be adjusted using either experimentally determined values or
+   dynamic adaptation.  For example, in networks with infrequent
+   topology changes ROUTE_VALID_TIMEOUT may be set to a much larger
+   value.
+
+   It is assumed that all nodes in the network share the same parameter
+   settings.  Different parameter values for ROUTE_VALID_TIMEOUT or
+   ROUTE_DELETE_TIMEOUT in addition to arbitrary packet delays may
+   result in frequent route breaks or in extreme cases routing loops.
+
+
+7.  IANA Considerations
+
+   DYMO requires a UDP port number to carry protocol packets - TBD.
+   DYMO also requires the link-local multicast address
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 24]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   LL_ALL_MANET_ROUTERS; IPv4 TBD, IPv6 TBD.
+
+   This section also specifies several messages types, message tlv-
+   types, and address tlv-types.
+
+   Future types will be allocated using standard actions as described in
+   [RFC2434].
+
+7.1.  DYMO Message Type Specification
+
+   The following address block TLV.
+
+                            DYMO Message Types
+
+                   +------------------------+----------+
+                   |          Name          |   Type   |
+                   +------------------------+----------+
+                   |  Route Request (RREQ)  | 10 - TBD |
+                   |   Route Reply (RREP)   | 11 - TBD |
+                   |   Route Error (RERR)   | 12 - TBD |
+                   +------------------------+----------+
+
+                                  Table 2
+
+7.2.  Packet TLV Type Specification
+
+                             Packet TLV Types
+
+   +-------------------+------+--------+-------------------------------+
+   |        Name       | Type | Length | Value                         |
+   +-------------------+------+--------+-------------------------------+
+   |  Unicast Response |  TBD |  10 -  | Indicates to the processing   |
+   |      Request      |      |   TBD  | node that the previous hop    |
+   |                   |      |        | (IP.SourceAddress) expects a  |
+   |                   |      |        | unicast message within        |
+   |                   |      |        | UNICAST_MESSAGE_SENT_TIMEOUT. |
+   |                   |      |        | Any unicast packet will serve |
+   |                   |      |        | this purpose, and it MAY be   |
+   |                   |      |        | an ICMP REPLY message.  If a  |
+   |                   |      |        | message is not sent, then the |
+   |                   |      |        | previous hop may assume that  |
+   |                   |      |        | the link is unidirectional    |
+   |                   |      |        | and may blacklist this node.  |
+   +-------------------+------+--------+-------------------------------+
+
+                                  Table 3
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 25]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+7.3.  Address Block TLV Specification
+
+                 Address Block TLV Specification Overview
+
+   +----------------------+------+--------+----------------------------+
+   |         Name         | Type | Length | Value                      |
+   +----------------------+------+--------+----------------------------+
+   |      DYMOSeqNum      | 10 - |   16   | The DYMO sequence num      |
+   |                      |  TBD |  bits  | associated with this       |
+   |                      |      |        | address.  The sequence     |
+   |                      |      |        | number may be the last     |
+   |                      |      |        | known sequence number.     |
+   |       HopCount       | 11 - | 8 bits | The number of hops         |
+   |                      |  TBD |        | traversed by the           |
+   |                      |      |        | information associated     |
+   |                      |      |        | with this address.         |
+   |   IsInternetGateway  | 12 - | 0 bits | Usde to indicate that this |
+   |                      |  TBD |        | node is an Internet        |
+   |                      |      |        | Gateway                    |
+   |     IsOriginator     | 13 - | 0 bits | Used to indicate that this |
+   |                      |  TBD |        | node is the Originator of  |
+   |                      |      |        | the RM.                    |
+   |       IsTarget       | 14 - | 0 bits | Used to indicate this node |
+   |                      |  TBD |        | is the target of the DYMO  |
+   |                      |      |        | message                    |
+   |        Ignore        | 15 - |    0   | Used to indicate that this |
+   |                      |  TBD |        | addresses should not be    |
+   |                      |      |        | processed normally;        |
+   |                      |      |        | instead it should be       |
+   |                      |      |        | ignored.                   |
+   +----------------------+------+--------+----------------------------+
+
+                                  Table 4
+
+
+8.  Security Considerations
+
+   Currently, DYMO does not specify any special security measures.
+   Routing protocols, however, are prime targets for impersonation
+   attacks.  In networks where the node membership is not known, it is
+   difficult to determine the occurrence of impersonation attacks, and
+   security prevention techniques are difficult at best.  However, when
+   the network membership is known and there is a danger of such
+   attacks, DYMO messages must be protected by the use of authentication
+   techniques, such as those involving generation of unforgeable and
+   cryptographically strong message digests or digital signatures.
+   While DYMO does not place restrictions on the authentication
+   mechanism used for this purpose, IPsec Authentication Message (AH) is
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 26]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   an appropriate choice for cases where the nodes share an appropriate
+   security association that enables the use of AH.
+
+   In particular, RM messages SHOULD be authenticated to avoid creation
+   of spurious routes to a destination.  Otherwise, an attacker could
+   masquerade as that destination and maliciously deny service to the
+   destination and/or maliciously inspect and consume traffic intended
+   for delivery to the destination.  RERR messages, while slightly less
+   dangerous, SHOULD be authenticated in order to prevent malicious
+   nodes from disrupting active routes between communicating nodes.
+
+   If the mobile nodes in the ad hoc network have pre-established
+   security associations, the purposes for which the security
+   associations are created should include that of authorizing the
+   processing of DYMO control packets.  Given this understanding, the
+   mobile nodes should be able to use the same authentication mechanisms
+   based on their IP addresses as they would have used otherwise.
+
+
+9.  Acknowledgments
+
+   DYMO is a descendant of the design of previous MANET reactive
+   protocols, especially AODV [RFC3561] and DSR [Johnson96].  Changes to
+   previous MANET reactive protocols stem from research and
+   implementation experiences.  Thanks to Elizabeth Belding-Royer for
+   her long time authorship of DYMO.  Additional thanks to Luke Klein-
+   Berndt, Pedro Ruiz, Fransisco Ros, Koojana Kuladinithi, Ramon
+   Caceres, and Thomas Clausen for reviewing of DYMO, as well as several
+   specification suggestions.
+
+
+10.  References
+
+10.1.  Normative References
+
+   [RFC1812]  Baker, F., "Requirements for IP Version 4 Routers",
+              RFC 1812, June 1995.
+
+   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2434]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
+              IANA Considerations Section in RFCs", BCP 26, RFC 2434,
+              October 1998.
+
+   [RFC3513]  Hinden, R. and S. Deering, "Internet Protocol Version 6
+              (IPv6) Addressing Architecture", RFC 3513, April 2003.
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 27]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+   [RFC3561]  Perkins, C., Belding-Royer, E., and S. Das, "Ad hoc On-
+              Demand Distance Vector (AODV) Routing", RFC 3561,
+              July 2003.
+
+10.2.  Informative References
+
+   [I-D.ietf-manet-nhdp]
+              Clausen, T., Dearlove, C., and J. Dean, "MANET
+              Neighborhood Discovery Protocol", draft-ietf-manet-nhdp-00
+              (work in progress), June 2006.
+
+   [I-D.ietf-manet-packetbb]
+              Clausen, T., Dearlove, C., Dean, J., and C. Adjih,
+              "Generalized MANET Packet/Message Format",
+              draft-ietf-manet-packetbb-01 (work in progress),
+              June 2006.
+
+   [Johnson96]
+              Johnson, D. and D. Maltz, "Dynamic Source Routing (DSR) in
+              Ad hoc Networks", In Mobile Computing, Chapter 5, pp. 153-
+              181, 1996.
+
+   [Perkins99]
+              Perkins, C. and E. Belding-Royer, "Ad hoc On-Demand
+              Distance Vector (AODV) Routing", Proceedings of the 2nd
+              IEEE Workshop on Mobile            Computing Systems and
+              Applications, New Orleans, LA,            pp. 90-100,
+              February 1999.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 28]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+Authors' Addresses
+
+   Ian Chakeres
+   Boeing Phantom Works
+   The Boeing Company
+   P.O. Box 3707 Mailcode 7L-49
+   Seattle, WA  98124-2207
+   USA
+
+   Email: ian.chakeres@gmail.com
+
+
+   Charlie Perkins
+   Nokia Research Center
+   313 Fairchild Drive
+   Mountain View, CA  94043
+   USA
+
+   Phone: +1-650-625-2986
+   Fax:   +1-650-625-2502
+   Email: charlie.perkins@nokia.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 29]
+
+Internet-Draft                    DYMO                         June 2006
+
+
+Intellectual Property Statement
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+Disclaimer of Validity
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+
+Copyright Statement
+
+   Copyright (C) The Internet Society (2006).  This document is subject
+   to the rights, licenses and restrictions contained in BCP 78, and
+   except as set forth therein, the authors retain all their rights.
+
+
+Acknowledgment
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+Chakeres & Perkins      Expires December 22, 2006              [Page 30]
+
diff -Naur ns-2.35-orig/dymoum/dymo_generic.c ns-2.35/dymoum/dymo_generic.c
--- ns-2.35-orig/dymoum/dymo_generic.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_generic.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,122 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "dymo_generic.h"
+#include "dymo_re.h"
+#include "dymo_uerr.h"
+#include "dymo_rerr.h"
+#include "dymo_hello.h"
+#include "defs.h"
+#include "debug.h"
+
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#endif	/* NS_PORT */
+
+void NS_CLASS generic_process_message(DYMO_element *e, struct in_addr src, u_int32_t ifindex)
+{
+	// Generic preprocessing
+	generic_preprocess(e);
+	
+	switch (e->type)
+	{		
+		case DYMO_RE_TYPE:
+			if (((RE *) e)->a)
+				dlog(LOG_DEBUG, 0, __FUNCTION__,
+					"RREQ received in %s from %s",
+					DEV_IFINDEX(ifindex).ifname,
+					ip2str(src.s_addr));
+			else
+				dlog(LOG_DEBUG, 0, __FUNCTION__,
+					"RREP received in %s from %s",
+					DEV_IFINDEX(ifindex).ifname,
+					ip2str(src.s_addr));
+			re_process((RE *) e, src, ifindex);
+			break;
+		
+		case DYMO_RERR_TYPE:
+			dlog(LOG_DEBUG, 0, __FUNCTION__,
+				"RERR received in %s from %s",
+				DEV_IFINDEX(ifindex).ifname,
+				ip2str(src.s_addr));
+			rerr_process((RERR *) e, src, ifindex);
+			break;
+		
+		case DYMO_UERR_TYPE:
+			dlog(LOG_DEBUG, 0, __FUNCTION__,
+				"UERR received in %s from %s",
+				DEV_IFINDEX(ifindex).ifname,
+				ip2str(src.s_addr));
+			uerr_process((UERR *) e, src, ifindex);
+			break;
+		
+		case DYMO_HELLO_TYPE:
+			dlog(LOG_DEBUG, 0, __FUNCTION__,
+				"HELLO received in %s from %s",
+				DEV_IFINDEX(ifindex).ifname,
+				ip2str(src.s_addr));
+			hello_process((HELLO *) e, src, ifindex);
+			break;
+#ifdef NS_PORT
+		case DYMO_ECHOREPLY_TYPE:
+			dlog(LOG_DEBUG, 0, __FUNCTION__,
+				"ICMP ECHOREPLY received in %s from %s",
+				DEV_IFINDEX(ifindex).ifname,
+				ip2str(src.s_addr));
+			icmp_process(src);
+			break;
+#endif	/* NS_PORT */
+		
+		default:
+			dlog(LOG_DEBUG, 0, __FUNCTION__,
+			"unknown msg type %u received in %s from %s",
+			e->type,
+			DEV_IFINDEX(ifindex).ifname,
+			ip2str(src.s_addr));
+			
+			if (e->m)
+				uerr_send(e, ifindex);
+			switch (e->h)
+			{
+				case 0: // H = 00
+				// TODO: we should skip this element from the
+				// packet and continue the packet processing,
+				// but we are only dealing with 1-element
+				// packets. Thus the packet is dropped
+				break;
+				
+				case 1: // H = 01
+				// TODO: we should remove this element from the
+				// packet and continue the processing
+				break;
+				
+				case 2: // H = 10: set I bit
+				e->i = 1;
+				// TODO: continue processing
+				break;
+				
+				case 3: // H = 11: drop the packet
+				break;
+			}
+	}
+}
diff -Naur ns-2.35-orig/dymoum/dymo_generic.h ns-2.35/dymoum/dymo_generic.h
--- ns-2.35-orig/dymoum/dymo_generic.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_generic.h	2006-08-30 18:24:03.000000000 +0200
@@ -0,0 +1,113 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_GENERIC_H__
+#define __DYMO_GENERIC_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include "defs.h"
+
+#include <sys/types.h>
+#include <netinet/in.h>
+
+/* Broadcast address (255.255.255.255) */
+#define DYMO_BROADCAST ((in_addr_t) 0xFFFFFFFF)
+
+/* DYMO port is not determined yet, so I am using AODV_PORT - 1 */
+#define DYMO_PORT	653
+
+/* TTL field in IP header for every DYMO packet */
+#define DYMO_IPTTL	1
+
+/* Maximum number of DYMO messages per second which can be generated
+   by a node */
+#define DYMO_RATELIMIT	10
+
+/* Macro for incrementing a sequence number */
+#define INC_SEQNUM(s) (s == 65535 ? s = 256 : s++)
+
+
+/* DYMO message types */
+#define DYMO_RE_TYPE	1
+#define DYMO_RERR_TYPE	2
+#define DYMO_UERR_TYPE	3
+#define DYMO_HELLO_TYPE	4
+#ifdef NS_PORT
+#define DYMO_ECHOREPLY_TYPE	5
+#endif	/* NS_PORT */
+
+/* Network diameter (in number of hops) */
+#define NET_DIAMETER	10
+
+
+/* Generic DYMO element fixed struct */
+#ifdef NS_PORT
+struct DYMO_element {	// FIXME: adjust byte ordering
+#else
+typedef struct {
+#endif	/* NS_PORT */
+	u_int32_t	m : 1;
+	u_int32_t	h : 2;
+	u_int32_t	type : 5;
+	u_int32_t	len : 12;
+	u_int32_t	ttl : 6;
+	u_int32_t	i : 1;
+	u_int32_t	res : 5;
+
+	u_int32_t	notify_addr; // if M bit set
+	u_int32_t	target_addr; // if not a DYMOcast addr in IP dest addr
+	
+#ifdef NS_PORT
+	static int offset_;
+	inline static int& offset() { return offset_; }
+	inline static DYMO_element *access(const Packet *p) {
+		return (DYMO_element *) p->access(offset_);
+	}
+};
+
+typedef DYMO_element hdr_dymoum;
+#define HDR_DYMOUM(p) ((hdr_dymoum *) hdr_dymoum::access(p))
+#else
+} DYMO_element;
+#endif	/* NS_PORT */
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Decrements TTL */
+NS_STATIC NS_INLINE void generic_preprocess(DYMO_element *e) {
+	e->ttl--;
+}
+
+/* Returns true if TTL is greater than 0 */
+// TODO: this must be changed according to the specification when support for
+// multiple elements be added.
+NS_STATIC NS_INLINE int generic_postprocess(DYMO_element *e) {
+	return (e->ttl > 0);
+}
+
+/* Processes a DYMO message */
+void generic_process_message(DYMO_element *e, struct in_addr src, u_int32_t ifindex);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __DYMO_GENERIC_H__ */
diff -Naur ns-2.35-orig/dymoum/dymo_hello.c ns-2.35/dymoum/dymo_hello.c
--- ns-2.35-orig/dymoum/dymo_hello.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_hello.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,115 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "defs.h"
+#include "dymo_hello.h"
+#include "timer_queue.h"
+#include "dymo_socket.h"
+#include "dymo_nb.h"
+#include <sys/time.h>
+#include <stdlib.h>
+
+static struct timer hello_timer;
+extern int hello_ival;
+#endif	/* NS_PORT */
+
+void NS_CLASS hello_init(void)
+{
+	if (hello_timer.used || hello_ival <= 0)
+		return;
+	
+	timer_init(&hello_timer, &NS_CLASS hello_send, NULL);
+	hello_send(NULL);
+}
+
+void NS_CLASS hello_fini(void)
+{
+	timer_remove(&hello_timer);
+}
+
+HELLO *NS_CLASS hello_create(void)
+{
+	HELLO *hello;
+	
+	hello		= (HELLO *) dymo_socket_new_element();
+	hello->m	= 0;
+	hello->h	= 0;
+	hello->type	= DYMO_HELLO_TYPE;
+	hello->len	= HELLO_BASIC_SIZE;
+	hello->ttl	= 1;
+	hello->i	= 0;
+	hello->res	= 0;
+	
+	return hello;
+}
+
+void NS_CLASS hello_send(void *arg)
+{
+	int i;
+	struct in_addr dest_addr;
+	
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "sending HELLO");
+	
+	HELLO *hello = hello_create();
+	dest_addr.s_addr = DYMO_BROADCAST;
+	
+	// Queue the new HELLO
+	hello = (HELLO *) dymo_socket_queue((DYMO_element *) hello);
+	
+	// Send HELLO over all enabled interfaces
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+		if (DEV_NR(i).enabled)
+			dymo_socket_send(dest_addr, &DEV_NR(i));
+	
+	// Schedule next HELLO
+	timer_set_timeout(&hello_timer, (hello_ival*1000) + hello_jitter());
+	timer_add(&hello_timer);
+}
+
+void NS_CLASS hello_process(HELLO *hello, struct in_addr ip_src, u_int32_t ifindex)
+{
+	nb_t *nb;
+	
+	// Insert or update a neighbor entry
+	nb = nb_find(ip_src, ifindex);
+	if (!nb)
+		nb_insert(ip_src, ifindex);
+	else
+		nb_update(nb);
+}
+
+long NS_CLASS hello_jitter(void)
+{
+	long jitter;
+#ifdef NS_PORT
+	jitter = (long) (Random::uniform() * 0.1 * hello_ival * 1000);
+	if (Random::uniform() > 0.5)
+		return jitter;
+	return -jitter;
+#else
+	jitter = (long) (((float) random() / (float) RAND_MAX) * 0.1 * hello_ival * 1000);
+	if ((float) random() / (float) RAND_MAX > 0.5)
+		return jitter;
+	return -jitter;
+#endif
+}
diff -Naur ns-2.35-orig/dymoum/dymo_hello.h ns-2.35/dymoum/dymo_hello.h
--- ns-2.35-orig/dymoum/dymo_hello.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_hello.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,67 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_HELLO_H__
+#define __DYMO_HELLO_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include <sys/types.h>
+#include <netinet/in.h>
+
+/* HELLO message */
+typedef struct {	// FIXME: adjust byte ordering
+	u_int32_t	m : 1;
+	u_int32_t	h : 2;
+	u_int32_t	type : 5;
+	u_int32_t	len : 12;
+	u_int32_t	ttl : 6;
+	u_int32_t	i : 1;
+	u_int32_t	res : 5;
+} HELLO;
+
+#define HELLO_BASIC_SIZE	sizeof(HELLO)
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Start sending of HELLO messages */
+void hello_init(void);
+
+/* Finish sending of HELLO messages */
+void hello_fini(void);
+
+/* Return a HELLO message */
+HELLO *hello_create(void);
+
+/* Send a HELLO message and schedule the next. Use hello_init() and
+   hello_fini() instead.*/
+void hello_send(void *arg);
+
+/* Process a HELLO message */
+void hello_process(HELLO *hello, struct in_addr ip_src, u_int32_t ifindex);
+
+/* Return a random jitter */
+long hello_jitter(void);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __DYMO_HELLO_H__ */
diff -Naur ns-2.35-orig/dymoum/dymo_nb.c ns-2.35/dymoum/dymo_nb.c
--- ns-2.35-orig/dymoum/dymo_nb.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_nb.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,88 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#include <errno.h>
+#else
+#include "dymo_nb.h"
+#include "debug.h"
+#include "dymo_timeout.h"
+#include <stdlib.h>
+#include <errno.h>
+
+static DLIST_HEAD(NBLIST);
+extern int hello_ival;
+#endif	/* NS_PORT */
+
+nb_t *NS_CLASS nb_insert(struct in_addr nb_addr, u_int32_t ifindex)
+{
+	nb_t *nb;
+	
+	if ((nb = (nb_t *) malloc(sizeof(nb_t))) == NULL)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "failed malloc()");
+		exit(EXIT_FAILURE);
+	}
+	
+	nb->nb_addr.s_addr	= nb_addr.s_addr;
+	nb->ifindex		= ifindex;
+	timer_init(&nb->timer, &NS_CLASS nb_timeout, nb);
+	nb_update(nb);
+	dlist_add(&nb->list_head, &NBLIST);
+	
+	return nb;
+}
+
+void NS_CLASS nb_update(nb_t *nb)
+{
+	timer_set_timeout(&nb->timer, NB_TIMEOUT);
+	timer_add(&nb->timer);
+}
+
+int NS_CLASS nb_remove(nb_t *nb)
+{
+	if (!nb)
+		return 0;
+	
+	dlist_del(&nb->list_head);
+	timer_remove(&nb->timer);
+	
+	free(nb);
+	
+	return 1;
+}
+
+nb_t *NS_CLASS nb_find(struct in_addr nb_addr, u_int32_t ifindex)
+{
+	dlist_head_t *pos;
+	
+	dlist_for_each(pos, &NBLIST)
+	{
+		nb_t *nb = (nb_t *) pos;
+		if (nb->nb_addr.s_addr == nb_addr.s_addr &&
+			nb->ifindex == ifindex)
+		{
+			return nb;
+		}
+	}
+	
+	return NULL;
+}
diff -Naur ns-2.35-orig/dymoum/dymo_nb.h ns-2.35/dymoum/dymo_nb.h
--- ns-2.35-orig/dymoum/dymo_nb.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_nb.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,60 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_NB_H__
+#define __DYMO_NB_H__
+
+#ifndef NS_NO_GLOBALS
+#include "dlist.h"
+#include "timer_queue.h"
+#include <sys/types.h>
+
+/* Manage neighborhood connectivity. This information is acquired via HELLO
+   messages. */
+
+#define NB_TIMEOUT	2*1000*hello_ival
+
+typedef struct nb
+{
+	dlist_head_t	list_head;
+	struct in_addr	nb_addr;
+	u_int32_t	ifindex;
+	struct timer	timer;
+} nb_t;
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Add a new entry to the list */
+nb_t *nb_insert(struct in_addr nb_addr, u_int32_t ifindex);
+
+/* Update an existing nb_t entry */
+void nb_update(nb_t *nb);
+
+/* Remove an entry from the list */
+int nb_remove(nb_t *nb);
+
+/* Find an entry in the list with the given address and ifindex */
+nb_t *nb_find(struct in_addr nb_addr, u_int32_t ifindex);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __DYMO_NB_H__ */
diff -Naur ns-2.35-orig/dymoum/dymo_netlink.c ns-2.35/dymoum/dymo_netlink.c
--- ns-2.35-orig/dymoum/dymo_netlink.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_netlink.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,185 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <linux/netlink.h>
+
+#include "dymo_netlink.h"
+#include "dymo_generic.h"
+#include "dymo_re.h"
+#include "dymo_rerr.h"
+#include "rtable.h"
+#include "timer_queue.h"
+#include "defs.h"
+#include "debug.h"
+#include "lnx/kdymo_netlink.h"
+
+#define BUFLEN	256
+
+static int nlfd;
+static struct sockaddr_nl local;
+static struct sockaddr_nl peer;
+
+static void netlink_callback(int fd);
+static int netlink_send_msg(int type, struct in_addr addr);
+
+void netlink_init(void)
+{
+	if ((nlfd = socket(PF_NETLINK, SOCK_RAW, NETLINK_DYMO)) < 0)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "socket() failed");
+		exit(EXIT_FAILURE);
+	}
+	
+	memset(&local, 0, sizeof(struct sockaddr_nl));
+	local.nl_family	= AF_NETLINK;
+	local.nl_pid	= getpid();
+	local.nl_groups	= DYMOGRP_NOTIFY;
+	
+	memset(&peer, 0, sizeof(struct sockaddr_nl));
+	peer.nl_family	= AF_NETLINK;
+	peer.nl_pid	= 0;
+	peer.nl_groups	= 0;
+	
+	if (bind(nlfd, (struct sockaddr *) &local, sizeof(local)) < 0)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "bind() failed");
+		exit(EXIT_FAILURE);
+	}
+	
+	if (attach_callback_func(nlfd, netlink_callback) < 0)
+	{
+		dlog(LOG_ERR, 0, __FUNCTION__, "Could not attach netlink"
+			" callback");
+		exit(EXIT_FAILURE);
+	}
+}
+
+void netlink_fini(void)
+{
+	close(nlfd);
+}
+
+inline void netlink_add_route(struct in_addr addr)
+{
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "added route to %s",
+		ip2str(addr.s_addr));
+	netlink_send_msg(KDYMO_ADDROUTE, addr);
+}
+
+inline void netlink_del_route(struct in_addr addr)
+{
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "deleted route to %s",
+		ip2str(addr.s_addr));
+	netlink_send_msg(KDYMO_DELROUTE, addr);
+}
+
+inline void netlink_no_route_found(struct in_addr addr)
+{
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "no route found to %s",
+		ip2str(addr.s_addr));
+	netlink_send_msg(KDYMO_NOROUTE_FOUND, addr);
+}
+
+static int netlink_send_msg(int type, struct in_addr addr)
+{
+	struct
+	{
+		struct nlmsghdr nlh;
+		struct kdymo_rtmsg rtm;
+	} req;
+	
+	memset(&req, 0, sizeof(req));
+	
+	req.nlh.nlmsg_len	= NLMSG_LENGTH(sizeof(req));
+	req.nlh.nlmsg_flags	= NLM_F_REQUEST;
+	req.nlh.nlmsg_type	= type;
+	req.nlh.nlmsg_pid	= local.nl_pid;
+	
+	req.rtm.addr	= addr.s_addr;
+	req.rtm.ifindex	= 0;
+	
+	return sendto(nlfd, &req, req.nlh.nlmsg_len, 0,
+		(struct sockaddr *) &peer, sizeof(peer));
+}
+
+/* This function processes those messages which are sent from kernel space */
+static void netlink_callback(int fd)
+{
+	socklen_t addrlen;
+	char buf[BUFLEN];
+	
+	addrlen = sizeof(peer);
+	if (recvfrom(nlfd, buf, BUFLEN, 0, (struct sockaddr *) &peer,
+		&addrlen) > 0)
+	{
+		int type;
+		struct kdymo_rtmsg *msg;
+		rtable_entry_t *entry;
+		struct in_addr addr;
+		
+		type = ((struct nlmsghdr *) buf)->nlmsg_type;
+		
+		switch (type)
+		{
+		case KDYMO_NOROUTE:
+			msg = NLMSG_DATA((struct nlmsghdr *) buf);
+			
+			addr.s_addr = msg->addr;
+			route_discovery(addr);
+			break;
+			
+		case KDYMO_ROUTE_UPDATE:
+			msg = NLMSG_DATA((struct nlmsghdr *) buf);
+			
+			addr.s_addr = msg->addr;
+			if (addr.s_addr == DYMO_BROADCAST || addr.s_addr ==
+				DEV_IFINDEX(msg->ifindex).bcast.s_addr)
+				return;
+			
+			entry = rtable_find(addr);
+			if (entry)
+				rtable_update_timeout(entry);
+			break;
+		
+		case KDYMO_SEND_RERR:
+			msg = NLMSG_DATA((struct nlmsghdr *) buf);
+			
+			addr.s_addr = msg->addr;
+			if (addr.s_addr == DYMO_BROADCAST || addr.s_addr ==
+				DEV_IFINDEX(msg->ifindex).bcast.s_addr)
+				return;
+			
+			entry = rtable_find(addr);
+			rerr_send(addr, NET_DIAMETER, entry);
+			break;
+		
+		default:
+			dlog(LOG_DEBUG, 0, __FUNCTION__,
+				"Got an unknown netlink message: %d\n",
+				type);
+		}
+	}
+}
diff -Naur ns-2.35-orig/dymoum/dymo_netlink.h ns-2.35/dymoum/dymo_netlink.h
--- ns-2.35-orig/dymoum/dymo_netlink.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_netlink.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,46 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_NETLINK_H__
+#define __DYMO_NETLINK_H__
+
+#include <netinet/in.h>
+
+/* Here we implement communications from user space to kernel space via
+   netlink sockets */
+
+/* Set up netlink socket */
+void netlink_init(void);
+
+/* Close netlink socket */
+void netlink_fini(void);
+
+/* Send a message to kernel space to inform that a new routing entry must be
+   added */
+void netlink_add_route(struct in_addr addr);
+
+/* Send a message to kernel space to inform that a routing entry must be
+   deleted */
+void netlink_del_route(struct in_addr addr);
+
+/* Send a message to kernel space to inform that a route discovery failed */
+void netlink_no_route_found(struct in_addr addr);
+
+#endif	/* __DYMO_NETLINK_H__ */
diff -Naur ns-2.35-orig/dymoum/dymo_re.c ns-2.35/dymoum/dymo_re.c
--- ns-2.35-orig/dymoum/dymo_re.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_re.c	2006-08-30 19:36:04.000000000 +0200
@@ -0,0 +1,449 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include <string.h>
+
+#include "dymo_re.h"
+#include "dymo_generic.h"
+#include "dymo_socket.h"
+#include "icmp_socket.h"
+#include "dymo_timeout.h"
+#include "rtable.h"
+#include "pending_rreq.h"
+#include "blacklist.h"
+
+extern int no_path_acc, s_bit;
+#endif	/* NS_PORT */
+
+RE *NS_CLASS re_create_rreq(struct in_addr target_addr,
+		u_int32_t target_seqnum,
+		struct in_addr re_node_addr,
+		u_int32_t re_node_seqnum,
+		u_int8_t prefix, u_int8_t g,
+		u_int8_t ttl, u_int8_t thopcnt)
+{
+	RE *re;
+	
+	re		= (RE *) dymo_socket_new_element();
+	re->m		= 0;
+	re->h		= 0;
+	re->type	= DYMO_RE_TYPE;
+	re->a		= 1;
+	re->s		= 0;
+	re->i		= 0;
+	re->res1	= 0;
+	re->res2	= 0;
+	re->ttl		= ttl;
+	re->len		= RE_BASIC_SIZE + RE_BLOCK_SIZE;
+	re->thopcnt	= thopcnt;
+	re->target_addr		= (u_int32_t) target_addr.s_addr;
+	re->target_seqnum	= htonl(target_seqnum);
+	
+	re->re_blocks[0].g		= g;
+	re->re_blocks[0].prefix		= prefix;
+	re->re_blocks[0].res		= 0;
+	re->re_blocks[0].re_hopcnt	= 0;
+	re->re_blocks[0].re_node_addr	= (u_int32_t) re_node_addr.s_addr;
+	re->re_blocks[0].re_node_seqnum	= htonl(re_node_seqnum);
+	
+	return re;
+}
+
+RE *NS_CLASS re_create_rrep(struct in_addr target_addr,
+		u_int32_t target_seqnum,
+		struct in_addr re_node_addr,
+		u_int32_t re_node_seqnum,
+		u_int8_t prefix, u_int8_t g,
+		u_int8_t ttl, u_int8_t thopcnt)
+{
+	RE *re;
+	
+	re		= (RE *) dymo_socket_new_element();
+	re->m		= 0;
+	re->h		= 0;
+	re->type	= DYMO_RE_TYPE;
+	re->a		= 0;
+	re->s		= s_bit;
+	re->i		= 0;
+	re->res1	= 0;
+	re->res2	= 0;
+	re->ttl		= ttl;
+	re->len		= RE_BASIC_SIZE + RE_BLOCK_SIZE;
+	re->thopcnt	= thopcnt;
+	re->target_addr		= (u_int32_t) target_addr.s_addr;
+	re->target_seqnum	= htonl(target_seqnum);
+	
+	re->re_blocks[0].g		= g;
+	re->re_blocks[0].prefix		= prefix;
+	re->re_blocks[0].res		= 0;
+	re->re_blocks[0].re_hopcnt	= 0;
+	re->re_blocks[0].re_node_addr	= (u_int32_t) re_node_addr.s_addr;
+	re->re_blocks[0].re_node_seqnum	= htonl(re_node_seqnum);
+	
+	return re;
+}
+
+void NS_CLASS re_process(RE *re, struct in_addr ip_src, u_int32_t ifindex)
+{
+	struct in_addr node_addr;
+	rtable_entry_t *entry;
+	int i;
+	
+	// Assure that there is a block at least
+	if (re_numblocks(re) <= 0)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__, "malformed RE received");
+		return;
+	}
+	
+	// Check if the message is a RREQ and the previous hop is blacklisted
+	if (re->a && blacklist_find(ip_src))
+	{
+		dlog(LOG_DEBUG, 0, __FUNCTION__, "ignoring RREQ because "
+			"previous hop (%s) is blacklisted", ip2str(ip_src.s_addr));
+		return;
+	}
+	
+	/*
+	 * Add route to neighbor
+	 *
+	 * NOTE: this isn't in the spec. Motivation: suppose that path
+	 * accumulation is disabled and the S-bit is active. Then, after
+	 * receiving a RREP the node sends an ICMP ECHOREPLY message to
+	 * the neighbor. If we don't create this route, it'd be needed
+	 * a new route discovery. There are other (finer grain) possible
+	 * solutions but this seems to be ok.
+	 *
+	 */
+	entry = rtable_find(ip_src);
+	if (re->s)
+	{
+		if (!entry)
+			rtable_insert(
+				ip_src,		// dest
+				ip_src,		// nxt hop
+				ifindex,	// iface
+				0,		// seqnum
+				0,		// prefix
+				1,		// hop count
+				0);		// is gw
+		icmp_reply_send(ip_src, &DEV_IFINDEX(ifindex));
+	}
+	
+	// Process blocks
+	for (i = 0; i < re_numblocks(re); i++)
+	{
+		node_addr.s_addr	= re->re_blocks[i].re_node_addr;
+		entry			= rtable_find(node_addr);
+		if (re_process_block(&re->re_blocks[i], re->a, entry, ip_src, ifindex))
+		{
+			// stale information: drop packet if first block,
+			// drop block otherwise
+			if (i == 0)
+				return;
+			else {
+				int n = re_numblocks(re) - i - 1;
+				
+				memmove(&re->re_blocks[i], &re->re_blocks[i+1],
+					n * sizeof(struct re_block));
+				memset(&re->re_blocks[i + n], 0,
+					sizeof(struct re_block));
+				
+				re->len -= RE_BLOCK_SIZE;
+				i--;
+			}
+		}
+	}
+	
+	// If this node is the target, the RE must not be retransmitted
+	if (re->target_addr == (u_int32_t) DEV_IFINDEX(ifindex).ipaddr.s_addr)
+	{
+		// If A-bit is set, a RE is sent back
+		if (re->a)
+		{
+			struct in_addr target_addr;
+			u_int32_t target_seqnum;
+			
+			node_addr.s_addr	= re->re_blocks[0].re_node_addr;
+			target_addr.s_addr	= re->target_addr;
+			target_seqnum		= ntohl(re->target_seqnum);
+			
+			if (!target_seqnum ||
+				((int32_t) target_seqnum) - ((int32_t) this_host.seqnum) > 0 ||
+				(target_seqnum == this_host.seqnum && re->thopcnt < re->re_blocks[0].re_hopcnt))
+				INC_SEQNUM(this_host.seqnum);
+			
+			RE *rrep = re_create_rrep(
+				node_addr,
+				ntohl(re->re_blocks[0].re_node_seqnum),
+				target_addr,
+				this_host.seqnum,
+				this_host.prefix,
+				this_host.is_gw,
+				NET_DIAMETER,
+				re->re_blocks[0].re_hopcnt);
+			
+			re_send_rrep(rrep);
+		}
+	}
+	// Otherwise the RE is considered to be forwarded
+	else if (generic_postprocess((DYMO_element *) re))
+	{
+		if (!no_path_acc)
+		{
+			int n = re_numblocks(re);
+			
+			INC_SEQNUM(this_host.seqnum);
+			re->re_blocks[n].g		= this_host.is_gw;
+			re->re_blocks[n].prefix		= this_host.prefix;
+			re->re_blocks[n].res		= 0;
+			re->re_blocks[n].re_hopcnt	= 0;
+			re->re_blocks[n].re_node_seqnum	= htonl(this_host.seqnum);
+			
+			re->len += RE_BLOCK_SIZE;
+			
+			// If this is a RREQ
+			if (re->a)
+				re_forward_rreq_path_acc(re, n);
+			// Else if this is a RREP
+			else
+			{
+				re->re_blocks[n].re_node_addr	=
+					(u_int32_t) DEV_IFINDEX(ifindex).ipaddr.s_addr;
+				re_forward_rrep_path_acc(re);
+			}
+		}
+		else
+			re_forward(re);
+	}
+}
+
+int NS_CLASS re_process_block(struct re_block *block, u_int8_t is_rreq,
+	rtable_entry_t *entry, struct in_addr ip_src, u_int32_t ifindex)
+{
+	struct in_addr dest_addr;
+	u_int32_t seqnum;
+	int rb_state;
+	
+	if (!block)
+		return -1;
+	
+	dest_addr.s_addr	= block->re_node_addr;
+	seqnum			= ntohl(block->re_node_seqnum);
+	
+	// Increment block hop count
+	block->re_hopcnt++;
+	
+	rb_state = re_info_type(block, entry, is_rreq);
+	if (rb_state != RB_FRESH)
+	{
+		dlog(LOG_DEBUG, 0, __FUNCTION__, "ignoring a %s RE block",
+			(rb_state == RB_STALE ? "stale" : (rb_state == RB_LOOP_PRONE ?
+			"loop-prone" : (rb_state == RB_INFERIOR ? "inferior" :
+			"self-generated"))));
+		return -1;
+	}
+	
+	// Create/update a route towards RENodeAddress
+	if (entry)
+		rtable_update(
+			entry,			// routing table entry
+			dest_addr,		// dest
+			ip_src,			// nxt hop
+			ifindex,		// iface
+			seqnum,			// seqnum
+			block->prefix,		// prefix
+			block->re_hopcnt,	// hop count
+			block->g);		// is gw
+	else
+		rtable_insert(
+			dest_addr,		// dest
+			ip_src,			// nxt hop
+			ifindex,		// iface
+			seqnum,			// seqnum
+			block->prefix,		// prefix
+			block->re_hopcnt,	// hop count
+			block->g);		// is gw
+	
+	return 0;
+}
+
+void NS_CLASS __re_send(RE *re)
+{
+	struct in_addr dest_addr;
+	int i;
+	
+	// If it is a RREQ
+	if (re->a)
+	{
+		dest_addr.s_addr = DYMO_BROADCAST;
+	
+		// Queue the new RE
+		re = (RE *) dymo_socket_queue((DYMO_element *) re);
+	
+		// Send RE over all enabled interfaces
+		for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+			if (DEV_NR(i).enabled)
+				dymo_socket_send(dest_addr, &DEV_NR(i));
+	}
+	// Else if RREP
+	else
+	{
+		dest_addr.s_addr = re->target_addr;
+		rtable_entry_t *entry = rtable_find(dest_addr);
+		if (entry && entry->rt_state == RT_VALID)
+		{
+			dest_addr.s_addr = entry->rt_nxthop_addr.s_addr;
+			
+			// Queue the new RE
+			re = (RE *) dymo_socket_queue((DYMO_element *) re);
+			
+			// Send RE over appropiate interface
+			if (DEV_IFINDEX(entry->rt_ifindex).enabled)
+				dymo_socket_send(dest_addr, &DEV_IFINDEX(entry->rt_ifindex));
+			
+			// Add next hop to the blacklist until we receive a
+			// unicast message from it
+			if (re->s)
+			{
+				blacklist_t *blacklist
+					= blacklist_add(dest_addr);
+				
+				timer_init(&blacklist->timer, &NS_CLASS blacklist_timeout,
+					blacklist);
+				timer_set_timeout(&blacklist->timer, BLACKLIST_TIMEOUT);
+				timer_add(&blacklist->timer);
+			}
+		}
+	}
+}
+
+void NS_CLASS re_send_rrep(RE *rrep)
+{
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "sending RREP to %s",
+		ip2str(rrep->target_addr));
+	__re_send(rrep);
+}
+
+void NS_CLASS re_send_rreq(struct in_addr dest_addr, u_int32_t seqnum,
+	u_int8_t thopcnt)
+{
+	int i;
+	RE *rreq;
+	struct in_addr bcast_addr;
+	
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "sending RREQ to find %s",
+		ip2str(dest_addr.s_addr));
+	
+	bcast_addr.s_addr = DYMO_BROADCAST;
+	
+	INC_SEQNUM(this_host.seqnum);
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+	{
+		if (DEV_NR(i).enabled)
+		{
+			rreq = re_create_rreq(dest_addr, seqnum,
+				DEV_NR(i).ipaddr, this_host.seqnum,
+				this_host.prefix, this_host.is_gw,
+				NET_DIAMETER, thopcnt);
+			
+			dymo_socket_queue((DYMO_element *) rreq);
+			dymo_socket_send(bcast_addr, &DEV_NR(i));
+		}
+	}
+}
+
+void NS_CLASS re_forward(RE *re)
+{
+	if (re->a)
+		dlog(LOG_DEBUG, 0, __FUNCTION__, "forwarding RREQ to find %s",
+			ip2str(re->target_addr));
+	else
+		dlog(LOG_DEBUG, 0, __FUNCTION__, "forwarding RREP to %s",
+			ip2str(re->target_addr));
+	__re_send(re);
+}
+
+void NS_CLASS re_forward_rreq_path_acc(RE *rreq, int blindex)
+{
+	int i;
+	struct in_addr bcast_addr;
+	
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "forwarding RREQ to find %s",
+		ip2str(rreq->target_addr));
+	
+	bcast_addr.s_addr = DYMO_BROADCAST;
+	
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+	{
+		if (DEV_NR(i).enabled)
+		{
+			rreq->re_blocks[blindex].re_node_addr =
+				(u_int32_t) DEV_NR(i).ipaddr.s_addr;
+			
+			dymo_socket_queue((DYMO_element *) rreq);
+			dymo_socket_send(bcast_addr, &DEV_NR(i));
+		}
+	}
+}
+
+void NS_CLASS re_forward_rrep_path_acc(RE *rrep)
+{
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "forwarding RREP to %s",
+		ip2str(rrep->target_addr));
+	__re_send(rrep);
+}
+
+void NS_CLASS route_discovery(struct in_addr dest_addr)
+{
+	u_int32_t	seqnum;
+	u_int8_t	thopcnt;
+	
+	// If we are already doing a route discovery for dest_addr,
+	// then simply return
+	if (pending_rreq_find(dest_addr))
+		return;
+	
+	// Get info from routing table (if there exists an entry)
+	rtable_entry_t *rt_entry = rtable_find(dest_addr);
+	if (rt_entry)
+	{
+		seqnum	= rt_entry->rt_seqnum;
+		thopcnt	= rt_entry->rt_hopcnt;
+	}
+	else
+	{
+		seqnum	= 0;
+		thopcnt	= 0;
+	}
+	
+	// Send a RREQ
+	re_send_rreq(dest_addr, seqnum, thopcnt);
+	
+	// Record information for destination and set a timer
+	pending_rreq_t *pend_rreq = pending_rreq_add(dest_addr, seqnum);
+	timer_init(&pend_rreq->timer, &NS_CLASS route_discovery_timeout,
+		pend_rreq);
+	timer_set_timeout(&pend_rreq->timer, RREQ_WAIT_TIME);
+	timer_add(&pend_rreq->timer);
+}
diff -Naur ns-2.35-orig/dymoum/dymo_re.h ns-2.35/dymoum/dymo_re.h
--- ns-2.35-orig/dymoum/dymo_re.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_re.h	2006-08-30 18:20:46.000000000 +0200
@@ -0,0 +1,197 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_RE_H__
+#define __DYMO_RE_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include "defs.h"
+#include "rtable.h"
+#include "debug.h"
+
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <stdlib.h>
+#include <assert.h>
+
+
+#define RREQ_WAIT_TIME	1000
+#define RREQ_TRIES	3
+
+#define RB_STALE	0
+#define RB_LOOP_PRONE	1
+#define RB_INFERIOR	2
+#define RB_FRESH	3
+#define RB_SELF_GEN	4
+
+
+/* Routing blocks advertised in a RE message */
+struct re_block {
+# if __BYTE_ORDER == __BIG_ENDIAN
+	u_int16_t	g : 1;
+	u_int16_t	prefix : 7;
+	u_int16_t	res : 2;
+	u_int16_t	re_hopcnt : 6;
+# elif __BYTE_ORDER == __LITTLE_ENDIAN
+	u_int16_t	res : 2;
+	u_int16_t	re_hopcnt : 6;
+	u_int16_t	g : 1;
+	u_int16_t	prefix : 7;
+# else
+#   error "Adjust your <bits/endian.h> defines"
+# endif
+	u_int32_t	re_node_addr;
+	u_int32_t	re_node_seqnum;
+};
+#define MAX_RE_BLOCKS 50
+
+/* RE message */
+typedef struct {	// FIXME: adjust byte ordering
+	u_int32_t	m : 1;
+	u_int32_t	h : 2;
+	u_int32_t	type : 5;
+	u_int32_t	len : 12;
+	u_int32_t	ttl : 6;
+	u_int32_t	i : 1;
+	u_int32_t	a : 1;
+	u_int32_t	s : 1;
+	u_int32_t	res1 : 3;
+	
+	u_int32_t	target_addr;
+	u_int32_t	target_seqnum;
+	
+	u_int8_t	thopcnt : 6;
+	u_int8_t	res2 : 2;
+	
+	struct re_block	re_blocks[MAX_RE_BLOCKS];
+} RE;
+
+#define RE_BLOCK_SIZE	sizeof(struct re_block)
+#define RE_SIZE		sizeof(RE)
+#define RE_BASIC_SIZE	(RE_SIZE - (MAX_RE_BLOCKS * RE_BLOCK_SIZE))
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Create a RREQ */
+RE *re_create_rreq(struct in_addr target_addr,
+		u_int32_t target_seqnum,
+		struct in_addr re_node_addr,
+		u_int32_t re_node_seqnum,
+		u_int8_t prefix, u_int8_t g,
+		u_int8_t ttl, u_int8_t thopcnt);
+
+/* Create a RREP */
+RE *re_create_rrep(struct in_addr target_addr,
+		u_int32_t target_seqnum,
+		struct in_addr re_node_addr,
+		u_int32_t re_node_seqnum,
+		u_int8_t prefix, u_int8_t g,
+		u_int8_t ttl, u_int8_t thopcnt);
+
+/* Process a RE message */
+void re_process(RE *re, struct in_addr ip_src, u_int32_t ifindex);
+
+/* Process a RE block updating suitable fields and modifying the routing
+   table accordingly. Return a negative value if the block was not processed */
+int re_process_block(struct re_block *block,
+		u_int8_t is_rreq,
+		rtable_entry_t *entry,
+		struct in_addr ip_src,
+		u_int32_t ifindex);
+
+/* Auxilliary function, do not use */
+void __re_send(RE *re);
+
+/* Send a given RREP */
+void re_send_rrep(RE *rrep);
+
+/* Send a RREQ given the destination address and the destination sequence
+   number */
+void re_send_rreq(struct in_addr dest_addr, u_int32_t seqnum, u_int8_t thopcnt);
+
+/* Forward a given RE (RREQ/RREP) when there is no path accumulation */
+void re_forward(RE *re);
+
+/* Forward a given RREQ when there is path accumulation. Given index is used
+   to access the RE block which has been added */
+void re_forward_rreq_path_acc(RE *rreq, int blindex);
+
+/* Forward a RREP when there is path accumulation */
+void re_forward_rrep_path_acc(RE *rrep);
+
+/* Implement route discovery */
+void route_discovery(struct in_addr dest_addr);
+
+/* Return the number of blocks contained inside a RE */
+static NS_INLINE int re_numblocks(RE *re)
+{
+	assert(re);
+	
+	if ((re->len - RE_BASIC_SIZE) % RE_BLOCK_SIZE != 0)
+		return -1;
+	return (re->len - RE_BASIC_SIZE) / RE_BLOCK_SIZE;
+}
+
+/* Return the routing information type: self-generated, stale, loop-prone,
+   inferior or stale */
+NS_STATIC NS_INLINE int re_info_type(struct re_block *b, rtable_entry_t *e, u_int8_t is_rreq)
+{
+	u_int32_t node_seqnum;
+	int32_t sub;
+	int i;
+	
+	assert(b);
+	
+	// If the block was issued from one interface of the processing node,
+	// then the block is considered stale
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+	{
+		if (this_host.devs[i].enabled &&
+			this_host.devs[i].ipaddr.s_addr == b->re_node_addr)
+		{
+			return RB_SELF_GEN;
+		}
+	}
+	
+	if (e)
+	{
+		node_seqnum	= ntohl(b->re_node_seqnum);
+		sub		= ((int32_t) node_seqnum) - ((int32_t) e->rt_seqnum);
+		
+		if (sub < 0)
+			return RB_STALE;
+		if (sub == 0)
+		{
+			if (e->rt_hopcnt == 0 || b->re_hopcnt == 0 || b->re_hopcnt > e->rt_hopcnt + 1)
+				return RB_LOOP_PRONE;
+			if (e->rt_state == RT_VALID && (b->re_hopcnt > e->rt_hopcnt || (b->re_hopcnt == e->rt_hopcnt && is_rreq)))
+				return RB_INFERIOR;
+		}
+	}
+	return RB_FRESH;
+}
+
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __DYMO_RE_H__ */
diff -Naur ns-2.35-orig/dymoum/dymo_rerr.c ns-2.35/dymoum/dymo_rerr.c
--- ns-2.35-orig/dymoum/dymo_rerr.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_rerr.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,162 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "dymo_rerr.h"
+#include "dymo_socket.h"
+#include <string.h>
+
+#endif	/* NS_PORT */
+
+
+RERR *NS_CLASS rerr_create(struct rerr_block *blocks, int nblocks, int ttl)
+{
+	int i;
+	RERR *rerr;
+	
+	rerr		= (RERR *) dymo_socket_new_element();
+	rerr->m		= 0;
+	rerr->h		= 0;
+	rerr->type	= DYMO_RERR_TYPE;
+	rerr->len	= RERR_BASIC_SIZE + (nblocks * RERR_BLOCK_SIZE);
+	rerr->ttl	= ttl;
+	rerr->i		= 0;
+	
+	for (i = 0; i < nblocks; i++)
+	{
+		rerr->rerr_blocks[i].unode_addr = blocks[i].unode_addr;
+		rerr->rerr_blocks[i].unode_seqnum = blocks[i].unode_seqnum;
+	}
+	
+	return rerr;
+}
+
+void NS_CLASS rerr_send(struct in_addr addr, int ttl, rtable_entry_t *entry)
+{
+	int i = 1;
+	struct rerr_block blocks[MAX_RERR_BLOCKS];
+	
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "sending RERR");
+	
+	memset(blocks, '\0', MAX_RERR_BLOCKS * sizeof(struct rerr_block));
+	blocks[0].unode_addr = addr.s_addr;
+	
+	if (entry)
+	{
+		dlist_head_t *pos;
+		
+		blocks[0].unode_seqnum = entry->rt_seqnum;
+		dlist_for_each(pos, &rtable.l)
+		{
+			rtable_entry_t *e = (rtable_entry_t *) pos;
+			if (e != entry && (e->rt_nxthop_addr.s_addr
+				== entry->rt_nxthop_addr.s_addr) && 
+				(e->rt_ifindex == entry->rt_ifindex))
+			{
+				i++;
+				blocks[i-1].unode_addr		= e->rt_dest_addr.s_addr;
+				blocks[i-1].unode_seqnum	= e->rt_seqnum;
+			}
+		}
+	}
+	else
+		blocks[0].unode_seqnum = 0;
+	
+	RERR *rerr = rerr_create(blocks, i, ttl);
+	rerr_forward(rerr);
+}
+
+void NS_CLASS rerr_process(RERR *rerr, struct in_addr src, u_int32_t ifindex)
+{
+	struct in_addr node_addr;
+	rtable_entry_t *entry;
+	int i;
+	
+	// Be sure that there is a block at least
+	if (rerr_numblocks(rerr) <= 0)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__, "malformed RERR received");
+		return;
+	}
+	
+	for (i = 0; i < rerr_numblocks(rerr); i++)
+	{
+		int changed = 0;
+		
+		node_addr.s_addr	= rerr->rerr_blocks[i].unode_addr;
+		entry			= rtable_find(node_addr);
+		
+		if (entry && entry->rt_state == RT_VALID)
+		{
+			int32_t sub;
+			u_int32_t unode_seqnum =
+				ntohl(rerr->rerr_blocks[i].unode_seqnum);
+			u_int32_t rt_seqnum = ntohl(entry->rt_seqnum);
+			
+			sub = (int32_t) unode_seqnum - (int32_t) rt_seqnum;
+			
+			if (entry->rt_nxthop_addr.s_addr == src.s_addr &&
+				entry->rt_ifindex == ifindex &&
+				(unode_seqnum == 0 || sub <= 0))
+			{
+				rtable_expire_timeout(entry);
+				changed = 1;
+			}
+		}
+		
+		if (!changed)
+		{
+			// drop block
+			int n = rerr_numblocks(rerr) - i - 1;
+			
+			memmove(&rerr->rerr_blocks[i], &rerr->rerr_blocks[i+1],
+				n * sizeof(struct rerr_block));
+			memset(&rerr->rerr_blocks[i + n], 0, sizeof(struct rerr_block));
+			
+			rerr->len -= RERR_BLOCK_SIZE;
+			i--;
+		}
+	}
+	
+	if (rerr_numblocks(rerr) > 0 &&
+		generic_postprocess((DYMO_element *) rerr))
+	{
+		rerr_forward(rerr);
+	}
+}
+
+void NS_CLASS rerr_forward(RERR *rerr)
+{
+	struct in_addr dest_addr;
+	int i;
+	
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "forwarding RERR");
+	
+	// Queue the new RERR
+	rerr = (RERR *) dymo_socket_queue((DYMO_element *) rerr);
+	
+	// Send RERR over all enabled interfaces
+	dest_addr.s_addr = DYMO_BROADCAST;
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+		if (DEV_NR(i).enabled)
+			dymo_socket_send(dest_addr, &DEV_NR(i));
+}
diff -Naur ns-2.35-orig/dymoum/dymo_rerr.h ns-2.35/dymoum/dymo_rerr.h
--- ns-2.35-orig/dymoum/dymo_rerr.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_rerr.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,86 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_RERR_H__
+#define __DYMO_RERR_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include "defs.h"
+#include "debug.h"
+#include "rtable.h"
+#include <assert.h>
+#include <sys/types.h>
+
+/* Blocks contained within a RERR message */
+struct rerr_block {
+	u_int32_t	unode_addr;
+	u_int32_t	unode_seqnum;
+};
+#define MAX_RERR_BLOCKS	50
+
+/* RERR message */
+typedef struct {	// FIXME: adjust byte ordering
+	u_int32_t	m : 1;
+	u_int32_t	h : 2;
+	u_int32_t	type : 5;
+	u_int32_t	len : 12;
+	u_int32_t	ttl : 6;
+	u_int32_t	i : 1;
+	u_int32_t	res : 5;
+	
+	struct rerr_block rerr_blocks[MAX_RERR_BLOCKS];
+} RERR;
+
+#define RERR_SIZE	sizeof(RERR)
+#define RERR_BLOCK_SIZE	sizeof(struct rerr_block)
+#define RERR_BASIC_SIZE	(RERR_SIZE - (MAX_RERR_BLOCKS * RERR_BLOCK_SIZE))
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Create a RERR given an array of blocks (previously created), the number of
+   those blocks and the TTL of the message */
+RERR *rerr_create(struct rerr_block *blocks, int nblocks, int ttl);
+
+/* Send a RERR */
+void rerr_send(struct in_addr addr, int ttl, rtable_entry_t *entry);
+
+/* Forward a RERR */
+void rerr_forward(RERR *rerr);
+
+/* Process a RERR given the address of the sender of the message and the
+   interface from which the message was received */
+void rerr_process(RERR *rerr, struct in_addr src, u_int32_t ifindex);
+
+/* Return the number of blocks contained inside a RERR */
+static NS_INLINE int rerr_numblocks(RERR *rerr)
+{
+	assert(rerr);
+	
+	if ((rerr->len - RERR_BASIC_SIZE) % RERR_BLOCK_SIZE != 0)
+		return -1;
+	return (rerr->len - RERR_BASIC_SIZE) / RERR_BLOCK_SIZE;
+}
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __DYMO_RERR_H__ */
diff -Naur ns-2.35-orig/dymoum/dymo_socket.c ns-2.35/dymoum/dymo_socket.c
--- ns-2.35-orig/dymoum/dymo_socket.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_socket.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,339 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "dymo_socket.h"
+#include "debug.h"
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <net/if.h>
+#include <netinet/ip.h>
+#include <arpa/inet.h>
+#include <errno.h>
+
+
+#define SO_RECVBUF_SIZE (256 * 1024)
+
+/* Receiving and sending buffers */
+static char recv_buf[RECV_BUF_SIZE];
+static char send_buf[SEND_BUF_SIZE];
+
+static void dymo_socket_read(int fd);
+
+#endif	/* NS_PORT */
+
+void NS_CLASS dymo_socket_init()
+{
+#ifndef NS_PORT
+	struct sockaddr_in dymo_addr;
+	char ifname[IFNAMSIZ];
+	int i;
+	int on			= 1;
+	int tos			= IPTOS_LOWDELAY;
+	int bufsize		= SO_RECVBUF_SIZE;
+	socklen_t bufoptlen	= sizeof(bufsize);
+	
+	// Check if there are no interfaces
+	if (this_host.nif == 0)
+	{
+		dlog(LOG_ERR, 0, __FUNCTION__, "No interfaces configured\n");
+		exit(EXIT_FAILURE);
+	}
+	
+	// For each interface...
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+	{
+		if (!DEV_NR(i).enabled)
+			continue;
+		
+		// Create an UDP socket
+		if ((DEV_NR(i).sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
+		{
+			dlog(LOG_ERR, errno, __FUNCTION__, "socket() failed");
+			exit(EXIT_FAILURE);
+		}
+		
+		// Bind to DYMO port number
+		memset(&dymo_addr, 0, sizeof(struct sockaddr_in));
+		dymo_addr.sin_family		= AF_INET;
+		dymo_addr.sin_port		= htons(DYMO_PORT);
+		dymo_addr.sin_addr.s_addr	= htonl(INADDR_ANY);
+		
+		if (bind(DEV_NR(i).sock,
+			(struct sockaddr *)&dymo_addr,
+			sizeof(struct sockaddr)) < 0)
+		{
+			dlog(LOG_ERR, errno, __FUNCTION__, "bind() failed");
+			exit(EXIT_FAILURE);
+		}
+		
+		// Enable the datagram socket as a broadcast one
+		if (setsockopt(DEV_NR(i).sock,
+			SOL_SOCKET,
+			SO_BROADCAST,
+			&on,
+			sizeof(int)) < 0)
+		{
+			dlog(LOG_ERR, errno, __FUNCTION__, "setsockopt(BROADCAST) failed");
+			exit(EXIT_FAILURE);
+		}
+		
+		// Make the socket only process packets received from an interface
+		strncpy(ifname, DEV_NR(i).ifname, sizeof(ifname));
+		
+		if (setsockopt(DEV_NR(i).sock,
+			SOL_SOCKET,
+			SO_BINDTODEVICE,
+			&ifname,
+			sizeof(ifname)) < 0)
+		{
+			dlog(LOG_ERR, errno, __FUNCTION__, "setsockopt(BINDTODEVICE)"
+				" failed for %s", DEV_NR(i).ifname);
+			exit(EXIT_FAILURE);
+		}
+		
+		// Set priority of IP datagrams
+		if (setsockopt(DEV_NR(i).sock,
+			SOL_SOCKET,
+			SO_PRIORITY,
+			&tos,
+			sizeof(int)) < 0)
+		{
+			dlog(LOG_ERR, errno, __FUNCTION__, "setsockopt(PRIORITY)"
+				" failed for LOWDELAY");
+			exit(EXIT_FAILURE);
+		}
+		
+		// Set maximum allowable receive buffer size
+		for ( ; ; bufsize -= 1024)
+		{
+			if (setsockopt(DEV_NR(i).sock,
+				SOL_SOCKET,
+				SO_RCVBUF,
+				(char *) &bufsize,
+				bufoptlen) == 0)
+			{
+				dlog(LOG_NOTICE, 0, __FUNCTION__,
+					"receive buffer size set to %d",
+					bufsize);
+				break;
+			}
+			if (bufsize < RECV_BUF_SIZE)
+			{
+				dlog(LOG_ERR, 0, __FUNCTION__, "could not set receive buffer size");
+				exit(EXIT_FAILURE);
+			}
+			
+		}
+		
+		// Attach callback function
+		if (attach_callback_func(DEV_NR(i).sock, dymo_socket_read) < 0)
+		{
+			dlog(LOG_ERR, 0, __FUNCTION__, "could not register input handler");
+			exit(EXIT_FAILURE);
+		}
+	}
+#endif	/* NS_PORT */
+	num_dymo_msgs = 0;
+}
+
+void NS_CLASS dymo_socket_fini()
+{
+#ifndef NS_PORT
+	int i;
+	
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+	{
+		if (!DEV_NR(i).enabled)
+			continue;
+		close(DEV_NR(i).sock);
+	}
+#endif	/* NS_PORT */
+}
+
+DYMO_element *NS_CLASS dymo_socket_new_element()
+{
+	memset(send_buf, '\0', SEND_BUF_SIZE);
+	return (DYMO_element *) send_buf;
+}
+
+DYMO_element *NS_CLASS dymo_socket_queue(DYMO_element *e)
+{
+	memcpy((char *) send_buf, e, e->len);
+	return (DYMO_element *) send_buf;
+}
+
+void NS_CLASS dymo_socket_send(struct in_addr dest_addr, struct dev_info *dev)
+{
+	struct timeval now;
+#ifndef NS_PORT
+	struct sockaddr_in dest_sockaddr;
+	u_int8_t ttl;
+	
+	dest_sockaddr.sin_family	= AF_INET;
+	dest_sockaddr.sin_addr		= dest_addr;
+	dest_sockaddr.sin_port		= htons(DYMO_PORT);
+	
+	// Set TTL
+	ttl = DYMO_IPTTL;
+	if (setsockopt(dev->sock,
+		SOL_IP,
+		IP_TTL,
+		&ttl,
+		sizeof(ttl)) < 0)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "setsockopt(IP_TTL) failed");
+		exit(EXIT_FAILURE);
+	}
+#else
+	
+	int len = ((DYMO_element *) send_buf)->len;
+	
+	Packet *p		= allocpkt();
+	struct hdr_cmn *ch	= HDR_CMN(p);
+	struct hdr_ip *ih	= HDR_IP(p);
+	hdr_dymoum *dh		= HDR_DYMOUM(p);
+	
+	memset(dh, '\0', DYMO_MSG_MAX_SIZE);
+	memcpy(dh, send_buf, len);
+	
+	ch->ptype()	= PT_DYMOUM;
+	ch->direction()	= hdr_cmn::DOWN;
+	ch->size()	= IP_HDR_LEN + len;
+	ch->error()	= 0;
+	ch->next_hop_	= (nsaddr_t) dest_addr.s_addr;
+	ch->prev_hop_	= (nsaddr_t) dev->ipaddr.s_addr;
+	ch->addr_type()	= NS_AF_INET;
+	
+	ih->saddr()	= (nsaddr_t) dev->ipaddr.s_addr;
+	ih->daddr()	= (nsaddr_t) dest_addr.s_addr;
+	ih->sport()	= RT_PORT;
+	ih->dport()	= RT_PORT;
+	ih->ttl()	= DYMO_IPTTL;
+#endif	/* NS_PORT */
+	
+	// Rate limit stuff
+	gettimeofday(&now, NULL);
+	if (num_dymo_msgs == DYMO_RATELIMIT - 1)
+	{
+		if (timeval_diff(&now, &dymo_rate[0]) < 1000)
+			return;	// dropping packet
+		else
+		{
+			memmove(dymo_rate,
+				&dymo_rate[1],
+				sizeof(struct timeval) * (num_dymo_msgs - 1));
+			dymo_rate[num_dymo_msgs-1] = now;
+		}
+	}
+	else
+	{
+		dymo_rate[num_dymo_msgs] = now;
+		num_dymo_msgs++;
+	}
+	
+	// Send the queued packet
+#ifdef NS_PORT
+	/*if (ih->daddr() == IP_BROADCAST)
+		Scheduler::instance().schedule(target_, p, 0.02 * Random::uniform());
+	else*/ // TODO: add jitter for sending broadcast messages?
+		Scheduler::instance().schedule(target_, p, 0.0);
+#else
+	if (sendto(dev->sock, send_buf, ((DYMO_element *) send_buf)->len,
+		0, (struct sockaddr *) &dest_sockaddr, sizeof(dest_sockaddr)) < 0)
+	{
+		dlog(LOG_WARNING, errno, __FUNCTION__, "failed send to %s", ip2str(dest_addr.s_addr));
+		return;
+	}
+#endif	/* NS_PORT */
+}
+
+#ifdef NS_PORT
+void NS_CLASS recv_dymoum_pkt(Packet *p)
+{
+	struct in_addr src_addr;
+	struct hdr_cmn *ch	= HDR_CMN(p);
+	struct hdr_ip *ih	= HDR_IP(p);
+	hdr_dymoum *dh		= HDR_DYMOUM(p);
+	DYMO_element *e		= (DYMO_element *) recv_buf;
+	
+	assert(ch->ptype() == PT_DYMOUM);
+	assert(ch->direction() == hdr_cmn::UP);
+	assert(ih->sport() == RT_PORT);
+	assert(ih->dport() == RT_PORT);
+	
+	src_addr.s_addr	= ih->saddr();
+	memcpy(recv_buf, dh, RECV_BUF_SIZE);
+	
+	Packet::free(p);
+	
+	generic_process_message(e, src_addr, NS_IFINDEX);
+}
+#else
+static void dymo_socket_read(int fd)
+{
+	int i, len;
+	DYMO_element *msg;
+	struct dev_info *dev;
+	struct sockaddr_in sender_addr;
+	socklen_t addr_len = sizeof(struct sockaddr_in);
+	
+	// Receive message
+	if ((len = recvfrom(fd, recv_buf, RECV_BUF_SIZE, 0,
+		(struct sockaddr *) &sender_addr, &addr_len)) < 0)
+	{
+		dlog(LOG_WARNING, errno, __FUNCTION__, "could not receive message");
+		return;
+	}
+	
+	// Ignore messages generated locally
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+		if (DEV_NR(i).enabled && DEV_NR(i).ipaddr.s_addr ==
+			sender_addr.sin_addr.s_addr)
+			return;
+	
+	dev = devfromsock(fd);
+	if (!dev)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__, "could not get device info");
+		return;
+	}
+	
+	msg = (DYMO_element *) recv_buf;
+	if (msg->len != len)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__,
+			"actual message length did not match with stated length: %d != %d",
+			len, msg->len);
+		return;
+	}
+	
+	generic_process_message(msg, sender_addr.sin_addr, dev->ifindex);
+}
+#endif	/* NS_PORT */
diff -Naur ns-2.35-orig/dymoum/dymo_socket.h ns-2.35/dymoum/dymo_socket.h
--- ns-2.35-orig/dymoum/dymo_socket.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_socket.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,68 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_SOCKET_H__
+#define __DYMO_SOCKET_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include "defs.h"
+#include "dymo_generic.h"
+#include "dymo_re.h"
+
+#include <netinet/in.h>
+
+/* We are allowing a maximum DYMO message size of a RE message
+   which advertises MAX_RE_BLOCKS RENodeAddresses */
+#define DYMO_MSG_MAX_SIZE	RE_SIZE
+#define RECV_BUF_SIZE		DYMO_MSG_MAX_SIZE
+#define SEND_BUF_SIZE		DYMO_MSG_MAX_SIZE
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Used to limit rate of sending DYMO messages */
+struct timeval dymo_rate[DYMO_RATELIMIT - 1];
+int num_dymo_msgs;
+
+/* Creates and configures an UDP socket for each enabled interface */
+void dymo_socket_init();
+
+/* Closes all sockets */
+void dymo_socket_fini();
+
+/* Prepares sending buffer for a new element */
+DYMO_element *dymo_socket_new_element();
+
+/* Queues an element before it is sent */
+DYMO_element *dymo_socket_queue(DYMO_element *e);
+
+/* Sends queued DYMO element */
+void dymo_socket_send(struct in_addr dest_addr, struct dev_info *dev);
+
+#ifdef NS_PORT
+/* Process a received DYMO packet */
+void recv_dymoum_pkt(Packet *p);
+#endif	/* NS_PORT */
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __DYMO_SOCKET_H__ */
diff -Naur ns-2.35-orig/dymoum/dymo_timeout.c ns-2.35/dymoum/dymo_timeout.c
--- ns-2.35-orig/dymoum/dymo_timeout.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_timeout.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,138 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "dymo_timeout.h"
+#include "dymo_re.h"
+#include "dymo_netlink.h"
+#include "pending_rreq.h"
+#include "rtable.h"
+#include "blacklist.h"
+#include "dymo_nb.h"
+#include "debug.h"
+
+
+extern int reissue_rreq;
+#endif	/* NS_PORT */
+
+void NS_CLASS route_valid_timeout(void *arg)
+{
+	rtable_entry_t *entry = (rtable_entry_t *) arg;
+	
+	if (!entry)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__,
+			"NULL routing table entry, ignoring timeout");
+		return;
+	}
+	
+	rtable_invalidate(entry);
+}
+
+void NS_CLASS route_del_timeout(void *arg)
+{
+	rtable_entry_t *entry = (rtable_entry_t *) arg;
+	
+	if (!entry)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__,
+			"NULL routing table entry, ignoring timeout");
+		return;
+	}
+	
+	//if (entry->rt_state == RT_INVALID) // I think this isn't needed
+		rtable_delete(entry);
+}
+
+void NS_CLASS blacklist_timeout(void *arg)
+{
+	blacklist_t *entry = (blacklist_t *) arg;
+	
+	if (!entry)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__,
+			"NULL blacklist entry, ignoring timeout");
+		return;
+	}
+	
+	blacklist_remove(entry);
+}
+
+void NS_CLASS route_discovery_timeout(void *arg)
+{
+	pending_rreq_t *entry = (pending_rreq_t *) arg;
+	
+	if (!entry)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__,
+			"NULL pending route discovery list entry,"
+			" ignoring timeout");
+		return;
+	}
+	
+	if (reissue_rreq)
+	{
+		if (entry->tries < RREQ_TRIES)
+		{
+			rtable_entry_t *rte;
+			
+			entry->tries++;
+			timer_set_timeout(&entry->timer,
+				RREQ_WAIT_TIME << entry->tries);
+			timer_add(&entry->timer);
+			
+			rte = rtable_find(entry->dest_addr);
+			if (rte)
+				re_send_rreq(entry->dest_addr, entry->seqnum,
+					rte->rt_hopcnt);
+			else
+				re_send_rreq(entry->dest_addr, entry->seqnum,
+					0);
+			
+			return;
+		}
+	}
+#ifdef NS_PORT
+	packet_queue_set_verdict(entry->dest_addr, PQ_DROP);
+#else
+	netlink_no_route_found(entry->dest_addr);
+#endif	/* NS_PORT */
+	
+	pending_rreq_remove(entry);
+}
+
+void NS_CLASS nb_timeout(void *arg)
+{
+	nb_t *nb = (nb_t *) arg;
+	
+	if (!nb)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__,
+			"NULL nblist entry, ignoring timeout");
+		return;
+	}
+	
+	// A link break has been detected: Expire all routes utilizing the
+	// broken link
+	rtable_expire_timeout_all(nb->nb_addr, nb->ifindex);
+	nb_remove(nb);
+}
diff -Naur ns-2.35-orig/dymoum/dymo_timeout.h ns-2.35/dymoum/dymo_timeout.h
--- ns-2.35-orig/dymoum/dymo_timeout.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_timeout.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,48 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_TIMEOUT_H__
+#define __DYMO_TIMEOUT_H__
+
+#ifndef NS_NO_GLOBALS
+#include "defs.h"
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Handler function called when a routing table entry becomes invalid */
+void route_valid_timeout(void *arg);
+
+/* Handler function called when a routing table entry must be deleted */
+void route_del_timeout(void *arg);
+
+/* Handler function called when no RREP has been received after sending a
+   RREQ */
+void route_discovery_timeout(void *arg);
+
+/* Handler function called when an entry in the blacklist expired */
+void blacklist_timeout(void *arg);
+
+/* Handler function called when an entry in the neighbor list expired */
+void nb_timeout(void *arg);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __DYMO_TIMEOUT_H__ */
diff -Naur ns-2.35-orig/dymoum/dymo_uerr.c ns-2.35/dymoum/dymo_uerr.c
--- ns-2.35-orig/dymoum/dymo_uerr.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_uerr.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,92 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "dymo_uerr.h"
+#include "dymo_socket.h"
+
+#endif	/* NS_PORT */
+
+UERR *NS_CLASS uerr_create(struct in_addr target_addr,
+	struct in_addr uelem_target_addr,
+	struct in_addr uerr_node_addr,
+	u_int8_t uelem_type, u_int8_t ttl)
+{
+	UERR *uerr;
+	
+	uerr		= (UERR *) dymo_socket_new_element();
+	uerr->m		= 0;
+	uerr->h		= 0;
+	uerr->type	= DYMO_UERR_TYPE;
+	uerr->len	= UERR_SIZE;
+	uerr->ttl	= ttl;
+	uerr->i		= 0;
+	uerr->res	= 0;
+	
+	uerr->target_addr	= (u_int32_t) target_addr.s_addr;
+	uerr->uerr_node_addr	= (u_int32_t) uerr_node_addr.s_addr;
+	uerr->uelem_target_addr	= (u_int32_t) uelem_target_addr.s_addr;
+	uerr->uelem_type	= uelem_type;
+	
+	return uerr;
+}
+
+void NS_CLASS uerr_send(DYMO_element *e, u_int32_t ifindex)
+{
+	struct in_addr notify_addr, target_addr;
+	rtable_entry_t *entry;
+	
+	notify_addr.s_addr	= e->notify_addr;
+	target_addr.s_addr	= e->target_addr;
+	
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "sending UERR to %s",
+		ip2str(notify_addr.s_addr));
+
+	UERR *uerr = uerr_create(notify_addr,
+		target_addr,
+		DEV_IFINDEX(ifindex).ipaddr,
+		e->type,
+		NET_DIAMETER);
+	
+	entry = rtable_find(notify_addr);
+	if (entry && entry->rt_state == RT_VALID)
+	{
+		notify_addr.s_addr = entry->rt_nxthop_addr.s_addr;
+		
+		// Queue the new UERR
+		uerr = (UERR *) dymo_socket_queue((DYMO_element *) uerr);
+		
+		// Send UERR over appropriate interface
+		if (DEV_IFINDEX(entry->rt_ifindex).enabled)
+			dymo_socket_send(notify_addr, &DEV_IFINDEX(entry->rt_ifindex));
+	}
+	else
+	{
+		dlog(LOG_DEBUG, 0, __FUNCTION__, "could not send a UERR to %s"
+			" because there is no suitable route",
+			ip2str(notify_addr.s_addr));
+	}
+}
+
+void NS_CLASS uerr_process(UERR *e, struct in_addr ip_src, u_int32_t ifindex)
+{
+}
diff -Naur ns-2.35-orig/dymoum/dymo_uerr.h ns-2.35/dymoum/dymo_uerr.h
--- ns-2.35-orig/dymoum/dymo_uerr.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/dymo_uerr.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,66 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_UERR_H__
+#define __DYMO_UERR_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include "defs.h"
+#include "dymo_generic.h"
+
+#include <sys/types.h>
+#include <netinet/in.h>
+
+/* UERR message */
+typedef struct {	// FIXME: adjust byte ordering
+	u_int32_t	m : 1;
+	u_int32_t	h : 2;
+	u_int32_t	type : 5;
+	u_int32_t	len : 12;
+	u_int32_t	ttl : 6;
+	u_int32_t	i : 1;
+	u_int32_t	res : 5;
+	
+	u_int32_t	target_addr;
+	u_int32_t	uelem_target_addr;
+	u_int32_t	uerr_node_addr;
+	
+	u_int8_t	uelem_type;
+} UERR;
+#define UERR_SIZE	sizeof(UERR)
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Create a UERR message */
+UERR *uerr_create(struct in_addr target_addr, struct in_addr uelem_target_addr,
+	struct in_addr uerr_node_addr, u_int8_t uelem_type, u_int8_t ttl);
+
+/* Send a UERR message given the unsupported message which was received */
+void uerr_send(DYMO_element *e, u_int32_t ifindex);
+
+/* Process a UERR message */
+void uerr_process(UERR *e, struct in_addr ip_src, u_int32_t ifindex);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __DYMO_UERR_H__ */
diff -Naur ns-2.35-orig/dymoum/icmp_socket.c ns-2.35/dymoum/icmp_socket.c
--- ns-2.35-orig/dymoum/icmp_socket.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/icmp_socket.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,271 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "debug.h"
+#include "icmp_socket.h"
+#include "blacklist.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <netinet/ip_icmp.h>
+
+
+/* Sending and receiving buffers */
+static char icmp_send_buf[ICMP_SEND_BUF_SIZE];
+static char icmp_recv_buf[ICMP_RECV_BUF_SIZE];
+
+static void icmp_socket_read(int fd);
+
+#endif  /* NS_PORT */
+
+void NS_CLASS icmp_socket_init(void)
+{
+#ifndef NS_PORT
+	char ifname[IFNAMSIZ];
+	struct icmp *icmp;
+	int i;
+	int tos = IPTOS_LOWDELAY;
+	
+	// Check if there are no interfaces
+	if (this_host.nif == 0)
+	{
+		dlog(LOG_ERR, 0, __FUNCTION__, "No interfaces configured\n");
+		exit(EXIT_FAILURE);
+	}
+	
+	// For each interface...
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+	{
+		if (!DEV_NR(i).enabled)
+			continue;
+		
+		// Create a raw socket
+		if ((DEV_NR(i).icmp_sock = socket(PF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
+		{
+			dlog(LOG_ERR, errno, __FUNCTION__, "socket() failed");
+			exit(EXIT_FAILURE);
+		}
+		
+		// Make the socket only process packets received from an interface
+		strncpy(ifname, DEV_NR(i).ifname, sizeof(ifname));
+		
+		if (setsockopt(DEV_NR(i).icmp_sock,
+			SOL_SOCKET,
+			SO_BINDTODEVICE,
+			&ifname,
+			sizeof(ifname)) < 0)
+		{
+			dlog(LOG_ERR, errno, __FUNCTION__, "setsockopt(BINDTODEVICE)"
+				" failed for %s", DEV_NR(i).ifname);
+			exit(EXIT_FAILURE);
+		}
+		
+		// Set priority of IP datagrams
+		if (setsockopt(DEV_NR(i).icmp_sock,
+			SOL_SOCKET,
+			SO_PRIORITY,
+			&tos,
+			sizeof(int)) < 0)
+		{
+			dlog(LOG_ERR, errno, __FUNCTION__, "setsockopt(PRIORITY)"
+				" failed for LOWDELAY");
+			exit(EXIT_FAILURE);
+		}
+		
+		// Attach callback function
+		if (attach_callback_func(DEV_NR(i).icmp_sock, icmp_socket_read) < 0)
+		{
+			dlog(LOG_ERR, 0, __FUNCTION__, "could not register input handler");
+			exit(EXIT_FAILURE);
+		}
+	}
+	
+	// Prepare the send buffer
+	memset(icmp_send_buf, '\0', ICMP_SEND_BUF_SIZE);
+	icmp			= (struct icmp *) icmp_send_buf;
+	icmp->icmp_type		= ICMP_ECHOREPLY;
+	icmp->icmp_code		= 0;
+	icmp->icmp_cksum	= in_cksum((u_short *) icmp, ICMP_ECHOREPLY_SIZE);
+	icmp->icmp_id		= 0;
+	icmp->icmp_seq		= 0;
+
+#endif	/* NS_PORT */	
+}
+
+void NS_CLASS icmp_socket_fini(void)
+{
+#ifndef NS_PORT
+	int i;
+	
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+	{
+		if (!DEV_NR(i).enabled)
+			continue;
+		close(DEV_NR(i).icmp_sock);
+	}
+#endif	/* NS_PORT */
+}
+
+u_short NS_CLASS in_cksum(u_short *icmp, int len)
+{
+	int nleft	= len;
+	u_short *w	= icmp;
+	int sum		= 0;
+	u_short cksum;
+	
+	while (nleft > 1)
+	{
+		sum	+= *w++;
+		nleft	-= 2;
+	}
+	
+	if (nleft == 1)
+	{
+		u_short u = 0;
+		
+		*(u_char *) (&u) = *(u_char *) w;
+		sum += u;
+	}
+	
+	sum	= (sum >> 16) + (sum & 0xffff);
+	sum	+= (sum >> 16);
+	cksum	= ~sum;
+	
+	return cksum;
+}
+
+void NS_CLASS icmp_reply_send(struct in_addr dest_addr, struct dev_info *dev)
+{
+#ifndef NS_PORT
+	struct sockaddr_in icmp_sockaddr;
+	u_int8_t ttl;
+	
+	icmp_sockaddr.sin_family	= AF_INET;
+	icmp_sockaddr.sin_addr		= dest_addr;
+	icmp_sockaddr.sin_port		= 0;
+	
+	// Set TTL
+	ttl = 1;
+	if (setsockopt(dev->icmp_sock,
+		SOL_IP,
+		IP_TTL,
+		&ttl,
+		sizeof(ttl)) < 0)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "setsockopt(IP_TTL) failed");
+		exit(EXIT_FAILURE);
+	}
+	
+	if (sendto(dev->icmp_sock, icmp_send_buf, ICMP_ECHOREPLY_SIZE, 0,
+		(struct sockaddr *) &icmp_sockaddr, sizeof(icmp_sockaddr)) < 0)
+	{
+		dlog(LOG_WARNING, errno, __FUNCTION__,
+			"failed send ICMP ECHOREPLY to %s",
+			ip2str(dest_addr.s_addr));
+	}
+#else
+	Packet *p		= allocpkt();
+	struct hdr_cmn *ch	= HDR_CMN(p);
+	struct hdr_ip *ih	= HDR_IP(p);
+	hdr_dymoum *dh		= HDR_DYMOUM(p);
+	
+	memset(dh, '\0', DYMO_MSG_MAX_SIZE);
+	dh->type	= DYMO_ECHOREPLY_TYPE;
+	dh->len		= ICMP_ECHOREPLY_SIZE;
+	dh->ttl		= 1;
+		
+	ch->ptype()	= PT_DYMOUM;
+	ch->direction()	= hdr_cmn::DOWN;
+	ch->size()	= IP_HDR_LEN + ICMP_ECHOREPLY_SIZE;
+	ch->error()	= 0;
+	ch->next_hop_	= (nsaddr_t) dest_addr.s_addr;
+	ch->prev_hop_	= (nsaddr_t) dev->ipaddr.s_addr;
+	ch->addr_type()	= NS_AF_INET;
+	
+	ih->saddr()	= (nsaddr_t) dev->ipaddr.s_addr;
+	ih->daddr()	= (nsaddr_t) dest_addr.s_addr;
+	ih->sport()	= RT_PORT;
+	ih->dport()	= RT_PORT;
+	ih->ttl()	= DYMO_IPTTL;
+
+	Scheduler::instance().schedule(target_, p, 0.0);
+
+#endif	/* NS_PORT */
+	
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "sending ICMP msg to %s",
+		ip2str(dest_addr.s_addr));
+}
+
+
+#ifdef NS_PORT
+void NS_CLASS icmp_process(struct in_addr ip_src)
+{
+	blacklist_remove(blacklist_find(ip_src));
+}
+#else
+static void icmp_socket_read(int fd)
+{
+	int i, len;
+	struct ip *ip;
+	struct dev_info *dev;
+	struct sockaddr_in sender_addr;
+	socklen_t addr_len = sizeof(struct sockaddr_in);
+	
+	// Receive message
+	if ((len = recvfrom(fd, icmp_recv_buf, ICMP_RECV_BUF_SIZE, 0,
+		(struct sockaddr *) &sender_addr, &addr_len)) < 0)
+	{
+		dlog(LOG_WARNING, errno, __FUNCTION__, "could not receive message");
+		return;
+	}
+	
+	// Ignore messages generated locally
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+		if (DEV_NR(i).enabled && DEV_NR(i).ipaddr.s_addr ==
+			sender_addr.sin_addr.s_addr)
+			return;
+	
+	dev = devfromicmpsock(fd);
+	if (!dev)
+	{
+		dlog(LOG_WARNING, 0, __FUNCTION__, "could not get device info");
+		return;
+	}
+	
+	/* If this is an ICMP message, remove it from the blacklist.
+	   NOTE: obviously we can receive ICMP messages which aren't sent from
+           a neighbor, but we don't check this because in that case the address
+           isn't in the blacklist and therefore we can safely invoke the
+           procedures below. */
+	ip = (struct ip *) icmp_recv_buf;
+	if (ip->ip_p != IPPROTO_ICMP)
+		return;
+	
+	blacklist_remove(blacklist_find(sender_addr.sin_addr));
+	
+	dlog(LOG_DEBUG, 0, __FUNCTION__, "ICMP msg received in %s from %s",
+		dev->ifname, ip2str(sender_addr.sin_addr.s_addr));
+}
+#endif	/* NS_PORT */
diff -Naur ns-2.35-orig/dymoum/icmp_socket.h ns-2.35/dymoum/icmp_socket.h
--- ns-2.35-orig/dymoum/icmp_socket.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/icmp_socket.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,49 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __ICMP_SOCKET_H__
+#define __ICMP_SOCKET_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include "defs.h"
+#include <netinet/in.h>
+#include <sys/types.h>
+
+#define ICMP_ECHOREPLY_SIZE	8
+#define ICMP_SEND_BUF_SIZE	4096
+#define ICMP_RECV_BUF_SIZE	4096
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+void icmp_socket_init(void);
+void icmp_socket_fini(void);
+u_short in_cksum(u_short *icmp, int len);
+void icmp_reply_send(struct in_addr dest_addr, struct dev_info *dev);
+
+#ifdef NS_PORT
+void icmp_process(struct in_addr ip_src);
+#endif	/* NS_PORT */
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __ICMP_SOCKET_H__ */
diff -Naur ns-2.35-orig/dymoum/k_route.c ns-2.35/dymoum/k_route.c
--- ns-2.35-orig/dymoum/k_route.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/k_route.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,149 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "k_route.h"
+#include "defs.h"
+
+#include <netinet/in.h>
+#include <net/route.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include "debug.h"
+
+
+int k_add_rte(struct in_addr dest_addr,
+		struct in_addr nxthop_addr,
+		struct in_addr netmask,
+		u_int8_t hopcnt,
+		u_int32_t ifindex)
+{
+	int sock, ret;
+	unsigned short int flags;
+	struct rtentry entry;
+	struct sockaddr_in dest_saddr, nxthop_saddr, nm_saddr;
+	
+	if (dest_addr.s_addr == nxthop_addr.s_addr)
+	{
+		nxthop_addr.s_addr = 0;
+		flags = RTF_HOST | RTF_UP | RTF_DYNAMIC;
+	}
+	else
+		flags = RTF_HOST | RTF_GATEWAY | RTF_UP | RTF_DYNAMIC;
+	
+	dest_saddr.sin_family	= AF_INET;
+	nxthop_saddr.sin_family	= AF_INET;
+	nm_saddr.sin_family	= AF_INET;
+	
+	dest_saddr.sin_addr.s_addr	= dest_addr.s_addr;
+	nxthop_saddr.sin_addr.s_addr	= nxthop_addr.s_addr;
+	nm_saddr.sin_addr.s_addr	= netmask.s_addr;
+	
+	memset(&entry, 0, sizeof(struct rtentry));
+	memcpy(&entry.rt_dst, &dest_saddr, sizeof(struct sockaddr_in));
+	memcpy(&entry.rt_gateway, &nxthop_saddr, sizeof(struct sockaddr_in));
+	memcpy(&entry.rt_genmask, &nm_saddr, sizeof(struct sockaddr_in));
+	entry.rt_flags	= flags;
+	entry.rt_metric	= hopcnt + 1;
+	entry.rt_dev	= DEV_IFINDEX(ifindex).ifname;
+	
+	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+	{
+		dlog(LOG_WARNING, errno, __FUNCTION__, "socket() failed, "
+			"couldn't create route to %s",
+			ip2str(dest_addr.s_addr));
+		return sock;
+	}
+	
+	if ((ret = ioctl(sock, SIOCADDRT, &entry)) < 0)
+	{
+		close(sock);
+		dlog(LOG_WARNING, errno, __FUNCTION__, "ioctl() failed, "
+			"couldn't create route to %s",
+			ip2str(dest_addr.s_addr));
+		return ret;
+	}
+	
+	close(sock);
+	
+	return 0;
+}
+
+int k_chg_rte(struct in_addr dest_addr,
+		struct in_addr nxthop_addr,
+		struct in_addr netmask,
+		u_int8_t hopcnt,
+		u_int32_t ifindex)
+{
+	int ret;
+	
+	if ((ret = k_del_rte(dest_addr)) < 0)
+		return ret;
+	
+	if ((ret = k_add_rte(dest_addr, nxthop_addr, netmask, hopcnt, ifindex)) < 0)
+		return ret;
+	
+	return 0;
+}
+
+int k_del_rte(struct in_addr dest_addr)
+{
+	int sock, ret;
+	struct rtentry entry;
+	struct sockaddr_in dest_saddr, nxthop_saddr, nm_saddr;
+	
+	dest_saddr.sin_family	= AF_INET;
+	nxthop_saddr.sin_family	= AF_INET;
+	nm_saddr.sin_family	= AF_INET;
+	
+	dest_saddr.sin_addr.s_addr	= dest_addr.s_addr;
+	nxthop_saddr.sin_addr.s_addr	= 0;
+	nm_saddr.sin_addr.s_addr	= 0;
+	
+	memset(&entry, 0, sizeof(struct rtentry));
+	memcpy(&entry.rt_dst, &dest_saddr, sizeof(struct sockaddr_in));
+	memcpy(&entry.rt_gateway, &nxthop_saddr, sizeof(struct sockaddr_in));
+	memcpy(&entry.rt_genmask, &nm_saddr, sizeof(struct sockaddr_in));
+	entry.rt_flags	= RTF_HOST;
+	
+	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+	{
+		dlog(LOG_WARNING, errno, __FUNCTION__, "socket() failed, "
+			"couldn't delete route to %s",
+			ip2str(dest_addr.s_addr));
+		return sock;
+	}
+	
+	if ((ret = ioctl(sock, SIOCDELRT, &entry)) < 0)
+	{
+		close(sock);
+		dlog(LOG_WARNING, errno, __FUNCTION__, "ioctl() failed, "
+			"couldn't delete route to %s",
+			ip2str(dest_addr.s_addr));
+		return ret;
+	}
+	
+	close(sock);
+	
+	return 0;
+}
diff -Naur ns-2.35-orig/dymoum/k_route.h ns-2.35/dymoum/k_route.h
--- ns-2.35-orig/dymoum/k_route.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/k_route.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,44 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __K_ROUTE_H__
+#define __K_ROUTE_H__
+
+#include <netinet/in.h>
+
+
+/* Add a new route in the kernel routing table */
+int k_add_rte(struct in_addr dest_addr,
+		struct in_addr nxthop_addr,
+		struct in_addr netmask,
+		u_int8_t hopcnt,
+		u_int32_t ifindex);
+
+/* Change a existing route in the kernel routing table */
+int k_chg_rte(struct in_addr dest_addr,
+		struct in_addr nxthop_addr,
+		struct in_addr netmask,
+		u_int8_t hopcnt,
+		u_int32_t ifindex);
+
+/* Delete a route in the kernel routing table */
+int k_del_rte(struct in_addr dest_addr);
+
+#endif	/* __K_ROUTE_H__ */
diff -Naur ns-2.35-orig/dymoum/LICENSE ns-2.35/dymoum/LICENSE
--- ns-2.35-orig/dymoum/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/LICENSE	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Naur ns-2.35-orig/dymoum/lnx/kdymo_destl.c ns-2.35/dymoum/lnx/kdymo_destl.c
--- ns-2.35-orig/dymoum/lnx/kdymo_destl.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/lnx/kdymo_destl.c	2006-08-28 19:15:05.000000000 +0200
@@ -0,0 +1,176 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/* This has been taken from AODVUU implementation (kaodv-expl.c). It maintains
+   a list of destination addresses with a valid route. That could be directly
+   done just by looking up in the routing table, but I don't know how... */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/netdevice.h>
+
+#include "kdymo_destl.h"
+
+
+#define DESTL_MAX_LEN	1024
+
+static unsigned int destl_len;
+static LIST_HEAD(destl_head);
+static rwlock_t destl_lock = RW_LOCK_UNLOCKED;
+
+static inline struct destl_entry *__kdymo_destl_find(u32 daddr)
+{
+	struct list_head *pos;
+	
+	list_for_each(pos, &destl_head)
+	{
+		struct destl_entry *e = (struct destl_entry *) pos;
+		
+		if (e->daddr == daddr)
+			return e;
+	}
+	
+	return NULL;
+}
+
+static inline void __kdymo_destl_flush(void)
+{
+	struct list_head *pos, *tmp;
+
+	list_for_each_safe(pos, tmp, &destl_head)
+	{
+		struct destl_entry *e = (struct destl_entry *) pos;
+		
+		list_del(&e->l);
+		destl_len--;
+		kfree(e);
+	}
+}
+
+static inline int __kdymo_destl_add(struct destl_entry *e)
+{
+	if (destl_len >= DESTL_MAX_LEN)
+	{
+		printk(KERN_WARNING "kdymo_destl: max list length reached\n");
+		return -ENOSPC;
+	}
+
+	list_add(&e->l, &destl_head);
+	
+	return 1;
+}
+
+static inline int __kdymo_destl_del(struct destl_entry *e)
+{
+	if (e == NULL)
+		return 0;
+
+	list_del(&e->l);
+
+	return 1;
+}
+
+int kdymo_destl_get(u32 daddr, struct destl_entry *entry)
+{
+	struct destl_entry *e;
+	int res = 0;
+	
+	read_lock_bh(&destl_lock);
+	
+	if ((e = __kdymo_destl_find(daddr)))
+	{
+		res = 1;
+		if (entry)
+			memcpy(entry, e, sizeof(struct destl_entry));
+	}
+	
+	read_unlock_bh(&destl_lock);
+	
+	return res;
+}
+
+void kdymo_destl_flush(void)
+{
+	write_lock_bh(&destl_lock);
+	
+	__kdymo_destl_flush();
+	
+	write_unlock_bh(&destl_lock);
+}
+
+int kdymo_destl_add(u32 daddr)
+{
+	struct destl_entry *e;
+	int status = 0;
+	
+	if (kdymo_destl_get(daddr, NULL))
+		return 0;
+	
+	if ((e = kmalloc(sizeof(struct destl_entry), GFP_ATOMIC)) == NULL)
+	{
+		printk(KERN_ERR "kdymo_destl: OOM in kdymo_destl_add\n");
+		return -ENOMEM;
+	}
+	e->daddr = daddr;
+	
+	write_lock_bh(&destl_lock);
+	
+	if ((status = __kdymo_destl_add(e)))
+		destl_len++;
+	
+	write_unlock_bh(&destl_lock);
+	
+	if (status < 0)
+		kfree(e);
+	
+	return status;
+}
+
+int kdymo_destl_del(u32 daddr)
+{
+	struct destl_entry *e;
+	int res;
+	
+	write_lock_bh(&destl_lock); 
+	
+	if ((e = __kdymo_destl_find(daddr)) == NULL)
+	{
+		res = 0;
+		goto unlock;
+	}
+	
+	if ((res = __kdymo_destl_del(e)))
+		kfree(e);
+	
+unlock:
+	write_unlock_bh(&destl_lock);
+	
+	return res;
+}
+
+void kdymo_destl_init(void)
+{
+	destl_len = 0;
+}
+
+void kdymo_destl_fini(void)
+{
+	kdymo_destl_flush();
+}
diff -Naur ns-2.35-orig/dymoum/lnx/kdymo_destl.h ns-2.35/dymoum/lnx/kdymo_destl.h
--- ns-2.35-orig/dymoum/lnx/kdymo_destl.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/lnx/kdymo_destl.h	2006-08-28 19:15:05.000000000 +0200
@@ -0,0 +1,57 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __KDYMO_DESTL_H__
+#define __KDYMO_DESTL_H__
+
+#ifdef __KERNEL__
+
+#include <linux/list.h>
+#include <linux/types.h>
+
+/* List of destination addresses for which we have a valid route */
+
+struct destl_entry
+{
+	struct list_head l;
+	u32 daddr;
+};
+
+/* Initialize the list */
+void kdymo_destl_init(void);
+
+/* Destroy the list */
+void kdymo_destl_fini(void);
+
+/* Remove all elements from the list */
+void kdymo_destl_flush(void);
+
+/* Find an entry with the given address, and copy it in 'entry' if succesful */
+int kdymo_destl_get(u32 daddr, struct destl_entry *entry);
+
+/* Add a new entry in the list */
+int kdymo_destl_add(u32 daddr);
+
+/* Remove an entry from the list */
+int kdymo_destl_del(u32 daddr);
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __KDYMO_DESTL_H__ */
diff -Naur ns-2.35-orig/dymoum/lnx/kdymo_main.c ns-2.35/dymoum/lnx/kdymo_main.c
--- ns-2.35-orig/dymoum/lnx/kdymo_main.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/lnx/kdymo_main.c	2006-08-28 19:15:05.000000000 +0200
@@ -0,0 +1,352 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#ifdef KERNEL26
+#include <linux/moduleparam.h>
+#endif	/* KERNEL26 */
+
+#include "kdymo_destl.h"
+#include "kdymo_queue.h"
+#include "kdymo_netlink.h"
+
+
+#define DYMO_PORT		653
+#define DYMO_MAX_NR_INTERFACES	4
+
+struct netdev_info
+{
+	u32	ip_addr;
+	u32	bc_addr;
+	int	ifindex;
+};
+
+static int nif;
+static struct netdev_info netdevs[DYMO_MAX_NR_INTERFACES];
+static char *ifnames[DYMO_MAX_NR_INTERFACES] = { "eth0" };
+
+unsigned long pkts_dropped	= 0;
+extern unsigned int queue_len;
+
+#ifdef KERNEL26
+static int num_parms = 0;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10))
+module_param_array(ifnames, charp, num_parms, 0444);
+#else
+module_param_array(ifnames, charp, &num_parms, 0444);
+#endif
+#else
+MODULE_PARM(ifnames, "1-" __MODULE_STRING(MAX_INTERFACES) "s");
+#endif
+
+static unsigned int kdymo_hook(unsigned int hooknum,
+				struct sk_buff **skb,
+				const struct net_device *in,
+				const struct net_device *out,
+				int (*okfn) (struct sk_buff *));
+
+/* These structs define which netfilter hooks we are interested in */
+static struct nf_hook_ops kdymo_ops[] = {
+{
+	.hook		= kdymo_hook,
+#ifdef KERNEL26
+	.owner		= THIS_MODULE,
+#endif	/* KERNEL26 */
+	.pf		= PF_INET,
+	.hooknum	= NF_IP_PRE_ROUTING,
+	.priority	= NF_IP_PRI_FIRST
+},
+{
+	.hook		= kdymo_hook,
+#ifdef KERNEL26
+	.owner		= THIS_MODULE,
+#endif	/* KERNEL26 */
+	.pf		= PF_INET,
+	.hooknum	= NF_IP_LOCAL_OUT,
+	.priority	= NF_IP_PRI_FIRST
+},
+{
+	.hook		= kdymo_hook,
+#ifdef KERNEL26
+	.owner		= THIS_MODULE,
+#endif	/* KERNEL26 */
+	.pf		= PF_INET,
+	.hooknum	= NF_IP_POST_ROUTING,
+	.priority	= NF_IP_PRI_FIRST
+}
+};
+
+/* Write information into a /proc file when it is read */
+int kdymo_proc_info(char *buffer, char **start, off_t offset, int length)
+{
+	int len;
+	
+	len	= sprintf(buffer,
+			"dropped pkts=%lu\nqueued pkts=%d\n",
+			pkts_dropped, queue_len);
+	*start	= buffer + offset;
+	len	-= offset;
+	
+	if (len > length)
+		len = length;
+	else if (len < 0)
+		len = 0;
+	
+	return len;
+}
+
+/* This function is called whenever a packet reaches one of the hooks we are
+   interested in */
+static unsigned int kdymo_hook(unsigned int hooknum,
+				struct sk_buff **skb,
+				const struct net_device *in,
+				const struct net_device *out,
+				int (*okfn) (struct sk_buff *))
+{
+	int i;
+	struct destl_entry e;
+	struct iphdr *iph = (*skb)->nh.iph;
+	
+	// If this is not an IP packet, let it go on
+	if (iph == NULL)
+		return NF_ACCEPT;
+	
+	// Broadcast and multicast packets are also accepted
+	if (iph->daddr == INADDR_BROADCAST || IN_MULTICAST(ntohl(iph->daddr)))
+		return NF_ACCEPT;
+	for (i = 0; i < nif; i++)
+		if (iph->daddr == netdevs[i].bc_addr)
+			return NF_ACCEPT;
+		
+	// We want DYMO packets to directly go through the corresponding socket
+	if (iph->protocol == IPPROTO_UDP)
+	{
+		struct udphdr *udph;
+		
+		udph = (struct udphdr *) ((char *) iph + (iph->ihl << 2));
+		
+		if (ntohs(udph->dest) == DYMO_PORT
+			|| ntohs(udph->source) == DYMO_PORT)
+			return NF_ACCEPT;
+	}
+	
+	switch (hooknum)
+	{
+		case NF_IP_PRE_ROUTING:	// a received packet
+		
+		if (!in)
+			break;
+		
+		// Check if the packet is bound to any enabled interface
+		for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+			if (netdevs[i].ifindex == in->ifindex)
+			{
+				// Update route to source
+				kdymo_netlink_send_rtmsg(KDYMO_ROUTE_UPDATE,
+					iph->saddr, in->ifindex);
+				
+				// Packets originated from or destined to this
+				// node are accepted
+				if (iph->saddr == netdevs[i].ip_addr ||
+					iph->daddr == netdevs[i].ip_addr)
+					return NF_ACCEPT;
+				
+				// Drop packets without a valid destination
+				// route
+				if (!kdymo_destl_get(iph->daddr, NULL))
+				{
+					kdymo_netlink_send_rtmsg(KDYMO_SEND_RERR,
+						iph->daddr, in->ifindex);
+					pkts_dropped++;
+					return NF_DROP;
+				}
+				
+				return NF_ACCEPT;
+			}
+		break;
+		
+		case NF_IP_LOCAL_OUT:	// a self-generated packet
+		
+		if (!out)
+			break;
+		
+		// Check if the packet is bound to any enabled interface
+		for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+			if (netdevs[i].ifindex == out->ifindex)
+			{
+				// If there is a suitable route, the packet is
+				// accepted. Otherwise it is buffered
+				if (!kdymo_destl_get(iph->daddr, &e))
+				{
+					if (!kdymo_queue_find(iph->daddr))
+						// start a route discovery
+						kdymo_netlink_send_rtmsg(
+							KDYMO_NOROUTE,
+							iph->daddr,
+							out->ifindex
+						);
+					kdymo_queue_enqueue(*skb, okfn);
+					
+					return NF_STOLEN;
+				}
+				
+				return NF_ACCEPT;
+			}
+		break;
+		
+		case NF_IP_POST_ROUTING:	// an outgoing packet
+		
+		if (!out)
+			break;
+		
+		// Check if the packet is bound to any enabled interface
+		for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+			if (netdevs[i].ifindex == out->ifindex)
+			{
+				// Update route to destination
+				kdymo_netlink_send_rtmsg(KDYMO_ROUTE_UPDATE,
+					iph->daddr, out->ifindex);
+			}
+		break;
+	}
+	
+	return NF_ACCEPT;
+}
+
+/* Init function: set up netlink sockets, register all needed hooks and
+   create a /proc element for DYMOUM */
+static int __init kdymo_init(void)
+{
+	int i, ret;
+	
+	struct in_device *indev;
+	struct net_device *dev	= NULL;
+	struct in_ifaddr **ifap	= NULL;
+	struct in_ifaddr *ifa	= NULL;
+	
+	kdymo_destl_init();
+	
+	ret = kdymo_queue_init();
+	if (ret < 0)
+		return ret;
+	
+	ret = kdymo_netlink_init();
+	if (ret < 0)
+		goto cleanup_queue;
+	
+	ret = nf_register_hook(&kdymo_ops[0]);
+	if (ret < 0)
+		goto cleanup_netlink;
+	
+	ret = nf_register_hook(&kdymo_ops[1]);
+	if (ret < 0)
+		goto cleanup_hook0;
+	
+	ret = nf_register_hook(&kdymo_ops[2]);
+	if (ret < 0)
+		goto cleanup_hook1;
+	
+	// Prefetch network device info
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+	{
+		if (!ifnames[i])
+			break;
+		
+		if ((dev = dev_get_by_name(ifnames[i])) == NULL)
+		{
+			printk("No device %s available\n", ifnames[i]);
+			continue;
+		}
+		
+		netdevs[nif].ifindex = dev->ifindex;
+		indev = in_dev_get(dev);
+		
+		if (indev)
+		{
+			for (ifap = &indev->ifa_list;
+				(ifa = *ifap) != NULL;
+				ifap = &ifa->ifa_next)
+			{
+				if (!strcmp(dev->name, ifa->ifa_label))
+					break;
+			}
+			
+			if (ifa)
+			{
+				netdevs[nif].ip_addr = ifa->ifa_address;
+				netdevs[nif].bc_addr = ifa->ifa_broadcast;
+			}
+		}
+		
+		nif++;
+		dev_put(dev);
+	}
+	
+	proc_net_create("kdymo", 0, kdymo_proc_info);
+	
+	return ret;
+	
+cleanup_hook1:
+	nf_unregister_hook(&kdymo_ops[1]);
+cleanup_hook0:
+	nf_unregister_hook(&kdymo_ops[0]);
+cleanup_netlink:
+	kdymo_netlink_fini();
+cleanup_queue:
+	kdymo_queue_fini();
+	
+	kdymo_destl_fini();
+
+	return ret;
+}
+
+/* Exit function: unregister all hooks, remove /proc info for DYMO and ends
+   netlink sockets operation */
+static void __exit kdymo_exit(void)
+{
+	nf_unregister_hook(&kdymo_ops[2]);
+	nf_unregister_hook(&kdymo_ops[1]);
+	nf_unregister_hook(&kdymo_ops[0]);
+	
+	proc_net_remove("kdymo");
+	
+	kdymo_netlink_fini();
+	kdymo_queue_fini();
+	kdymo_destl_fini();
+}
+
+module_init(kdymo_init);
+module_exit(kdymo_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Francisco J. Ros");
+MODULE_DESCRIPTION("DYMOUM kernel support");
diff -Naur ns-2.35-orig/dymoum/lnx/kdymo_netlink.c ns-2.35/dymoum/lnx/kdymo_netlink.c
--- ns-2.35-orig/dymoum/lnx/kdymo_netlink.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/lnx/kdymo_netlink.c	2006-08-28 19:15:05.000000000 +0200
@@ -0,0 +1,258 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+#include <linux/spinlock.h>
+#include <asm/semaphore.h>
+#include <net/sock.h>
+#ifdef KERNEL26
+#include <linux/security.h>
+#endif	/* KERNEL26 */
+
+#include "kdymo_netlink.h"
+#include "kdymo_queue.h"
+#include "kdymo_destl.h"
+
+// For 2.4 backwards compatibility
+#ifndef KERNEL26
+#define sk_receive_queue receive_queue 
+#define sk_socket socket
+#endif	/* KERNEL26 */
+
+// TODO: maybe peer_pid stuff is not needed, since all messages are bcasted
+
+extern unsigned long pkts_dropped;
+
+static int peer_pid;
+static struct sock *nl_sock;
+static DECLARE_MUTEX(nl_sem);
+
+static void kdymo_netlink_rcv_sk(struct sock *sk, int len);
+static inline void kdymo_netlink_rcv_skb(struct sk_buff *skb);
+static int kdymo_netlink_rcv_event(struct notifier_block *this,
+	unsigned long event, void *ptr);
+static int kdymo_netlink_rcv_peer(unsigned char type, void *msg,
+	unsigned int len);
+
+static struct notifier_block kdymo_nl_notifier = {
+	.notifier_call = kdymo_netlink_rcv_event,
+};
+
+/* Return a socket buffer containing the message 'm' (a kdymo_rtmsg in our
+   case) */
+static struct sk_buff *kdymo_netlink_create_msg(int type, void *m, int len)
+{
+	unsigned char *old_tail;
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	struct kdymo_rtmsg *msg;
+	size_t size = 0;
+	
+	size = NLMSG_SPACE(len);
+	
+	if ((skb = alloc_skb(size, GFP_ATOMIC)) == NULL)
+		goto nlmsg_failure;
+	
+	old_tail = skb->tail;
+	nlh = NLMSG_PUT(skb, 0, 0, type, size - sizeof(struct nlmsghdr));
+	msg = NLMSG_DATA(nlh);
+	
+	memcpy(msg, m, len);
+	nlh->nlmsg_len = skb->tail - old_tail;
+	
+	return skb;
+	
+nlmsg_failure:	// NLMSG_PUT makes me use this label
+	if (skb)
+		kfree_skb(skb);
+	
+	printk(KERN_ERR "kdymo: error creating netlink message\n");
+	return NULL;
+}
+
+void kdymo_netlink_send_rtmsg(int type, __u32 addr, int ifindex)
+{
+	struct sk_buff *skb;
+	struct kdymo_rtmsg msg;
+	
+	msg.addr	= addr;
+	msg.ifindex	= ifindex;
+	
+	skb = kdymo_netlink_create_msg(type, &msg, sizeof(struct kdymo_rtmsg));
+	if (skb == NULL)
+		return;
+	
+	if (netlink_broadcast(nl_sock, skb, 0, DYMOGRP_NOTIFY, GFP_USER) < 0)
+		printk("could not send netlink bcast msg, type = %d\n", type);
+}
+
+int kdymo_netlink_init(void)
+{
+	netlink_register_notifier(&kdymo_nl_notifier);
+	
+	nl_sock = netlink_kernel_create(NETLINK_DYMO, kdymo_netlink_rcv_sk);
+	if (nl_sock == NULL)
+	{
+		printk(KERN_ERR "failed to create netlink socket");
+		netlink_unregister_notifier(&kdymo_nl_notifier);
+		return -1;
+	}
+	
+	return 1;
+}
+
+void kdymo_netlink_fini(void)
+{
+	sock_release(nl_sock->sk_socket);
+	
+	down(&nl_sem);
+	up(&nl_sem);
+	
+	netlink_unregister_notifier(&kdymo_nl_notifier);
+}
+
+static int kdymo_netlink_rcv_event(struct notifier_block *this,
+	unsigned long event, void *ptr)
+{
+	struct netlink_notify *n = ptr;
+	
+	if (event == NETLINK_URELEASE &&
+		n->protocol == NETLINK_DYMO && n->pid)
+	{
+		if (n->pid == peer_pid)
+		{
+			peer_pid = 0;
+			kdymo_destl_flush();
+			kdymo_queue_flush();
+		}
+		
+		return NOTIFY_DONE;
+	}
+	
+	return NOTIFY_DONE;
+}
+
+static void kdymo_netlink_rcv_sk(struct sock *sk, int len)
+{
+	do
+	{
+		struct sk_buff *skb;
+		
+		if (down_trylock(&nl_sem))
+			return;
+		
+		while ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL)
+		{
+			kdymo_netlink_rcv_skb(skb);
+			kfree_skb(skb);
+		}
+		
+		up(&nl_sem);
+	} while (nl_sock && nl_sock->sk_receive_queue.qlen);
+	
+	return;
+}
+
+#define RCV_SKB_FAIL(err) do {netlink_ack(skb, nlh, (err)); return;} while (0)
+static inline void kdymo_netlink_rcv_skb(struct sk_buff *skb)
+{
+	int status, type, pid, flags, nlmsglen, skblen;
+	struct nlmsghdr *nlh;
+	
+	if ((skblen = skb->len) < sizeof(struct nlmsghdr))
+	{
+	    printk("skblen too small\n");
+	    return;
+	}
+	
+	nlh		= (struct nlmsghdr *) skb->data;
+	nlmsglen	= nlh->nlmsg_len;
+	if (nlmsglen < sizeof(*nlh) || skblen < nlmsglen)
+	{
+		printk("nlsmsg=%d skblen=%d too small\n", nlmsglen, skblen);
+		return;
+	}
+	
+	pid	= nlh->nlmsg_pid;
+	flags	= nlh->nlmsg_flags;
+	if (pid <= 0 || !(flags & NLM_F_REQUEST) || flags & NLM_F_MULTI)
+		RCV_SKB_FAIL(-EINVAL);
+	if (flags & MSG_TRUNC)
+		RCV_SKB_FAIL(-ECOMM);
+	
+	type = nlh->nlmsg_type;
+
+#ifdef KERNEL26
+	if (security_netlink_recv(skb))
+		RCV_SKB_FAIL(-EPERM);
+#endif	/* KERNEL26 */
+	
+	if (peer_pid)
+	{
+		if (peer_pid != pid)
+			RCV_SKB_FAIL(-EBUSY);
+	}
+	else
+		peer_pid = pid;
+	
+	status = kdymo_netlink_rcv_peer(type, NLMSG_DATA(nlh),
+		skblen - NLMSG_LENGTH(0));
+	if (status < 0)
+		RCV_SKB_FAIL(status);
+	
+	if (flags & NLM_F_ACK)
+		netlink_ack(skb, nlh, 0);
+}
+
+/* Process messages coming from user space */
+static int kdymo_netlink_rcv_peer(unsigned char type, void *msg,
+	unsigned int len)
+{
+	int status = 0;
+	struct kdymo_rtmsg *rtm = (struct kdymo_rtmsg *) msg;
+	
+	if (len < sizeof(*msg))
+		return -EINVAL;
+	
+	switch (type)
+	{
+		case KDYMO_ADDROUTE:
+			kdymo_destl_add(rtm->addr);
+			kdymo_queue_set_verdict(KDYMO_QUEUE_SEND, rtm->addr);
+			break;
+			
+		case KDYMO_DELROUTE:  
+			kdymo_destl_del(rtm->addr);
+			pkts_dropped +=
+				kdymo_queue_set_verdict(KDYMO_QUEUE_DROP, rtm->addr);
+			break;
+			
+		case KDYMO_NOROUTE_FOUND:
+			pkts_dropped +=
+				kdymo_queue_set_verdict(KDYMO_QUEUE_DROP, rtm->addr);
+			break;
+		
+		default:
+			status = -EINVAL;
+	}
+	
+	return status;
+}
diff -Naur ns-2.35-orig/dymoum/lnx/kdymo_netlink.h ns-2.35/dymoum/lnx/kdymo_netlink.h
--- ns-2.35-orig/dymoum/lnx/kdymo_netlink.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/lnx/kdymo_netlink.h	2006-08-28 19:15:05.000000000 +0200
@@ -0,0 +1,60 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __KDYMO_NETLINK_H__
+#define __KDYMO_NETLINK_H__
+
+#include <linux/types.h>
+
+/* 12 was free last time I checked <linux/netlink.h> */
+#define NETLINK_DYMO	12
+#define DYMOGRP_NOTIFY	1
+
+#define KDYMO_BASE		0x00
+#define KDYMO_ADDROUTE		(KDYMO_BASE +1)
+#define KDYMO_DELROUTE		(KDYMO_BASE +2)
+#define KDYMO_NOROUTE_FOUND	(KDYMO_BASE +3)
+#define KDYMO_NOROUTE		(KDYMO_BASE +4)
+#define KDYMO_ROUTE_UPDATE	(KDYMO_BASE +5)
+#define KDYMO_SEND_RERR		(KDYMO_BASE +6)
+
+struct kdymo_rtmsg
+{
+	__u32	addr;
+	int	ifindex;
+};
+
+#ifdef __KERNEL__
+
+/* Implementation of the communication from kernel space to user space via
+   netlink sockets */
+
+/* Set up netlink socket */
+int kdymo_netlink_init(void);
+
+/* Close netlink socket */
+void kdymo_netlink_fini(void);
+
+/* Send a message to user space */
+void kdymo_netlink_send_rtmsg(int type, __u32 addr, int ifindex);
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __KDYMO_NETLINK_H__ */
diff -Naur ns-2.35-orig/dymoum/lnx/kdymo_queue.c ns-2.35/dymoum/lnx/kdymo_queue.c
--- ns-2.35-orig/dymoum/lnx/kdymo_queue.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/lnx/kdymo_queue.c	2006-08-28 19:15:05.000000000 +0200
@@ -0,0 +1,236 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/* This code has been taken from AODVUU, which in turn was taken from linux
+   kernel implementation. I use it in order to buffer all IP packets which
+   a route discovery is being performed for */
+
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/ip.h>
+#include <linux/netfilter_ipv4.h>
+#include <net/icmp.h>
+
+#include "kdymo_queue.h"
+#include "kdymo_destl.h"
+
+
+#define KDYMO_QUEUE_MAX_LEN	1024
+
+struct kdymo_queue_entry
+{
+	struct list_head	l;
+	u32			daddr;
+	struct sk_buff		*skb;
+	int (*okfn)(struct sk_buff *);
+};
+
+typedef int (*kdymo_queue_cmpfn) (struct kdymo_queue_entry *, u32);
+
+static rwlock_t queue_lock = RW_LOCK_UNLOCKED;
+unsigned int queue_len;
+static LIST_HEAD(queue_head);
+
+static inline int dest_cmp(struct kdymo_queue_entry *e, u32 daddr)
+{
+	return (daddr == e->daddr);
+}
+
+static inline struct kdymo_queue_entry *__kdymo_queue_find(kdymo_queue_cmpfn cmpfn, u32 daddr)
+{
+	struct list_head *pos;
+		
+	list_for_each_prev(pos, &queue_head)
+	{
+		struct kdymo_queue_entry *entry = (struct kdymo_queue_entry *) pos;
+		
+		if (!cmpfn || cmpfn(entry, daddr))
+			return entry;
+	}
+	
+	return NULL;
+}
+
+static inline int __kdymo_queue_enqueue(struct kdymo_queue_entry *entry)
+{
+	if (queue_len >= KDYMO_QUEUE_MAX_LEN)
+	{
+		if (net_ratelimit())
+			printk(KERN_WARNING "kdymo_queue: full at %d entries, "
+				"dropping packet(s).\n", queue_len);
+		return -ENOSPC;
+	}
+	
+	list_add(&entry->l, &queue_head);
+	queue_len++;
+	
+	return 0;
+}
+
+static inline struct kdymo_queue_entry *__kdymo_queue_dequeue(kdymo_queue_cmpfn cmpfn, u32 daddr)
+{
+	struct kdymo_queue_entry *entry;
+	
+	if ((entry = __kdymo_queue_find(cmpfn, daddr)) == NULL)
+		return NULL;
+	
+	list_del(&entry->l);
+	queue_len--;
+	
+	return entry;
+}
+
+static inline void __kdymo_queue_flush(void)
+{
+	struct kdymo_queue_entry *entry;
+		
+	while ((entry = __kdymo_queue_dequeue(NULL, 0)))
+	{
+		kfree_skb(entry->skb);
+		kfree(entry);
+	}
+}
+
+int kdymo_queue_enqueue(struct sk_buff *skb, int (*okfn)(struct sk_buff *))
+{
+	int status;
+	struct kdymo_queue_entry *entry;
+	struct iphdr *iph = skb->nh.iph;
+	
+	if ((entry = kmalloc(sizeof(struct kdymo_queue_entry), GFP_ATOMIC))
+		== NULL)
+	{
+		printk(KERN_ERR "kdymo_queue: OOM in kdymo_queue_enqueue()\n");
+		return -ENOMEM;
+	}
+	
+	entry->daddr	= iph->daddr;
+	entry->skb	= skb;
+	entry->okfn	= okfn;
+	
+	write_lock_bh(&queue_lock);
+	if ((status = __kdymo_queue_enqueue(entry)) < 0)
+		goto unlock;
+	write_unlock_bh(&queue_lock);
+	
+	return status;
+	
+unlock:
+	write_unlock_bh(&queue_lock);
+	kfree(entry);
+	
+	return status;
+}
+
+static struct kdymo_queue_entry *kdymo_queue_dequeue(kdymo_queue_cmpfn cmpfn, u32 daddr)
+{
+	struct kdymo_queue_entry *entry;
+	
+	write_lock_bh(&queue_lock);
+	entry = __kdymo_queue_dequeue(cmpfn, daddr);
+	write_unlock_bh(&queue_lock);
+	
+	return entry;
+}
+
+void kdymo_queue_flush(void)
+{
+	write_lock_bh(&queue_lock);
+	__kdymo_queue_flush();
+	write_unlock_bh(&queue_lock);
+}
+
+int kdymo_queue_find(u32 daddr)
+{
+	struct kdymo_queue_entry *entry;
+	int res = 0;
+	
+	read_lock_bh(&queue_lock);
+	
+	if ((entry = __kdymo_queue_find(dest_cmp, daddr)) != NULL)
+		res = 1;
+	
+	read_unlock_bh(&queue_lock);
+	
+	return res;    
+}
+
+int kdymo_queue_set_verdict(int verdict, u32 daddr)
+{
+	struct kdymo_queue_entry *entry;
+	int pkts = 0;
+	
+	if (verdict == KDYMO_QUEUE_DROP)
+	{
+		while (1)
+		{
+			if ((entry = kdymo_queue_dequeue(dest_cmp, daddr))
+				== NULL)
+				return pkts;
+			
+			// Send an ICMP message informing the application that
+			// the destination was unreachable
+			if (pkts == 0)
+				icmp_send(entry->skb, ICMP_DEST_UNREACH,
+					ICMP_HOST_UNREACH, 0);
+			
+			kfree_skb(entry->skb);
+			kfree(entry);
+			pkts++;
+		}
+	}
+	else if (verdict == KDYMO_QUEUE_SEND)
+	{
+		struct destl_entry e;
+		
+		while (1)
+		{
+			if ((entry = kdymo_queue_dequeue(dest_cmp, daddr))
+				== NULL)
+				return pkts;
+			
+			if (!kdymo_destl_get(daddr, &e))
+				return -1;
+			ip_route_me_harder(&entry->skb);
+			
+			// Reinject packet
+			entry->okfn(entry->skb);
+			kfree(entry);
+			pkts++;
+		}
+	}
+	
+	return 0;
+}
+
+int kdymo_queue_init(void)
+{
+	queue_len = 0;
+	return 1;
+}
+
+void kdymo_queue_fini(void)
+{
+#ifdef KERNEL26
+	synchronize_net();
+#endif	/* KERNEL26 */
+	kdymo_queue_flush();
+}
diff -Naur ns-2.35-orig/dymoum/lnx/kdymo_queue.h ns-2.35/dymoum/lnx/kdymo_queue.h
--- ns-2.35-orig/dymoum/lnx/kdymo_queue.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/lnx/kdymo_queue.h	2006-08-28 19:15:05.000000000 +0200
@@ -0,0 +1,56 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __KDYMO_QUEUE_H__
+#define __KDYMO_QUEUE_H__
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <linux/skbuff.h>
+
+/* Queue of packets which are waiting for the completion of a route
+   discovery */
+
+#define KDYMO_QUEUE_DROP	1
+#define KDYMO_QUEUE_SEND	2
+
+/* Initialize the queue */
+int kdymo_queue_init(void);
+
+/* Destroy the queue */
+void kdymo_queue_fini(void);
+
+/* Remove all elements from the queue */
+void kdymo_queue_flush(void);
+
+/* Check whether there is a packet with the given destination address */
+int kdymo_queue_find(u32 daddr);
+
+/* Enqueue a packet contained in the given socket buffer */
+int kdymo_queue_enqueue(struct sk_buff *skb, int (*okfn)(struct sk_buff *));
+
+/* Set the verdict for the given destination address. Packets destined to that
+   address are sent or dropped depending on the verdict */
+int kdymo_queue_set_verdict(int verdict, u32 daddr);
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __KDYMO_QUEUE_H__ */
diff -Naur ns-2.35-orig/dymoum/lnx/Makefile ns-2.35/dymoum/lnx/Makefile
--- ns-2.35-orig/dymoum/lnx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/lnx/Makefile	2006-08-30 19:30:29.000000000 +0200
@@ -0,0 +1,46 @@
+ifneq (,$(findstring 2.6,$(KERNELRELEASE)))
+EXTRA_CFLAGS += -D KERNEL26
+obj-m += kdymo.o
+kdymo-objs := kdymo_main.o kdymo_netlink.o kdymo_queue.o kdymo_destl.o
+else
+
+KOBJS := kdymo_main.o kdymo_netlink.o kdymo_queue.o kdymo_destl.o
+
+KERNEL=$(shell uname -r)
+KERNEL_DIR=/lib/modules/$(KERNEL)/build
+KERNEL_INC=$(KERNEL_DIR)/include
+
+KCC=gcc
+LD=ld
+
+VERSION=$(shell if [ ! -d $(KERNEL_DIR) ]; then echo "No linux source found!!! Check your setup..."; exit; fi; grep ^VERSION $(KERNEL_DIR)/Makefile | cut -d' ' -f 3)
+PATCHLEVEL=$(shell grep ^PATCHLEVEL $(KERNEL_DIR)/Makefile | cut -d' ' -f 3)
+SUBLEVEL=$(shell grep ^SUBLEVEL $(KERNEL_DIR)/Makefile | cut -d' ' -f 3)
+
+KINC=-nostdinc -DMODVERSIONS -include $(KERNEL_INC)/linux/modversions.h $(shell $(CC) -print-search-dirs | sed -ne 's/install: \(.*\)/-I \1include/gp') -I$(KERNEL_INC)
+KDEFS=-D__KERNEL__ -DMODULE
+KCFLAGS=-Wall -Wno-strict-aliasing -O2 $(KDEFS) $(KINC)
+
+.PHONY: clean
+
+ifeq ($(PATCHLEVEL),6)
+default: kdymo.ko
+else 
+default: kdymo.o
+endif
+
+$(KOBJS): %.o: %.c Makefile
+	$(KCC) $(KCFLAGS) -c -o $@ $<
+
+kdymo.o: $(KOBJS) Makefile
+	$(LD) -r $(KOBJS) -o $@
+	cp $@ ../
+
+kdymo.ko: $(KOBJS:%.o=%.c) Makefile
+	$(MAKE) -C $(KERNEL_DIR) SUBDIRS=$(PWD)/lnx modules
+	cp $@ ../
+
+clean:
+	rm -rf *.o *.ko *.mod.* *~ *.o.cmd
+
+endif
diff -Naur ns-2.35-orig/dymoum/main.c ns-2.35/dymoum/main.c
--- ns-2.35-orig/dymoum/main.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/main.c	2006-08-31 17:34:23.000000000 +0200
@@ -0,0 +1,472 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "defs.h"
+#include "debug.h"
+#include "rtable.h"
+#include "timer_queue.h"
+#include "dymo_socket.h"
+#include "icmp_socket.h"
+#include "dymo_netlink.h"
+#include "dymo_hello.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/select.h>
+#include <net/if.h>
+
+
+#define MAX_CALLBACKS 9
+
+static struct callback
+{
+	int		fd;
+	callback_func_t	func;
+} callbacks[MAX_CALLBACKS];
+
+static int num_callbacks = 0;
+
+char *progname		= NULL;
+int debug		= 0;
+int daemonize		= 0;
+int no_path_acc		= 0;
+int reissue_rreq	= 0;
+int s_bit		= 0;
+int hello_ival		= 0;
+
+
+struct option longopts[] = {
+	{"interface", required_argument, NULL, 'i'},
+	{"debug", no_argument, NULL, 'v'},
+	{"daemon", no_argument, NULL, 'd'},
+	{"no_path_acc", no_argument, NULL, 'n'},
+	{"reissue_rreq", no_argument, NULL, 'r'},
+	{"s_bit", no_argument, NULL, 's'},
+	{"hello", required_argument, NULL, 'm'},
+	{"help", no_argument, NULL, 'h'},
+	{"version", no_argument, NULL, 'V'},
+	{0}
+};
+
+
+void usage()
+{
+	fprintf(stdout,
+		"\nUsage: %s [-vdnrshV] [-m <ival>] -i <if0,if1,...>\n\n"
+		"-v, --debug           Verbose output (for debugging purposes).\n"
+		"-d, --daemon          Daemon mode.\n"
+		"-n, --no_path_acc     Do not perform path accumulation.\n"
+		"-r, --reissue_rreq    Retry a route discovery when a previous one did not success.\n"
+		"-s, --s_bit           Set S-bit on RREPs to avoid unidirectional links.\n"
+		"-m, --hello           Monitor link status with periodic HELLO messages every <ival> sec.\n"
+		"-h, --help            Show this help and exit.\n"
+		"-V, --version         Show version.\n\n"
+		"Francisco J. Ros, <fjrm@dif.um.es>\n\n", progname);
+}
+
+int set_kernel_options()
+{
+	int i, fd;
+	char command[64];
+	char on		= '1';
+	char off	= '0';
+	
+	// Enable IP forwarding
+	if ((fd = open("/proc/sys/net/ipv4/ip_forward", O_WRONLY)) < 0)
+		return -1;
+	if (write(fd, &on, sizeof(char)) < 0)
+		return -1;
+	close(fd);
+	
+	// Deactivate route cache
+	if ((fd = open("/proc/sys/net/ipv4/route/max_delay", O_WRONLY)) < 0)
+		return -1;
+	if (write(fd, &off, sizeof(char)) < 0)
+		return -1;
+	close(fd);
+	
+	// Deactivate route cache
+	if ((fd = open("/proc/sys/net/ipv4/route/min_delay", O_WRONLY)) < 0)
+		return -1;
+	if (write(fd, &off, sizeof(char)) < 0)
+		return -1;
+	close(fd);
+	
+	// AODVUU disables ICMP redirects on all interfaces. I guess that this
+	// may be also useful for DYMOUM in some scenarios, but I haven't
+	// thought very much about this. I leave this code here...
+	for (i = 0; i < DYMO_MAX_NR_INTERFACES; i++)
+	{
+		if (!DEV_NR(i).enabled)
+			continue;
+		
+		memset(command, '\0', 64);
+		sprintf(command, "/proc/sys/net/ipv4/conf/%s/send_redirects",
+			DEV_NR(i).ifname);
+		if ((fd = open(command, O_WRONLY)) < 0)
+			return -1;
+		if (write(fd, &off, sizeof(char)) < 0)
+			return -1;
+		close(fd);
+		
+		memset(command, '\0', 64);
+		sprintf(command, "/proc/sys/net/ipv4/conf/%s/accept_redirects",
+			DEV_NR(i).ifname);
+		if ((fd = open(command, O_WRONLY)) < 0)
+			return -1;
+		if (write(fd, &off, sizeof(char)) < 0)
+			return -1;
+		close(fd);
+	}
+	memset(command, '\0', 64);
+	sprintf(command, "/proc/sys/net/ipv4/conf/all/send_redirects");
+	if ((fd = open(command, O_WRONLY)) < 0)
+		return -1;
+	if (write(fd, &off, sizeof(char)) < 0)
+		return -1;
+	close(fd);
+	
+	return 0;
+}
+
+int attach_callback_func(int fd, callback_func_t func)
+{
+	if (num_callbacks >= MAX_CALLBACKS)
+		return -1;
+	
+	callbacks[num_callbacks].fd	= fd;
+	callbacks[num_callbacks].func	= func;
+	num_callbacks++;
+	
+	return 0;
+}
+
+void signal_handler(int type)
+{
+	switch (type)
+	{
+		case SIGSEGV:
+			dlog(LOG_ERR, 0, __FUNCTION__, "segmentation fault signal received");
+			exit(EXIT_FAILURE);
+			break;
+		default:
+			exit(EXIT_SUCCESS);
+	}
+}
+
+void get_if_info(struct ifreq *ifreq, char *ifname, int type)
+{
+	int sock;
+	
+	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__,
+			"could not open a socket to obtain interfaces information");
+		exit(EXIT_FAILURE);
+	}
+	
+	memset(ifreq, 0, sizeof(struct ifreq));
+	strncpy(ifreq->ifr_name, ifname, IFNAMSIZ * sizeof(char));
+	if (ioctl(sock, type, ifreq) < 0)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__,
+			"could not get interface information for %s",
+			ifname);
+		close(sock);
+		exit(EXIT_FAILURE);
+	}
+	
+	close(sock);
+}
+
+void load_modules(char *ifnames)
+{
+	struct stat st;
+	char buf[1024], *l = NULL;
+	int found = 0;
+	FILE *m;
+	
+	memset(buf, '\0', 64);
+	
+	if (stat("./kdymo.ko", &st) == 0)
+		sprintf(buf, "/sbin/insmod kdymo.ko ifnames=%s &>/dev/null", ifnames);
+	else if (stat("./kdymo.o", &st) == 0)
+		sprintf(buf, "/sbin/insmod kdymo.o ifnames=%s &>/dev/null", ifnames);
+	else
+		sprintf(buf, "/sbin/modprobe kdymo ifnames=%s &>/dev/null", ifnames);
+	
+	system(buf);
+	
+	usleep(100000);
+	
+	/* Check result */
+	m = fopen("/proc/modules", "r");
+	while (fgets(buf, sizeof(buf), m))
+	{
+		l = strtok(buf, " \t");
+		if (!strcmp(l, "kdymo"))
+			found++;
+	}
+	fclose(m);
+	
+	if (found < 1)
+	{
+		fprintf(stderr, "A kernel module could not be loaded, "
+			"check your installation... %d\n", found);
+		exit(EXIT_FAILURE);
+	}
+}
+
+void remove_modules(void)
+{
+    system("/sbin/rmmod kdymo &>/dev/null");
+}
+
+void host_init(char *ifnames)
+{
+	char *ifname, ifnames_aux[(IFNAMSIZ + 1) * DYMO_MAX_NR_INTERFACES];
+	struct ifreq ifreq;
+	
+	if (!ifnames)
+	{
+		usage();
+		exit(EXIT_SUCCESS);
+	}
+	
+	memset(&this_host, 0, sizeof(struct host_info));
+	memset(dev_indices, 0, DYMO_MAX_NR_INTERFACES * sizeof(u_int32_t));
+	
+	// Initialize this_host
+	this_host.nif		= 0;
+	this_host.seqnum	= 1;
+	this_host.prefix	= 0;
+	this_host.is_gw		= 0;
+	
+	// Get interfaces information
+	strncpy(ifnames_aux, ifnames, sizeof(ifnames_aux));
+	ifname = strtok(ifnames_aux, ",");
+	do
+	{
+		u_int32_t ifindex;
+		
+		// Get interface index
+		get_if_info(&ifreq, ifname, SIOCGIFINDEX);
+		ifindex = ifreq.ifr_ifindex;
+		this_host.devs[this_host.nif].ifindex	= ifindex;
+		dev_indices[this_host.nif]		= ifindex;
+		this_host.nif++;
+		
+		// Copy interface name
+		strncpy(DEV_IFINDEX(ifindex).ifname, ifname,
+			IFNAMSIZ * sizeof(char));
+		
+		// Get IP address
+		get_if_info(&ifreq, ifname, SIOCGIFADDR);
+		DEV_IFINDEX(ifindex).ipaddr.s_addr =
+			((struct sockaddr_in *) &ifreq.ifr_addr)->sin_addr.s_addr;
+		
+		// Get broadcast address
+		get_if_info(&ifreq, ifname, SIOCGIFBRDADDR);
+		DEV_IFINDEX(ifindex).bcast.s_addr =
+			((struct sockaddr_in *) &ifreq.ifr_broadaddr)->sin_addr.s_addr;
+		
+		// Enable interface
+		DEV_IFINDEX(ifindex).enabled = 1;
+		
+		if (this_host.nif >= DYMO_MAX_NR_INTERFACES)
+			break;
+	} while ((ifname = strtok(NULL, ",")) != NULL);
+	
+	// Load kernel modules
+	load_modules(ifnames_aux);
+	
+	// Set appropriate kernel options
+	if (set_kernel_options() < 0)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "could not set kernel options");
+		exit(EXIT_FAILURE);
+	}
+}
+
+void host_fini(void)
+{
+	remove_modules();
+	rtable_destroy();
+	netlink_fini();
+	dymo_socket_fini();
+	icmp_socket_fini();
+	hello_fini();
+	dlog_fini();
+}
+
+/* Main loop */
+int main(int argc, char *argv[])
+{
+	struct timeval *timeout;
+	char *ifnames = NULL;
+	fd_set readers, rfds;
+	int i, n, nfds = 0;
+	
+	progname = argv[0];
+	
+	// Get command line options
+	while (1)
+	{
+		int opt;
+		
+		opt = getopt_long(argc, argv, "i:vdnrm:shV", longopts, 0);
+		if (opt == -1)
+			break;
+		
+		switch (opt)
+		{
+			case 'i':
+				ifnames = optarg;
+				break;
+			
+			case 'v':
+				debug = 1;
+				break;
+				
+			case 'd':
+				daemonize = 1;
+				break;
+			
+			case 'n':
+				no_path_acc = 1;
+				break;
+			
+			case 'r':
+				reissue_rreq = 1;
+				break;
+			
+			case 's':
+				s_bit = 1;
+				break;
+			
+			case 'm':
+				hello_ival = atoi(optarg);
+				break;
+			
+			case 'h':
+				usage();
+				exit(EXIT_SUCCESS);
+				break;
+			case 'V':
+				fprintf(stdout, "\nDYMOUM v%s, %s - University of Murcia (Spain)\n"
+					"Francisco J. Ros <fjrm@dif.um.es>\n\n",
+					DYMO_UM_VERSION,
+					DYMO_DRAFT_VERSION);
+				exit(EXIT_SUCCESS);
+				break;
+			
+			case '?':
+			case ':':
+			default:
+				usage();
+				exit(EXIT_SUCCESS);
+				break;
+		}
+	}
+	
+	// Check we are root
+	if (geteuid() != 0)
+	{
+		fprintf(stderr, "You must be root\n");
+		exit(EXIT_FAILURE);
+	}
+	
+	// Daemonize
+	if (daemonize)
+	{
+		// Create a child process, parent dies
+		if (fork() != 0)
+			exit(EXIT_SUCCESS);
+		
+		// Close stdin, stdout and stderr
+		close(0);
+		close(1);
+		close(2);
+		
+		// Process is a group leader
+		setsid();
+	}
+	
+	// Make a clean exit
+	atexit(host_fini);
+	
+	// Initialize data structures and services
+	rtable_init();
+	dlog_init();
+	host_init(ifnames);
+	netlink_init();
+	dymo_socket_init();
+	icmp_socket_init();
+	hello_init();
+	
+	// Catch signals
+	signal(SIGHUP, signal_handler);
+	signal(SIGINT, signal_handler);
+	signal(SIGTERM, signal_handler);
+	//signal(SIGSEGV, signal_handler);
+	
+	FD_ZERO(&readers);
+	for (i = 0; i < num_callbacks; i++)
+	{
+		FD_SET(callbacks[i].fd, &readers);
+		if (callbacks[i].fd >= nfds)
+			nfds = callbacks[i].fd + 1;
+	}
+	
+	// Main loop
+	while (1)
+	{
+		memcpy((char *) &rfds, (char *) &readers, sizeof(rfds));
+		
+		timeout = timer_age_queue();
+		
+		if ((n = select(nfds, &rfds, NULL, NULL, timeout)) < 0)
+		{
+			if (errno != EINTR)
+				dlog(LOG_WARNING, errno, __FUNCTION__, "failed select() in main loop");
+			continue;
+		}
+		
+		if (n > 0)
+		{
+			for (i = 0; i < num_callbacks; i++)
+				if (FD_ISSET(callbacks[i].fd, &rfds))
+					callbacks[i].func(callbacks[i].fd);
+		}
+	}
+	
+	return 0;
+}
diff -Naur ns-2.35-orig/dymoum/Makefile ns-2.35/dymoum/Makefile
--- ns-2.35-orig/dymoum/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/Makefile	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,93 @@
+# Source files
+SRC = debug.c dymo_generic.c dymo_netlink.c dymo_re.c dymo_socket.c \
+      dymo_timeout.c dymo_uerr.c dymo_rerr.c k_route.c rtable.c \
+      timer_queue.c main.c pending_rreq.c icmp_socket.c blacklist.c \
+      dymo_nb.c dymo_hello.c
+
+SRC_NS = debug.c dymo_generic.c dymo_re.c dymo_socket.c dymo_timeout.c \
+         dymo_uerr.c dymo_rerr.c rtable.c timer_queue.c pending_rreq.c \
+         icmp_socket.c blacklist.c dymo_nb.c dymo_hello.c
+
+SRC_NS_CPP = ns/dymo_um.cc ns/packet_queue.cc
+
+# Object files
+OBJS = $(SRC:%.c=%.o)
+OBJS_NS = $(SRC_NS:%.c=%-ns.o)
+OBJS_NS_CPP = $(SRC_NS_CPP:%.cc=%-ns.o)
+
+# Kernel stuff
+KERNEL=$(shell uname -r)
+KERNEL_DIR=/lib/modules/$(KERNEL)/build
+KERNEL_INC=$(KERNEL_DIR)/include
+
+# Compiler options
+CC= gcc
+CPP= g++
+C_OPTS= -Wall -O3
+CPP_OPTS= -Wall
+
+export CC
+
+DEBUG= -g -O0 -DDEBUG
+DEFS=
+LD_OPTS=
+CFLAGS= $(C_OPTS) $(DEBUG) $(DEFS)
+
+NS_DEFS= # DON'T CHANGE (overridden by NS Makefile)
+NS_CFLAGS=$(OPTS) $(CPP_OPTS) $(DEBUG) $(NS_DEFS)
+NS_INC= # DON'T CHANGE (overridden by NS Makefile)
+NS_TARGET=libdymoum.a
+
+# Archiver and options
+AR=ar
+AR_FLAGS=rc
+
+.PHONY: default clean install uninstall depend kdymo
+
+# Targets
+default: dymod kdymo
+
+$(OBJS): %.o: %.c Makefile
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+$(OBJS_NS): %-ns.o: %.c Makefile
+	$(CPP) $(NS_CFLAGS) $(NS_INC) -c -o $@ $<
+
+$(OBJS_NS_CPP): %-ns.o: %.cc Makefile
+	$(CPP) $(NS_CFLAGS) $(NS_INC) -c -o $@ $<
+
+$(NS_TARGET): $(OBJS_NS_CPP) $(OBJS_NS)
+	$(AR) $(AR_FLAGS) $@ $(OBJS_NS_CPP) $(OBJS_NS) > /dev/null
+
+dymod: $(OBJS) Makefile
+	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LD_OPTS)
+
+kdymo:
+	$(MAKE) -C lnx KERNEL_DIR=$(KERNEL_DIR) KCC=$(CC)
+
+depend:
+	@echo "Updating Makefile dependencies..."
+	@makedepend -Y./ -- $(DEFS) -- $(SRC) &>/dev/null
+	@makedepend -a -Y./ -- $(KDEFS) kdymo.c &>/dev/null
+
+install: default
+	install -s -m 755 dymod /usr/sbin/dymod
+	
+	@if [ ! -d /lib/modules/$(KERNEL)/dymo ]; then \
+		mkdir /lib/modules/$(KERNEL)/dymo; \
+	fi
+	@echo "Installing kernel module in /lib/modules/$(KERNEL)/dymo/";
+	@if [ -f ./kdymo.ko ]; then \
+		install -m 644 kdymo.ko /lib/modules/$(KERNEL)/dymo/kdymo.ko; \
+	else \
+		install -m 644 kdymo.o /lib/modules/$(KERNEL)/dymo/kdymo.o; \
+	fi
+	/sbin/depmod -a
+
+uninstall:
+	rm -f /usr/sbin/dymod
+	rm -rf /lib/modules/$(KERNEL)/dymo
+
+clean:
+	rm -f dymod *~ *.o *.ko core *.log $(NS_TARGET) ns/*.o ns/*~
+	cd lnx && $(MAKE) clean
diff -Naur ns-2.35-orig/dymoum/ns/dymo_um.cc ns-2.35/dymoum/ns/dymo_um.cc
--- ns-2.35-orig/dymoum/ns/dymo_um.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/dymo_um.cc	2006-08-29 19:51:44.000000000 +0200
@@ -0,0 +1,355 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "dymo_um.h"
+
+#include <assert.h>
+#include <string.h>
+
+static void
+dymoum_mac_failed_callback(Packet *p, void *arg) {
+	((DYMOUM *) arg)->mac_failed(p);
+}
+
+int hdr_dymoum::offset_;
+static class DYMOUMHeaderClass : public PacketHeaderClass {
+public:
+	DYMOUMHeaderClass() : PacketHeaderClass("PacketHeader/DYMOUM",
+						DYMO_MSG_MAX_SIZE) {
+		bind_offset(&hdr_dymoum::offset_);
+	}
+} class_rtProtoDYMOUM_hdr;
+
+
+static class DYMOUMClass : public TclClass {
+public:
+	DYMOUMClass() : TclClass("Agent/DYMOUM") { }
+	TclObject *create(int argc, const char*const* argv) {
+		assert(argc == 5);
+		return new DYMOUM(
+			(nsaddr_t) Address::instance().str2addr(argv[4])
+		);
+	}
+} class_rtProtoDYMOUM;
+
+
+void
+DYMOUM_QueueTimer::expire(Event *e) {
+	struct timeval *timeout;
+	
+	timeout = agent_->timer_age_queue();
+	
+	if (timeout)
+		resched((double) timeout->tv_sec +
+			((double) timeout->tv_usec / 1000000.0));
+}
+
+
+NS_CLASS DYMOUM(nsaddr_t id) : Agent(PT_DYMOUM), qtimer_(this),
+				initialized_(0), pq_len(0)
+{
+	/*
+	 Enable usage of some of the configuration variables from Tcl.
+	
+	 Note: Do NOT change the values of these variables in the constructor
+	 after binding them! The desired default values should be set in
+	 ~ns/tcl/lib/ns-default.tcl instead.
+	*/
+	bind_bool("no_path_acc_", &no_path_acc);
+	bind_bool("reissue_rreq_", &reissue_rreq);
+	bind_bool("s_bit_", &s_bit);
+	bind("hello_ival_", &hello_ival);
+	
+	// Set general parameters
+	progname = strdup("DYMOUM");
+	
+	memset(&this_host, 0, sizeof(struct host_info));
+	memset(dev_indices, 0, sizeof(unsigned int) * DYMO_MAX_NR_INTERFACES);
+	this_host.seqnum	= 1;
+	this_host.nif		= 1;
+	this_host.prefix	= 0;
+	this_host.is_gw		= 0;
+	
+	const char faked_ifname[]	= "nsif";
+	dev_indices[NS_DEV_NR]		= NS_IFINDEX;
+	
+	strncpy(DEV_NR(NS_DEV_NR).ifname, faked_ifname, IFNAMSIZ - 1);
+	DEV_NR(NS_DEV_NR).ifname[IFNAMSIZ - 1]	= '\0';
+	DEV_NR(NS_DEV_NR).ipaddr.s_addr		= id;
+	DEV_NR(NS_DEV_NR).bcast.s_addr		= DYMO_BROADCAST;
+	DEV_NR(NS_DEV_NR).enabled		= 1;
+	DEV_NR(NS_DEV_NR).sock			= -1;
+	DEV_NR(NS_DEV_NR).ifindex		= NS_IFINDEX;
+	
+	INIT_DLIST_HEAD(&TQ);
+	INIT_DLIST_HEAD(&PENDING_RREQ);
+	INIT_DLIST_HEAD(&BLACKLIST);
+	INIT_DLIST_HEAD(&NBLIST);
+	
+	// Set agent parameters
+	ra_addr_	= id;
+	addr()		= id;
+	port()		= RT_PORT;
+	dport()		= RT_PORT;
+	
+	// Initialize data structures and services
+	dymo_socket_init();
+	icmp_socket_init();
+	packet_queue_init();
+	rtable_init();
+}
+
+NS_CLASS ~DYMOUM() {
+	rtable_destroy();
+	packet_queue_fini();
+	icmp_socket_fini();
+	dymo_socket_fini();
+	hello_fini();
+}
+
+int
+NS_CLASS command(int argc, const char*const* argv) {
+	if (argc == 2) {
+		if (strcasecmp(argv[1], "start") == 0) {
+			return start();
+		}
+	}
+	else if (argc == 3) {
+		// Get corresponding port classifier, although it is never used
+		if (strcmp(argv[1], "port-dmux") == 0) {
+			if (TclObject::lookup(argv[2]) == 0) {
+				fprintf(stderr, "%s: %s lookup of %s failed\n",
+					__FILE__,
+					argv[1],
+					argv[2]);
+				return TCL_ERROR;
+			}
+			return TCL_OK;
+		}
+		// Get corresponding tracer
+		else if (strcmp(argv[1], "log-target") == 0 ||
+			strcmp(argv[1], "tracetarget") == 0) {
+			logtarget_ = (Trace*) TclObject::lookup(argv[2]);
+			if (logtarget_ == 0)
+				return TCL_ERROR;
+			return TCL_OK;
+		}
+		// Enable promiscuous mode
+		else if (strcmp(argv[1], "install-tap") == 0) {
+			mac_ = (Mac *) TclObject::lookup(argv[2]);
+			if (mac_ == 0)
+				return TCL_ERROR;
+			mac_->installTap(this);
+			return TCL_OK;
+		}
+	}
+	// Pass the command to the base class
+	return Agent::command(argc, argv);
+}
+
+int
+NS_CLASS start() {
+	if (initialized_ == 0) {
+		debug("DYMOUM agent started in node %d\n", ra_addr_);
+		debug("\tno_path_acc=%d\n", no_path_acc);
+		debug("\treissue_rreq=%d\n", reissue_rreq);
+		debug("\ts_bit=%d\n", s_bit);
+		debug("\thello_ival=%d\n\n", hello_ival);
+		
+		initialized_ = 1;
+		hello_init();
+		schedule_next_event();
+		
+		return TCL_OK;
+	}
+	return TCL_ERROR;
+}
+
+void
+NS_CLASS schedule_next_event() {
+	struct timeval *timeout;
+	
+	timeout = timer_age_queue();
+	
+	if (timeout)
+		qtimer_.resched((double) timeout->tv_sec +
+				(double) timeout->tv_usec / (double) 1000000);
+}
+
+void
+NS_CLASS recv(Packet *p, Handler *h) {
+	struct hdr_cmn *ch	= HDR_CMN(p);
+	struct hdr_ip *ih	= HDR_IP(p);
+	
+	assert(initialized_);
+	
+	if (ih->saddr() == ra_addr_) {
+		// If there exists a loop, must drop the packet
+		if (ch->num_forwards() > 0) {
+			drop(p, DROP_RTR_ROUTE_LOOP);
+			schedule_next_event();
+			return;
+		}
+		// else if this is a packet I am originating, must add IP header
+		else if (ch->num_forwards() == 0)
+			ch->size() += IP_HDR_LEN;
+	}
+	
+	// If it is a DYMOUM packet, must process it
+	if (ch->ptype() == PT_DYMOUM)
+		recv_dymoum_pkt(p);
+	// Otherwise, must forward the packet (unless TTL has reached zero)
+	else {
+		ih->ttl_--;
+		if (ih->ttl_ == 0) {
+			drop(p, DROP_RTR_TTL);
+			schedule_next_event();
+			return;
+		}
+		process_data(p);
+	}
+	
+	schedule_next_event();
+}
+void
+NS_CLASS process_data(Packet *p) {
+	struct hdr_cmn* ch	= HDR_CMN(p);
+	struct hdr_ip* ih	= HDR_IP(p);
+	
+	ch->direction() = hdr_cmn::DOWN;
+	ch->addr_type() = NS_AF_INET;
+	
+	if ((u_int32_t) ih->daddr() == IP_BROADCAST)
+		ch->next_hop_ = IP_BROADCAST;
+	else {
+		struct in_addr dest_addr;
+		
+		dest_addr.s_addr	= ih->daddr();
+		rtable_entry_t *entry	= rtable_find(dest_addr);
+		if (!entry || entry->rt_state == RT_INVALID) {
+			// If I am the originating node, then a route discovery
+			// must be performed
+			if (ih->saddr() == ra_addr_) {
+				packet_queue_add(p, dest_addr);
+				route_discovery(dest_addr);
+			}
+			// Else we must send a RERR message to the source if
+			// the route has been previously used
+			else {
+				if (entry->rt_is_used)
+					rerr_send(dest_addr, NET_DIAMETER, entry);
+				drop(p, DROP_RTR_NO_ROUTE);
+			}
+			schedule_next_event();
+			return;
+		}
+		else
+		{
+			ch->prev_hop_ = ra_addr_;
+			ch->next_hop_ =
+				(nsaddr_t) entry->rt_nxthop_addr.s_addr;
+			
+			// Use link layer feedback if HELLO messages are disabled
+			if (hello_ival <= 0)
+			{
+				ch->xmit_failure_	= dymoum_mac_failed_callback;
+				ch->xmit_failure_data_	= (void *) this;
+			}
+			
+			// Update route to dst
+			rtable_update_timeout(entry);
+			dlog(LOG_DEBUG, 0, __FUNCTION__,
+				"route to dst %s updated",
+				ip2str(ih->daddr()));
+		}
+	}
+	
+	Scheduler::instance().schedule(target_, p, 0.0);
+	schedule_next_event();
+}
+
+int
+NS_CLASS gettimeofday(struct timeval *tv, struct timezone *tz) {
+	double current_time, tmp;
+	
+	if (!tv)
+		return -1;
+	
+	current_time = Scheduler::instance().clock();
+	
+	tv->tv_sec	= (long) current_time;
+	tmp		= (current_time - tv->tv_sec) * 1000000;
+	tv->tv_usec	= (long) tmp;
+	
+	return 0;
+}
+
+void
+NS_CLASS tap(const Packet *p) {
+	rtable_entry_t *entry;
+	struct in_addr addr;
+	struct hdr_cmn *ch	= HDR_CMN(p);
+	struct hdr_ip *ih	= HDR_IP(p);
+	
+	// We aren't interested in non-data packets
+	if (!DATA_PACKET(ch->ptype())) {
+		schedule_next_event();
+		return;
+	}
+	
+	// If this is a packet I'm receiving, update route to src
+	if (ch->next_hop_ == ra_addr_)
+	{
+		addr.s_addr = ih->saddr();
+		entry = rtable_find(addr);
+		if (entry)
+		{
+			rtable_update_timeout(entry);
+			dlog(LOG_DEBUG, 0, __FUNCTION__,
+				"route to src %s updated",
+				ip2str(ih->saddr()));
+		}
+		else
+			dlog(LOG_DEBUG, 0, __FUNCTION__,
+				"could not update route to src %s "
+				"because there was no such route",
+				ip2str(ih->saddr()));
+	}
+	
+	schedule_next_event();
+}
+
+void
+NS_CLASS mac_failed(Packet *p) {
+	struct hdr_cmn *ch	= HDR_CMN(p);
+	struct hdr_ip *ih	= HDR_IP(p);
+	
+	if (DATA_PACKET(ch->ptype()) &&
+		(u_int32_t) ih->daddr() != IP_BROADCAST)
+	{
+		struct in_addr addr;
+		
+		addr.s_addr = ch->next_hop();
+		rtable_expire_timeout_all(addr, NS_IFINDEX);
+	}
+	
+	drop(p, DROP_RTR_MAC_CALLBACK);
+	schedule_next_event();
+}
diff -Naur ns-2.35-orig/dymoum/ns/dymo_um.h ns-2.35/dymoum/ns/dymo_um.h
--- ns-2.35-orig/dymoum/ns/dymo_um.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/dymo_um.h	2006-08-28 19:15:21.000000000 +0200
@@ -0,0 +1,195 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DYMO_UM_H__
+#define __DYMO_UM_H__
+
+#ifndef NS_PORT
+#error "You must define NS_PORT in order to compile NS version of DYMOUM"
+#endif	/* NS_PORT */
+
+#include <mac.h>
+#include <agent.h>
+#include <address.h>
+#include <packet.h>
+#include <trace.h>
+#include <random.h>
+#include <cmu-trace.h>
+#include <timer-handler.h>
+
+/* Forward declaration of DYMO routing agent class */
+class DYMOUM;
+
+/* Global definitions */
+#undef	NS_NO_GLOBALS
+#define	NS_NO_DECLARATIONS
+
+#include "../defs.h"
+#include "../debug.h"
+#include "../dlist.h"
+#include "../dymo_generic.h"
+#include "../dymo_re.h"
+#include "../dymo_uerr.h"
+#include "../dymo_rerr.h"
+#include "../dymo_socket.h"
+#include "../dymo_timeout.h"
+#include "../rtable.h"
+#include "../pending_rreq.h"
+#include "../timer_queue.h"
+#include "../blacklist.h"
+#include "../icmp_socket.h"
+#include "../dymo_hello.h"
+#include "../dymo_nb.h"
+#include "packet_queue.h"
+
+#undef	NS_NO_DECLARATIONS
+
+/* In ns2 we don't care about byte order */
+#define ntohl(x) x
+#define htonl(x) x
+#define htons(x) x
+#define ntohs(x) x
+
+#define CURRENT_TIME Scheduler::instance().clock()
+
+/* Timer for managing the DYMO queue of timers */
+class DYMOUM_QueueTimer : public TimerHandler {
+public:
+	DYMOUM_QueueTimer(DYMOUM *agent) : TimerHandler() {
+		agent_ = agent;
+	}
+
+protected:
+	DYMOUM *agent_;
+	virtual void expire(Event *e);
+};
+
+/* DYMO routing agent */
+class DYMOUM : public Agent, public Tap {
+	// Make friends
+	friend class DYMOUM_QueueTimer;
+	friend class CMUTrace; // to call re_numblocks() which is protected
+	
+protected:
+	Mac			*mac_;
+	Trace			*logtarget_;
+	DYMOUM_QueueTimer	qtimer_;
+	nsaddr_t		ra_addr_;
+	int			initialized_;
+	
+	// Variables from main.c
+	char	*progname;
+	int	no_path_acc;
+	int	reissue_rreq;
+	int	s_bit;
+	int	hello_ival;
+	
+	// Variables from pending_rreq.c
+	dlist_head_t	PENDING_RREQ;
+	
+	// Variables from timer_queue.c
+	dlist_head_t	TQ;
+	
+	// Variables from blacklist.c
+	dlist_head_t	BLACKLIST;
+
+	// Variables from dymo_socket.c
+	char	recv_buf[RECV_BUF_SIZE];
+	char	send_buf[SEND_BUF_SIZE];
+	
+	// Variables from icmp_socket.c
+	char icmp_send_buf[ICMP_SEND_BUF_SIZE];
+	char icmp_recv_buf[ICMP_RECV_BUF_SIZE];
+	
+	// Variables from dymo_hello.c
+	struct timer hello_timer;
+	
+	// Variables from dymo_nb.c
+	dlist_head_t NBLIST;
+	
+	
+	int	gettimeofday(struct timeval *tv, struct timezone *tz);
+	int	start();
+	void	schedule_next_event();
+	void	process_data(Packet *p);
+	
+#define	NS_NO_GLOBALS
+#undef	NS_NO_DECLARATIONS
+
+#undef __DEFS_H__
+#include "../defs.h"
+
+#undef __DEBUG_H__
+#include "../debug.h"
+
+#undef __DYMO_GENERIC_H__
+#include "../dymo_generic.h"
+
+#undef __DYMO_RE_H__
+#include "../dymo_re.h"
+
+#undef __DYMO_UERR_H__
+#include "../dymo_uerr.h"
+
+#undef __DYMO_RERR_H__
+#include "../dymo_rerr.h"
+
+#undef __DYMO_SOCKET_H__
+#include "../dymo_socket.h"
+
+#undef __DYMO_TIMEOUT_H__
+#include "../dymo_timeout.h"
+
+#undef __RTABLE_H__
+#include "../rtable.h"
+
+#undef __PENDING_RREQ_H__
+#include "../pending_rreq.h"
+
+#undef __TIMER_QUEUE_H__
+#include "../timer_queue.h"
+
+#undef __BLACKLIST_H__
+#include "../blacklist.h"
+
+#undef __ICMP_SOCKET_H__
+#include "../icmp_socket.h"
+
+#undef __DYMO_HELLO_H__
+#include "../dymo_hello.h"
+
+#undef __DYMO_NB_H__
+#include "../dymo_nb.h"
+
+#undef __PACKET_QUEUE_H__
+#include "packet_queue.h"
+
+#undef NS_NO_GLOBALS
+
+public:
+	DYMOUM(nsaddr_t id);
+	~DYMOUM();
+	int	command(int, const char*const*);
+	void	recv(Packet *, Handler *);
+	void	mac_failed(Packet *);
+	void	tap(const Packet *);
+};
+
+#endif	/* __DYMO_UM_H__ */
diff -Naur ns-2.35-orig/dymoum/ns/packet_queue.cc ns-2.35/dymoum/ns/packet_queue.cc
--- ns-2.35-orig/dymoum/ns/packet_queue.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/packet_queue.cc	2006-08-28 19:15:21.000000000 +0200
@@ -0,0 +1,133 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "dymo_um.h"
+
+void
+NS_CLASS packet_queue_init()
+{
+	INIT_DLIST_HEAD(&PQ.l);
+}
+
+void
+NS_CLASS packet_queue_fini()
+{
+	dlist_head_t *pos, *tmp;
+	int count = 0;
+	
+	dlist_for_each_safe(pos, tmp, &PQ.l)
+	{
+		struct packet_queue *pq = (struct packet_queue *) pos;
+		dlist_del(pos);
+		drop(pq->p, DROP_END_OF_SIMULATION);
+		free(pq);
+		count++;
+	}
+	pq_len = 0;
+	
+	dlog(LOG_INFO, 0, __FUNCTION__, "Dropped %d buffered packets", count);
+}
+
+void
+NS_CLASS packet_queue_add(Packet *p, struct in_addr dest_addr)
+{
+	struct packet_queue *pq;
+	
+	if (pq_len >= MAX_QUEUE_LEN)
+	{
+		dlog(LOG_DEBUG, 0, __FUNCTION__, "Max queue length reached,"
+			" removing first packet");
+		if (!dlist_empty(&PQ.l))
+		{
+			pq = (struct packet_queue *) PQ.l.next;
+			dlist_del(PQ.l.next);
+			drop(pq->p, DROP_RTR_QFULL);
+			free(pq);
+			pq_len--;
+		}
+	}
+	
+	if ((pq = (struct packet_queue *) malloc(sizeof(struct packet_queue)))
+		== NULL)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "failed malloc()");
+		exit(EXIT_FAILURE);
+	}
+	
+	pq->p			= p;
+	pq->dest_addr.s_addr	= dest_addr.s_addr;
+	dlist_add_tail(&pq->l, &PQ.l);
+	
+	pq_len++;
+}
+
+int
+NS_CLASS packet_queue_set_verdict(struct in_addr dest_addr, int verdict)
+{
+	struct packet_queue *pq;
+	dlist_head_t *pos, *tmp;
+	int count = 0;
+	double delay = 0.0;
+	rtable_entry_t *entry = rtable_find(dest_addr);
+	
+#define ARP_DELAY 0.005
+	
+	dlist_for_each_safe(pos, tmp, &PQ.l)
+	{
+		pq = (struct packet_queue *) pos;
+		if (pq->dest_addr.s_addr == dest_addr.s_addr)
+		{
+			struct hdr_cmn *ch;
+			
+			dlist_del(pos);
+			switch (verdict)
+			{
+				case PQ_SEND:
+				
+				if (!entry || entry->rt_state == RT_INVALID)
+					return -1;
+				
+				ch = HDR_CMN(pq->p);
+				ch->next_hop_ =
+					(nsaddr_t)entry->rt_nxthop_addr.s_addr;
+				
+				Scheduler::instance().schedule(target_, pq->p,
+					delay);
+				delay += ARP_DELAY;
+				break;
+				
+				case PQ_DROP:
+				
+				drop(pq->p, DROP_RTR_NO_ROUTE);
+				break;
+				
+				default:
+				
+				dlog(LOG_ERR, 0, __FUNCTION__, "unknown verdict %d", verdict);
+				exit(EXIT_FAILURE);
+			}
+			free(pq);
+			pq_len--;
+			count++;
+		}
+	}
+	
+	return count;
+}
diff -Naur ns-2.35-orig/dymoum/ns/packet_queue.h ns-2.35/dymoum/ns/packet_queue.h
--- ns-2.35-orig/dymoum/ns/packet_queue.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/packet_queue.h	2006-08-28 19:15:21.000000000 +0200
@@ -0,0 +1,61 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __PACKET_QUEUE_H__
+#define __PACKET_QUEUE_H__
+
+#ifndef NS_NO_GLOBALS
+
+#define MAX_QUEUE_LEN	512
+
+/* Verdicts for queued packets */
+enum {
+	PQ_DROP = 0,
+	PQ_SEND = 1
+};
+
+struct packet_queue
+{
+	dlist_head_t	l;
+	Packet		*p;
+	struct in_addr	dest_addr;
+};
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+struct packet_queue PQ;
+int pq_len;
+
+/* Initialize the packet queue */
+void packet_queue_init();
+
+/* Destroy the packet queue */
+void packet_queue_fini();
+
+/* Add a new packet to the queue */
+void packet_queue_add(Packet *p, struct in_addr dest_addr);
+
+/* Set a verdict to the packets directed to a given destination: drop them
+   or send them. Return the number of packets dropped or sent */
+int packet_queue_set_verdict(struct in_addr dest_addr, int verdict);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __PACKET_QUEUE_H__ */
diff -Naur ns-2.35-orig/dymoum/ns/test/Makefile ns-2.35/dymoum/ns/test/Makefile
--- ns-2.35-orig/dymoum/ns/test/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/test/Makefile	2006-08-28 19:15:54.000000000 +0200
@@ -0,0 +1,5 @@
+default: clean
+
+clean:
+	rm -f *~ *.tr *.nam
+
diff -Naur ns-2.35-orig/dymoum/ns/test/test_2n_m.tcl ns-2.35/dymoum/ns/test/test_2n_m.tcl
--- ns-2.35-orig/dymoum/ns/test/test_2n_m.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/test/test_2n_m.tcl	2006-08-31 12:23:59.000000000 +0200
@@ -0,0 +1,161 @@
+# ======================================================================
+# Define options
+# ======================================================================
+set opt(chan)           Channel/WirelessChannel  ;# channel type
+set opt(prop)           Propagation/TwoRayGround ;# radio-propagation model
+set opt(netif)          Phy/WirelessPhy          ;# network interface type
+set opt(mac)            Mac/802_11               ;# MAC type
+set opt(ifq)            Queue/DropTail/PriQueue  ;# interface queue type
+set opt(ll)             LL                       ;# link layer type
+set opt(ant)            Antenna/OmniAntenna      ;# antenna model
+set opt(ifqlen)         50                       ;# max packet in ifq
+set opt(nn)             2                        ;# number of mobilenodes
+set opt(adhocRouting)   DYMOUM                   ;# routing protocol
+
+set opt(cp)             ""                        ;# connection pattern file
+set opt(sc)             "test_sc-2-900-0-400-200" ;# node movement file. 
+
+set opt(x)              400                      ;# x coordinate of topology
+set opt(y)              200                      ;# y coordinate of topology
+set opt(seed)           0.0                      ;# seed for random number gen.
+set opt(stop)           900                      ;# time to stop simulation
+
+set opt(cbr-start)      50.0
+# ============================================================================
+
+#
+# check for random seed
+#
+if {$opt(seed) > 0} {
+    puts "Seeding Random number generator with $opt(seed)\n"
+    ns-random $opt(seed)
+}
+
+#
+# create simulator instance
+#
+set ns_ [new Simulator]
+
+#
+# control DYMOUM behaviour from this script
+#
+Agent/DYMOUM set debug_ true
+Agent/DYMOUM set no_path_acc_ true
+Agent/DYMOUM set reissue_rreq_ false
+Agent/DYMOUM set s_bit_ false
+Agent/DYMOUM set hello_ival_ 1
+
+#
+# open traces
+#
+set tracefd  [open test_2n_m.tr w]
+set namtrace [open test_2n_m.nam w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $opt(x) $opt(y)
+
+#
+# create topography object
+#
+set topo [new Topography]
+
+#
+# define topology
+#
+$topo load_flatgrid $opt(x) $opt(y)
+
+#
+# create God
+#
+set god_ [create-god $opt(nn)]
+
+#
+# configure mobile nodes
+#
+$ns_ node-config -adhocRouting $opt(adhocRouting) \
+                 -llType $opt(ll) \
+                 -macType $opt(mac) \
+                 -ifqType $opt(ifq) \
+                 -ifqLen $opt(ifqlen) \
+                 -antType $opt(ant) \
+                 -propType $opt(prop) \
+                 -phyType $opt(netif) \
+                 -channelType $opt(chan) \
+                 -topoInstance $topo \
+                 -wiredRouting OFF \
+                 -agentTrace ON \
+                 -routerTrace ON \
+                 -macTrace OFF
+
+for {set i 0} {$i < $opt(nn)} {incr i} {
+    set node_($i) [$ns_ node]
+}
+
+#
+# setup UDP connection
+#
+set udp [new Agent/UDP]
+set null [new Agent/Null]
+$ns_ attach-agent $node_(0) $udp
+$ns_ attach-agent $node_(1) $null
+$ns_ connect $udp $null
+set cbr [new Application/Traffic/CBR]
+$cbr set packetSize_ 512
+$cbr set rate_ 20Kb
+$cbr attach-agent $udp
+$ns_ at $opt(cbr-start) "$cbr start"
+
+#
+# print (in the trace file) routing table and other
+# internal data structures on a per-node basis
+# TODO: implement this
+#$ns_ at 15.0 "[$node_(0) agent 255] print_rtable"
+
+#
+# source connection-pattern and node-movement scripts
+#
+if { $opt(cp) == "" } {
+    puts "*** NOTE: no connection pattern specified."
+    set opt(cp) "none"
+} else {
+    puts "Loading connection pattern..."
+    source $opt(cp)
+}
+if { $opt(sc) == "" } {
+    puts "*** NOTE: no scenario file specified."
+    set opt(sc) "none"
+} else {
+    puts "Loading scenario file..."
+    source $opt(sc)
+    puts "Load complete..."
+}
+
+#
+# define initial node position in nam
+#
+for {set i 0} {$i < $opt(nn)} {incr i} {
+    $ns_ initial_node_pos $node_($i) 20
+}     
+
+#
+# tell all nodes when the simulation ends
+#
+for {set i 0} {$i < $opt(nn) } {incr i} {
+    $ns_ at $opt(stop).0 "$node_($i) reset";
+}
+
+$ns_ at $opt(stop).0002 "puts \"NS EXITING...\" ; $ns_ halt"
+$ns_ at $opt(stop).0001 "stop"
+
+proc stop {} {
+    global ns_ tracefd namtrace
+    $ns_ flush-trace
+    close $tracefd
+    close $namtrace
+}
+
+#
+# begin simulation
+#
+puts "Starting Simulation..."
+
+$ns_ run
diff -Naur ns-2.35-orig/dymoum/ns/test/test_2n.tcl ns-2.35/dymoum/ns/test/test_2n.tcl
--- ns-2.35-orig/dymoum/ns/test/test_2n.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/test/test_2n.tcl	2006-08-31 12:23:59.000000000 +0200
@@ -0,0 +1,172 @@
+# ======================================================================
+# Define options
+# ======================================================================
+set opt(chan)           Channel/WirelessChannel  ;# channel type
+set opt(prop)           Propagation/TwoRayGround ;# radio-propagation model
+set opt(netif)          Phy/WirelessPhy          ;# network interface type
+set opt(mac)            Mac/802_11               ;# MAC type
+set opt(ifq)            Queue/DropTail/PriQueue  ;# interface queue type
+set opt(ll)             LL                       ;# link layer type
+set opt(ant)            Antenna/OmniAntenna      ;# antenna model
+set opt(ifqlen)         50                       ;# max packet in ifq
+set opt(nn)             2                        ;# number of mobilenodes
+set opt(adhocRouting)   DYMOUM                   ;# routing protocol
+
+set opt(cp)             ""                       ;# connection pattern file
+set opt(sc)             ""                       ;# node movement file. 
+
+set opt(x)              400                      ;# x coordinate of topology
+set opt(y)              600                      ;# y coordinate of topology
+set opt(seed)           0.0                      ;# seed for random number gen.
+set opt(stop)           40                       ;# time to stop simulation
+
+set opt(cbr-start)      10.0
+# ============================================================================
+
+#
+# check for random seed
+#
+if {$opt(seed) > 0} {
+    puts "Seeding Random number generator with $opt(seed)\n"
+    ns-random $opt(seed)
+}
+
+#
+# create simulator instance
+#
+set ns_ [new Simulator]
+
+#
+# control DYMOUM behaviour from this script
+#
+Agent/DYMOUM set debug_ true
+Agent/DYMOUM set no_path_acc_ true
+Agent/DYMOUM set reissue_rreq_ false
+Agent/DYMOUM set s_bit_ true
+Agent/DYMOUM set hello_ival_ 1
+
+#
+# open traces
+#
+set tracefd  [open test_2n.tr w]
+set namtrace [open test_2n.nam w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $opt(x) $opt(y)
+
+#
+# create topography object
+#
+set topo [new Topography]
+
+#
+# define topology
+#
+$topo load_flatgrid $opt(x) $opt(y)
+
+#
+# create God
+#
+create-god $opt(nn)
+
+#
+# configure mobile nodes
+#
+$ns_ node-config -adhocRouting $opt(adhocRouting) \
+                 -llType $opt(ll) \
+                 -macType $opt(mac) \
+                 -ifqType $opt(ifq) \
+                 -ifqLen $opt(ifqlen) \
+                 -antType $opt(ant) \
+                 -propType $opt(prop) \
+                 -phyType $opt(netif) \
+                 -channelType $opt(chan) \
+                 -topoInstance $topo \
+                 -wiredRouting OFF \
+                 -agentTrace ON \
+                 -routerTrace ON \
+                 -macTrace OFF
+
+for {set i 0} {$i < $opt(nn)} {incr i} {
+    set node_($i) [$ns_ node]
+}
+
+#
+# positions
+#
+$node_(0) set X_ 200.0
+$node_(0) set Y_ 200.0
+$node_(0) set Z_ 0.0
+
+$node_(1) set X_ 300.0
+$node_(1) set Y_ 200.0
+$node_(1) set Z_ 0.0
+
+#
+# setup UDP connection
+#
+set udp [new Agent/UDP]
+set null [new Agent/Null]
+$ns_ attach-agent $node_(0) $udp
+$ns_ attach-agent $node_(1) $null
+$ns_ connect $udp $null
+set cbr [new Application/Traffic/CBR]
+$cbr set packetSize_ 512
+$cbr set rate_ 20Kb
+$cbr attach-agent $udp
+$ns_ at $opt(cbr-start) "$cbr start"
+
+#
+# print (in the trace file) routing table and other
+# internal data structures on a per-node basis
+# TODO: implement this
+#$ns_ at 15.0 "[$node_(0) agent 255] print_rtable"
+
+#
+# source connection-pattern and node-movement scripts
+#
+if { $opt(cp) == "" } {
+    puts "*** NOTE: no connection pattern specified."
+    set opt(cp) "none"
+} else {
+    puts "Loading connection pattern..."
+    source $opt(cp)
+}
+if { $opt(sc) == "" } {
+    puts "*** NOTE: no scenario file specified."
+    set opt(sc) "none"
+} else {
+    puts "Loading scenario file..."
+    source $opt(sc)
+    puts "Load complete..."
+}
+
+#
+# define initial node position in nam
+#
+for {set i 0} {$i < $opt(nn)} {incr i} {
+    $ns_ initial_node_pos $node_($i) 20
+}     
+
+#
+# tell all nodes when the simulation ends
+#
+for {set i 0} {$i < $opt(nn) } {incr i} {
+    $ns_ at $opt(stop).0 "$node_($i) reset";
+}
+
+$ns_ at $opt(stop).0002 "puts \"NS EXITING...\" ; $ns_ halt"
+$ns_ at $opt(stop).0001 "stop"
+
+proc stop {} {
+    global ns_ tracefd namtrace
+    $ns_ flush-trace
+    close $tracefd
+    close $namtrace
+}
+
+#
+# begin simulation
+#
+puts "Starting Simulation..."
+
+$ns_ run
diff -Naur ns-2.35-orig/dymoum/ns/test/test_3n_m.tcl ns-2.35/dymoum/ns/test/test_3n_m.tcl
--- ns-2.35-orig/dymoum/ns/test/test_3n_m.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/test/test_3n_m.tcl	2006-08-31 12:23:59.000000000 +0200
@@ -0,0 +1,161 @@
+# ======================================================================
+# Define options
+# ======================================================================
+set opt(chan)           Channel/WirelessChannel  ;# channel type
+set opt(prop)           Propagation/TwoRayGround ;# radio-propagation model
+set opt(netif)          Phy/WirelessPhy          ;# network interface type
+set opt(mac)            Mac/802_11               ;# MAC type
+set opt(ifq)            Queue/DropTail/PriQueue  ;# interface queue type
+set opt(ll)             LL                       ;# link layer type
+set opt(ant)            Antenna/OmniAntenna      ;# antenna model
+set opt(ifqlen)         50                       ;# max packet in ifq
+set opt(nn)             3                        ;# number of mobilenodes
+set opt(adhocRouting)   DYMOUM                   ;# routing protocol
+
+set opt(cp)             ""                        ;# connection pattern file
+set opt(sc)             "test_sc-3-900-0-500-100" ;# node movement file. 
+
+set opt(x)              500                      ;# x coordinate of topology
+set opt(y)              100                      ;# y coordinate of topology
+set opt(seed)           0.0                      ;# seed for random number gen.
+set opt(stop)           900                      ;# time to stop simulation
+
+set opt(cbr-start)      10.0
+# ============================================================================
+
+#
+# check for random seed
+#
+if {$opt(seed) > 0} {
+    puts "Seeding Random number generator with $opt(seed)\n"
+    ns-random $opt(seed)
+}
+
+#
+# create simulator instance
+#
+set ns_ [new Simulator]
+
+#
+# control DYMOUM behaviour from this script
+#
+Agent/DYMOUM set debug_ true
+Agent/DYMOUM set no_path_acc_ true
+Agent/DYMOUM set reissue_rreq_ true
+Agent/DYMOUM set s_bit_ false
+Agent/DYMOUM set hello_ival_ 1
+
+#
+# open traces
+#
+set tracefd  [open test_3n_m.tr w]
+set namtrace [open test_3n_m.nam w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $opt(x) $opt(y)
+
+#
+# create topography object
+#
+set topo [new Topography]
+
+#
+# define topology
+#
+$topo load_flatgrid $opt(x) $opt(y)
+
+#
+# create God
+#
+set god_ [create-god $opt(nn)]
+
+#
+# configure mobile nodes
+#
+$ns_ node-config -adhocRouting $opt(adhocRouting) \
+                 -llType $opt(ll) \
+                 -macType $opt(mac) \
+                 -ifqType $opt(ifq) \
+                 -ifqLen $opt(ifqlen) \
+                 -antType $opt(ant) \
+                 -propType $opt(prop) \
+                 -phyType $opt(netif) \
+                 -channelType $opt(chan) \
+                 -topoInstance $topo \
+                 -wiredRouting OFF \
+                 -agentTrace ON \
+                 -routerTrace ON \
+                 -macTrace OFF
+
+for {set i 0} {$i < $opt(nn)} {incr i} {
+    set node_($i) [$ns_ node]
+}
+
+#
+# setup UDP connection
+#
+set udp [new Agent/UDP]
+set null [new Agent/Null]
+$ns_ attach-agent $node_(0) $udp
+$ns_ attach-agent $node_(2) $null
+$ns_ connect $udp $null
+set cbr [new Application/Traffic/CBR]
+$cbr set packetSize_ 512
+$cbr set rate_ 20Kb
+$cbr attach-agent $udp
+$ns_ at $opt(cbr-start) "$cbr start"
+
+#
+# print (in the trace file) routing table and other
+# internal data structures on a per-node basis
+# TODO: implement this
+#$ns_ at 15.0 "[$node_(0) agent 255] print_rtable"
+
+#
+# source connection-pattern and node-movement scripts
+#
+if { $opt(cp) == "" } {
+    puts "*** NOTE: no connection pattern specified."
+    set opt(cp) "none"
+} else {
+    puts "Loading connection pattern..."
+    source $opt(cp)
+}
+if { $opt(sc) == "" } {
+    puts "*** NOTE: no scenario file specified."
+    set opt(sc) "none"
+} else {
+    puts "Loading scenario file..."
+    source $opt(sc)
+    puts "Load complete..."
+}
+
+#
+# define initial node position in nam
+#
+for {set i 0} {$i < $opt(nn)} {incr i} {
+    $ns_ initial_node_pos $node_($i) 20
+}     
+
+#
+# tell all nodes when the simulation ends
+#
+for {set i 0} {$i < $opt(nn) } {incr i} {
+    $ns_ at $opt(stop).0 "$node_($i) reset";
+}
+
+$ns_ at $opt(stop).0002 "puts \"NS EXITING...\" ; $ns_ halt"
+$ns_ at $opt(stop).0001 "stop"
+
+proc stop {} {
+    global ns_ tracefd namtrace
+    $ns_ flush-trace
+    close $tracefd
+    close $namtrace
+}
+
+#
+# begin simulation
+#
+puts "Starting Simulation..."
+
+$ns_ run
diff -Naur ns-2.35-orig/dymoum/ns/test/test_3n.tcl ns-2.35/dymoum/ns/test/test_3n.tcl
--- ns-2.35-orig/dymoum/ns/test/test_3n.tcl	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/test/test_3n.tcl	2006-08-31 12:23:59.000000000 +0200
@@ -0,0 +1,176 @@
+# ======================================================================
+# Define options
+# ======================================================================
+set opt(chan)           Channel/WirelessChannel  ;# channel type
+set opt(prop)           Propagation/TwoRayGround ;# radio-propagation model
+set opt(netif)          Phy/WirelessPhy          ;# network interface type
+set opt(mac)            Mac/802_11               ;# MAC type
+set opt(ifq)            Queue/DropTail/PriQueue  ;# interface queue type
+set opt(ll)             LL                       ;# link layer type
+set opt(ant)            Antenna/OmniAntenna      ;# antenna model
+set opt(ifqlen)         50                       ;# max packet in ifq
+set opt(nn)             3                        ;# number of mobilenodes
+set opt(adhocRouting)   DYMOUM                   ;# routing protocol
+
+set opt(cp)             ""                       ;# connection pattern file
+set opt(sc)             ""                       ;# node movement file. 
+
+set opt(x)              500                      ;# x coordinate of topology
+set opt(y)              100                      ;# y coordinate of topology
+set opt(seed)           0.0                      ;# seed for random number gen.
+set opt(stop)           50                       ;# time to stop simulation
+
+set opt(cbr-start)      10.0
+# ============================================================================
+
+#
+# check for random seed
+#
+if {$opt(seed) > 0} {
+    puts "Seeding Random number generator with $opt(seed)\n"
+    ns-random $opt(seed)
+}
+
+#
+# create simulator instance
+#
+set ns_ [new Simulator]
+
+#
+# control DYMOUM behaviour from this script
+#
+Agent/DYMOUM set debug_ true
+Agent/DYMOUM set no_path_acc_ false
+Agent/DYMOUM set reissue_rreq_ false
+Agent/DYMOUM set s_bit_ false
+Agent/DYMOUM set hello_ival_ 1
+
+#
+# open traces
+#
+set tracefd  [open test_3n.tr w]
+set namtrace [open test_3n.nam w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $opt(x) $opt(y)
+
+#
+# create topography object
+#
+set topo [new Topography]
+
+#
+# define topology
+#
+$topo load_flatgrid $opt(x) $opt(y)
+
+#
+# create God
+#
+create-god $opt(nn)
+
+#
+# configure mobile nodes
+#
+$ns_ node-config -adhocRouting $opt(adhocRouting) \
+                 -llType $opt(ll) \
+                 -macType $opt(mac) \
+                 -ifqType $opt(ifq) \
+                 -ifqLen $opt(ifqlen) \
+                 -antType $opt(ant) \
+                 -propType $opt(prop) \
+                 -phyType $opt(netif) \
+                 -channelType $opt(chan) \
+                 -topoInstance $topo \
+                 -wiredRouting OFF \
+                 -agentTrace ON \
+                 -routerTrace ON \
+                 -macTrace OFF
+
+for {set i 0} {$i < $opt(nn)} {incr i} {
+    set node_($i) [$ns_ node]
+}
+
+#
+# positions
+#
+$node_(0) set X_ 50.0
+$node_(0) set Y_ 50.0
+$node_(0) set Z_ 0.0
+
+$node_(1) set X_ 250.0
+$node_(1) set Y_ 50.0
+$node_(1) set Z_ 0.0
+
+$node_(2) set X_ 450.0
+$node_(2) set Y_ 50.0
+$node_(2) set Z_ 0.0
+
+#
+# setup UDP connection
+#
+set udp [new Agent/UDP]
+set null [new Agent/Null]
+$ns_ attach-agent $node_(0) $udp
+$ns_ attach-agent $node_(2) $null
+$ns_ connect $udp $null
+set cbr [new Application/Traffic/CBR]
+$cbr set packetSize_ 512
+$cbr set rate_ 20Kb
+$cbr attach-agent $udp
+$ns_ at $opt(cbr-start) "$cbr start"
+
+#
+# print (in the trace file) routing table and other
+# internal data structures on a per-node basis
+# TODO: implement this
+#$ns_ at 15.0 "[$node_(0) agent 255] print_rtable"
+
+#
+# source connection-pattern and node-movement scripts
+#
+if { $opt(cp) == "" } {
+    puts "*** NOTE: no connection pattern specified."
+    set opt(cp) "none"
+} else {
+    puts "Loading connection pattern..."
+    source $opt(cp)
+}
+if { $opt(sc) == "" } {
+    puts "*** NOTE: no scenario file specified."
+    set opt(sc) "none"
+} else {
+    puts "Loading scenario file..."
+    source $opt(sc)
+    puts "Load complete..."
+}
+
+#
+# define initial node position in nam
+#
+for {set i 0} {$i < $opt(nn)} {incr i} {
+    $ns_ initial_node_pos $node_($i) 20
+}     
+
+#
+# tell all nodes when the simulation ends
+#
+for {set i 0} {$i < $opt(nn) } {incr i} {
+    $ns_ at $opt(stop).0 "$node_($i) reset";
+}
+
+$ns_ at $opt(stop).0002 "puts \"NS EXITING...\" ; $ns_ halt"
+$ns_ at $opt(stop).0001 "stop"
+
+proc stop {} {
+    global ns_ tracefd namtrace
+    $ns_ flush-trace
+    close $tracefd
+    close $namtrace
+}
+
+#
+# begin simulation
+#
+puts "Starting Simulation..."
+
+$ns_ run
diff -Naur ns-2.35-orig/dymoum/ns/test/test_sc-2-900-0-400-200 ns-2.35/dymoum/ns/test/test_sc-2-900-0-400-200
--- ns-2.35-orig/dymoum/ns/test/test_sc-2-900-0-400-200	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/test/test_sc-2-900-0-400-200	2006-08-28 19:15:54.000000000 +0200
@@ -0,0 +1,79 @@
+#
+# nodes: 2, pause: 0.00, max speed: 20.00, max x: 375.00, max y: 175.00
+#
+$node_(0) set X_ 228.082604750800
+$node_(0) set Y_ 60.910994540781
+$node_(0) set Z_ 0.000000000000
+$node_(1) set X_ 335.534966851415
+$node_(1) set Y_ 81.553574672002
+$node_(1) set Z_ 0.000000000000
+$ns_ at 0.000000000000 "$node_(0) setdest 374.948723093684 124.831804793797 3.333323205200"
+$ns_ at 0.000000000000 "$node_(1) setdest 13.970123582004 100.155875367909 11.338336532557"
+$god_ set-dist 0 1 1
+$ns_ at 24.862804502532 "$god_ set-dist 0 1 16777215"
+$ns_ at 28.408264118592 "$node_(1) setdest 116.416210940707 143.251831508563 16.832476724208"
+$ns_ at 32.582974223717 "$god_ set-dist 0 1 1"
+$ns_ at 35.011073278133 "$node_(1) setdest 67.274430765091 145.675359154231 13.650940819503"
+$ns_ at 36.743548895969 "$god_ set-dist 0 1 16777215"
+$ns_ at 38.615330680660 "$node_(1) setdest 155.439453072941 100.661249618870 13.793486819846"
+$ns_ at 41.759070180519 "$god_ set-dist 0 1 1"
+$ns_ at 45.792023799699 "$node_(1) setdest 40.870473633068 127.728966173629 6.861176706647"
+$ns_ at 48.052174088277 "$node_(0) setdest 326.559504621983 32.369392978222 2.020526556361"
+$ns_ at 50.686705479430 "$god_ set-dist 0 1 16777215"
+$ns_ at 62.949872564436 "$node_(1) setdest 98.476586073667 102.570612690106 13.403892532925"
+$ns_ at 67.639571270745 "$node_(1) setdest 210.112259945215 22.669608848001 6.999703374677"
+$ns_ at 68.894496147955 "$god_ set-dist 0 1 1"
+$ns_ at 87.252296968943 "$node_(1) setdest 351.022442602010 92.936814007316 17.944468723715"
+$ns_ at 96.027058731129 "$node_(1) setdest 17.992025646926 18.350712819246 18.009760274093"
+$ns_ at 99.701613106386 "$node_(0) setdest 108.371989898471 92.340523401934 2.865701801159"
+$ns_ at 113.817269129930 "$god_ set-dist 0 1 16777215"
+$ns_ at 114.976808431003 "$node_(1) setdest 79.511860685532 55.330716104663 3.733936049197"
+$ns_ at 117.886063804314 "$god_ set-dist 0 1 1"
+$ns_ at 134.200196531934 "$node_(1) setdest 175.543188178675 102.019924378289 10.759159046669"
+$ns_ at 144.124733386891 "$node_(1) setdest 192.893650090992 130.024356533556 0.120664179581"
+$ns_ at 178.662834464561 "$node_(0) setdest 164.356300650656 150.170355752444 17.409919197965"
+$ns_ at 183.286022605140 "$node_(0) setdest 4.379248895190 81.504117052037 0.366373554851"
+$ns_ at 417.144370967954 "$node_(1) setdest 242.172781726564 79.426870895733 1.123941427511"
+$ns_ at 479.985355302905 "$node_(1) setdest 276.759641114856 136.043157689734 16.134362382802"
+$ns_ at 484.097384423047 "$node_(1) setdest 196.500586112291 153.504660580999 13.709256563225"
+$ns_ at 490.088708104924 "$node_(1) setdest 275.733965123693 34.133701084603 5.963194961740"
+$ns_ at 514.115040488541 "$node_(1) setdest 51.191610842444 57.639219830501 12.632450342073"
+$ns_ at 531.987210741274 "$node_(1) setdest 286.080098828455 1.698300371237 10.436968484635"
+$ns_ at 553.757855874416 "$god_ set-dist 0 1 16777215"
+$ns_ at 555.122093915025 "$node_(1) setdest 191.708926519020 101.916908361883 6.288565860135"
+$ns_ at 557.823037764108 "$god_ set-dist 0 1 1"
+$ns_ at 577.012277967984 "$node_(1) setdest 41.359577351900 1.504342167849 19.428928359695"
+$ns_ at 586.317842786364 "$node_(1) setdest 162.162752817351 167.285021713535 1.979719729112"
+$ns_ at 658.459770513971 "$node_(0) setdest 298.453828716510 147.553743158043 12.176594681277"
+$ns_ at 683.212236787873 "$node_(0) setdest 111.209002237644 27.218448815736 15.825252726593"
+$ns_ at 689.931456249304 "$node_(1) setdest 180.853376599844 38.539661238028 15.199302560989"
+$ns_ at 697.277007033713 "$node_(0) setdest 243.872086773718 148.519269357670 11.584498470085"
+$ns_ at 698.490730117276 "$node_(1) setdest 213.121353725261 10.896037557716 15.894271299711"
+$ns_ at 701.164014544908 "$node_(1) setdest 138.979059651644 75.528974105843 10.711896291020"
+$ns_ at 710.346237233693 "$node_(1) setdest 351.855513013654 64.401390582903 18.959032414360"
+$ns_ at 712.794229194086 "$node_(0) setdest 300.143117563512 33.699330113470 2.442610517159"
+$ns_ at 721.589800912818 "$node_(1) setdest 130.145936027485 131.703289981066 2.357825229510"
+$ns_ at 765.142854894579 "$node_(0) setdest 231.040718920173 15.416444350644 14.151655510893"
+$ns_ at 770.193861466910 "$node_(0) setdest 279.585427902352 83.323225392082 4.079149022806"
+$ns_ at 790.657459500580 "$node_(0) setdest 132.650979233767 89.006930191173 17.372381341051"
+$ns_ at 799.121718542791 "$node_(0) setdest 58.216200381045 41.130055168190 1.590838672336"
+$ns_ at 819.858132531891 "$node_(1) setdest 346.394708944741 63.011278737417 6.199511408223"
+$ns_ at 850.637223264150 "$god_ set-dist 0 1 16777215"
+$ns_ at 854.754462225389 "$node_(0) setdest 1.138660209682 162.450721188157 2.332452853478"
+$ns_ at 856.457262834166 "$node_(1) setdest 158.757817529055 52.685895372104 17.330907863758"
+$ns_ at 858.915661402972 "$god_ set-dist 0 1 1"
+$ns_ at 867.300363121301 "$node_(1) setdest 280.716515411398 149.269835196465 7.087192650450"
+$ns_ at 887.901297283443 "$god_ set-dist 0 1 16777215"
+$ns_ at 889.251388516432 "$node_(1) setdest 124.620086378646 117.194797366745 12.885600361089"
+$ns_ at 890.006574081393 "$god_ set-dist 0 1 1"
+#
+# Destination Unreachables: 7
+#
+# Route Changes: 14
+#
+# Link Changes: 14
+#
+# Node | Route Changes | Link Changes
+#    0 |            14 |           14
+#    1 |            14 |           14
+#
diff -Naur ns-2.35-orig/dymoum/ns/test/test_sc-2-900-120-400-200 ns-2.35/dymoum/ns/test/test_sc-2-900-120-400-200
--- ns-2.35-orig/dymoum/ns/test/test_sc-2-900-120-400-200	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/test/test_sc-2-900-120-400-200	2006-08-28 19:15:54.000000000 +0200
@@ -0,0 +1,45 @@
+#
+# nodes: 2, pause: 120.00, max speed: 20.00, max x: 400.00, max y: 200.00
+#
+$node_(0) set X_ 322.087960828630
+$node_(0) set Y_ 41.968732031411
+$node_(0) set Z_ 0.000000000000
+$node_(1) set X_ 130.772841815080
+$node_(1) set Y_ 119.859910367723
+$node_(1) set Z_ 0.000000000000
+$god_ set-dist 0 1 1
+$ns_ at 120.000000000000 "$node_(0) setdest 213.112107461160 14.309854846552 15.953089096174"
+$ns_ at 120.000000000000 "$node_(1) setdest 176.244204924161 52.916679626021 7.184368063311"
+$ns_ at 127.047606253077 "$node_(0) setdest 213.112107461160 14.309854846552 0.000000000000"
+$ns_ at 131.264198139781 "$node_(1) setdest 176.244204924161 52.916679626021 0.000000000000"
+$ns_ at 247.047606253077 "$node_(0) setdest 351.269890988278 146.644268488048 8.936791815528"
+$ns_ at 251.264198139781 "$node_(1) setdest 231.087747511047 45.937698836215 3.797542939402"
+$ns_ at 265.822507763473 "$node_(1) setdest 231.087747511047 45.937698836215 0.000000000000"
+$ns_ at 268.454749970647 "$node_(0) setdest 351.269890988278 146.644268488048 0.000000000000"
+$ns_ at 385.822507763473 "$node_(1) setdest 36.346631953516 197.144257697744 13.779854473241"
+$ns_ at 388.454749970647 "$node_(0) setdest 24.304784893849 70.075445430282 7.543530484907"
+$ns_ at 403.714660686749 "$node_(1) setdest 36.346631953516 197.144257697744 0.000000000000"
+$ns_ at 432.971161441807 "$node_(0) setdest 24.304784893849 70.075445430282 0.000000000000"
+$ns_ at 523.714660686750 "$node_(1) setdest 109.859134175512 194.265211421802 13.974908652432"
+$ns_ at 528.979014106572 "$node_(1) setdest 109.859134175513 194.265211421802 0.000000000000"
+$ns_ at 552.971161441807 "$node_(0) setdest 153.890718428714 4.540964855002 8.233150949817"
+$ns_ at 570.608953906792 "$node_(0) setdest 153.890718428714 4.540964855002 0.000000000000"
+$ns_ at 648.979014106572 "$node_(1) setdest 273.341705383518 38.428703367983 13.264505988689"
+$ns_ at 666.006214913658 "$node_(1) setdest 273.341705383517 38.428703367983 0.000000000000"
+$ns_ at 690.608953906792 "$node_(0) setdest 324.421790866119 163.154727997301 5.164756531424"
+$ns_ at 735.701698961598 "$node_(0) setdest 324.421790866119 163.154727997301 0.000000000000"
+$ns_ at 786.006214913658 "$node_(1) setdest 367.362004428007 135.779134473312 2.096671097937"
+$ns_ at 850.556171139949 "$node_(1) setdest 367.362004428007 135.779134473312 0.000000000000"
+$ns_ at 855.701698961598 "$node_(0) setdest 376.482215129840 138.529002902571 6.797173338433"
+$ns_ at 864.174473969532 "$node_(0) setdest 376.482215129841 138.529002902571 0.000000000000"
+#
+# Destination Unreachables: 0
+#
+# Route Changes: 0
+#
+# Link Changes: 0
+#
+# Node | Route Changes | Link Changes
+#    0 |             0 |            0
+#    1 |             0 |            0
+#
diff -Naur ns-2.35-orig/dymoum/ns/test/test_sc-3-900-0-500-100 ns-2.35/dymoum/ns/test/test_sc-3-900-0-500-100
--- ns-2.35-orig/dymoum/ns/test/test_sc-3-900-0-500-100	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/ns/test/test_sc-3-900-0-500-100	2006-08-28 19:15:54.000000000 +0200
@@ -0,0 +1,135 @@
+#
+# nodes: 3, pause: 0.00, max speed: 20.00, max x: 495.00, max y: 95.00
+#
+$node_(0) set X_ 408.790134660282
+$node_(0) set Y_ 79.664095698421
+$node_(0) set Z_ 0.000000000000
+$node_(1) set X_ 237.342860542078
+$node_(1) set Y_ 63.732242606652
+$node_(1) set Z_ 0.000000000000
+$node_(2) set X_ 87.873376008976
+$node_(2) set Y_ 85.300330208258
+$node_(2) set Z_ 0.000000000000
+$ns_ at 0.000000000000 "$node_(0) setdest 346.085847487174 59.559579314290 18.959353515773"
+$ns_ at 0.000000000000 "$node_(1) setdest 366.096074097553 64.462214906966 8.021359222113"
+$ns_ at 0.000000000000 "$node_(2) setdest 398.593215222328 80.511164635262 19.362299211174"
+$god_ set-dist 0 1 1
+$god_ set-dist 0 2 2
+$god_ set-dist 1 2 1
+$ns_ at 1.909360271097 "$god_ set-dist 0 2 1"
+$ns_ at 3.473138276317 "$node_(0) setdest 100.346068067472 7.181560013854 18.774988754931"
+$ns_ at 14.927080693146 "$god_ set-dist 0 2 2"
+$ns_ at 15.797910861543 "$god_ set-dist 0 1 16777215"
+$ns_ at 15.797910861543 "$god_ set-dist 0 2 16777215"
+$ns_ at 16.049578701911 "$node_(2) setdest 11.131010266312 9.540019066614 0.167796629225"
+$ns_ at 16.051554266484 "$node_(1) setdest 320.933965421111 3.301895555759 3.861115873585"
+$ns_ at 16.855826340077 "$node_(0) setdest 310.738692807185 21.709831673802 5.240161705286"
+$ns_ at 19.281449779453 "$god_ set-dist 0 1 1"
+$ns_ at 19.281449779453 "$god_ set-dist 0 2 2"
+$ns_ at 27.584225274317 "$god_ set-dist 0 2 1"
+$ns_ at 35.742139528199 "$node_(1) setdest 278.065731636638 40.891337751038 1.631322577436"
+$ns_ at 57.101462153920 "$node_(0) setdest 81.417161511436 76.853820394165 9.723054934851"
+$ns_ at 70.691993683908 "$node_(1) setdest 338.214709767760 11.466881097320 7.619966292976"
+$ns_ at 75.233707305994 "$god_ set-dist 0 2 2"
+$ns_ at 79.479489613780 "$node_(1) setdest 118.213577232888 88.484590598334 6.643152577285"
+$ns_ at 80.536752441833 "$god_ set-dist 0 1 16777215"
+$ns_ at 80.536752441833 "$god_ set-dist 0 2 16777215"
+$ns_ at 81.359114199953 "$node_(0) setdest 123.928523607816 68.559756069544 12.341279463606"
+$ns_ at 81.494005243485 "$god_ set-dist 0 1 1"
+$ns_ at 81.494005243485 "$god_ set-dist 0 2 2"
+$ns_ at 84.868709888726 "$node_(0) setdest 289.273451816728 40.320117219022 3.360490388931"
+$ns_ at 88.777320382217 "$god_ set-dist 0 2 1"
+$ns_ at 112.243470504957 "$god_ set-dist 1 2 2"
+$ns_ at 114.567158948382 "$node_(1) setdest 456.302936020310 70.771699890148 12.025217167392"
+$ns_ at 115.744222188071 "$god_ set-dist 1 2 1"
+$ns_ at 134.783790938783 "$node_(0) setdest 180.106213889572 56.203003949538 4.946065975535"
+$ns_ at 142.720749480534 "$node_(1) setdest 486.959226843323 47.127270870254 10.361850935795"
+$ns_ at 146.088857276108 "$god_ set-dist 0 1 2"
+$ns_ at 146.457070957714 "$node_(1) setdest 308.276062996923 0.163815273920 19.266566822176"
+$ns_ at 146.809735509794 "$god_ set-dist 0 1 1"
+$ns_ at 156.046316052594 "$node_(1) setdest 345.241064908947 88.558107403826 1.425882395493"
+$ns_ at 157.087698559422 "$node_(0) setdest 490.631025181211 25.671530775651 14.276363926354"
+$ns_ at 178.943555073954 "$node_(0) setdest 287.647604193935 68.281345321452 18.149792560180"
+$ns_ at 190.371095410674 "$node_(0) setdest 21.939223199933 7.179909566981 15.865811361021"
+$ns_ at 201.078679805458 "$god_ set-dist 0 2 2"
+$ns_ at 203.314484173002 "$god_ set-dist 0 1 16777215"
+$ns_ at 203.314484173002 "$god_ set-dist 0 2 16777215"
+$ns_ at 207.555418399863 "$node_(0) setdest 196.058286227082 3.469545541253 8.696541262064"
+$ns_ at 216.901114759080 "$god_ set-dist 0 1 1"
+$ns_ at 216.901114759080 "$god_ set-dist 0 2 2"
+$ns_ at 219.391698478141 "$god_ set-dist 0 2 1"
+$ns_ at 223.241282359727 "$node_(1) setdest 427.681989001076 44.788164936690 15.963777080287"
+$ns_ at 227.581608814499 "$node_(0) setdest 109.210736371072 46.060318490618 8.985115682917"
+$ns_ at 229.088255527272 "$node_(1) setdest 406.805416202528 11.667544621008 9.191128376814"
+$ns_ at 230.934723772122 "$god_ set-dist 0 1 2"
+$ns_ at 233.347914926793 "$node_(1) setdest 27.838725544385 17.345528599776 8.124444435789"
+$ns_ at 237.777774514656 "$god_ set-dist 0 1 16777215"
+$ns_ at 237.777774514656 "$god_ set-dist 0 2 16777215"
+$ns_ at 238.347063112186 "$node_(0) setdest 368.448051601228 23.906112805119 5.829582673626"
+$ns_ at 239.008977768339 "$god_ set-dist 0 1 1"
+$ns_ at 239.008977768339 "$god_ set-dist 0 2 2"
+$ns_ at 239.062270944976 "$god_ set-dist 0 2 1"
+$ns_ at 269.478311857117 "$god_ set-dist 1 2 2"
+$ns_ at 274.718749115147 "$god_ set-dist 0 1 16777215"
+$ns_ at 274.718749115147 "$god_ set-dist 1 2 16777215"
+$ns_ at 279.998393901658 "$node_(1) setdest 99.906316148237 79.405037981050 0.844794040480"
+$ns_ at 282.978428288392 "$node_(0) setdest 400.383914206143 34.175041468909 16.011130211483"
+$ns_ at 285.073610797581 "$node_(0) setdest 274.286318552111 15.661955072472 4.033864070439"
+$ns_ at 310.934906546900 "$god_ set-dist 0 1 1"
+$ns_ at 310.934906546900 "$god_ set-dist 1 2 2"
+$ns_ at 316.668466849379 "$node_(0) setdest 431.314928792069 43.315425474338 7.263998638585"
+$ns_ at 320.706224318412 "$god_ set-dist 0 1 16777215"
+$ns_ at 320.706224318412 "$god_ set-dist 1 2 16777215"
+$ns_ at 338.618494539376 "$node_(0) setdest 280.946591246615 71.664451657842 3.493263411009"
+$ns_ at 367.093364930569 "$god_ set-dist 0 1 1"
+$ns_ at 367.093364930569 "$god_ set-dist 1 2 2"
+$ns_ at 375.862587394715 "$god_ set-dist 1 2 1"
+$ns_ at 382.422042990344 "$node_(0) setdest 441.393662530436 19.136968430944 17.449582714940"
+$ns_ at 386.260383152919 "$god_ set-dist 0 1 2"
+$ns_ at 392.097147462520 "$node_(0) setdest 102.652276448597 66.176492050223 11.000929318413"
+$ns_ at 392.577120678493 "$node_(1) setdest 137.560404254488 4.981722935615 0.900757808089"
+$ns_ at 400.510329543258 "$god_ set-dist 0 1 1"
+$ns_ at 423.184691647202 "$node_(0) setdest 153.986338363997 55.125677689477 17.469583254697"
+$ns_ at 426.190490888405 "$node_(0) setdest 84.845215025778 69.800410744149 15.121223746150"
+$ns_ at 430.864800113029 "$node_(0) setdest 124.156181557217 87.289970069265 0.482699773368"
+$ns_ at 485.173148994211 "$node_(1) setdest 475.501937045344 55.805823600993 2.847016959493"
+$ns_ at 520.000953731940 "$node_(0) setdest 375.372676029223 25.358826025537 5.639533515326"
+$ns_ at 565.880225863076 "$node_(0) setdest 450.122273134867 59.893022513191 11.607073730387"
+$ns_ at 572.974299998413 "$node_(0) setdest 304.604014794490 48.761844791580 11.763226978190"
+$ns_ at 585.381045881126 "$node_(0) setdest 467.896049327072 94.926647139886 7.571387895115"
+$ns_ at 605.208247891626 "$node_(1) setdest 183.509452327845 56.677554505628 7.681144843269"
+$ns_ at 607.793357180051 "$node_(0) setdest 284.543902981126 22.910770182600 12.305314829458"
+$ns_ at 623.801729460236 "$node_(0) setdest 209.823522970149 39.145055979530 9.829464411486"
+$ns_ at 631.580752827539 "$node_(0) setdest 405.200310448805 45.328777716119 11.081637340826"
+$ns_ at 643.222605377398 "$node_(1) setdest 406.924976502870 81.803850224288 14.181225590802"
+$ns_ at 649.220259978228 "$node_(0) setdest 87.376777485332 26.016787729806 6.654113424955"
+$ns_ at 659.076241589299 "$node_(1) setdest 144.404113253359 23.298065478680 1.305222947031"
+$ns_ at 692.391324438836 "$god_ set-dist 0 1 2"
+$ns_ at 697.071822111737 "$node_(0) setdest 316.021291805065 10.618406216062 19.657564100058"
+$ns_ at 698.290799266188 "$god_ set-dist 0 1 1"
+$ns_ at 708.729545276997 "$node_(0) setdest 454.218262293702 0.033438862757 5.509010978479"
+$ns_ at 733.888643204657 "$node_(0) setdest 100.419945914147 39.748375167293 9.955346675290"
+$ns_ at 769.650371156687 "$node_(0) setdest 84.116624647579 68.926015328991 0.853366907104"
+$ns_ at 808.817040121662 "$node_(0) setdest 184.851553173299 79.177763857640 13.177948892352"
+$ns_ at 816.500727736549 "$node_(0) setdest 85.769451302487 21.879149624347 16.036035752738"
+$ns_ at 823.638212014250 "$node_(0) setdest 261.237330284753 43.409156665230 7.514603837169"
+$ns_ at 847.163579455844 "$node_(0) setdest 178.858867027481 79.926669460197 6.752528013784"
+$ns_ at 860.508151957816 "$node_(0) setdest 298.857176229892 47.021917075747 5.812822512599"
+$ns_ at 865.141578475756 "$node_(1) setdest 170.678248787549 46.249480224189 19.517743680554"
+$ns_ at 866.929025171315 "$node_(1) setdest 381.769141552034 85.312776962541 13.183353650881"
+$ns_ at 881.913924896801 "$node_(0) setdest 286.418816919931 0.989358660482 15.230679239142"
+$ns_ at 883.212809288492 "$node_(1) setdest 151.395574488044 85.997805579692 9.587919901658"
+$ns_ at 885.044673454722 "$node_(0) setdest 438.046589792634 89.833877200830 12.538976908686"
+$ns_ at 899.060121615148 "$node_(0) setdest 166.793781491720 88.480269292811 7.288550589238"
+#
+# Destination Unreachables: 12
+#
+# Route Changes: 43
+#
+# Link Changes: 31
+#
+# Node | Route Changes | Link Changes
+#    0 |            35 |           27
+#    1 |            27 |           22
+#    2 |            24 |           13
+#
diff -Naur ns-2.35-orig/dymoum/pending_rreq.c ns-2.35/dymoum/pending_rreq.c
--- ns-2.35-orig/dymoum/pending_rreq.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/pending_rreq.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,79 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#include <errno.h>
+#else
+#include "debug.h"
+#include "defs.h"
+#include "pending_rreq.h"
+
+#include <stdlib.h>
+#include <errno.h>
+
+static DLIST_HEAD(PENDING_RREQ);
+#endif	/* NS_PORT */
+
+pending_rreq_t *NS_CLASS pending_rreq_add(struct in_addr dest_addr, u_int32_t seqnum)
+{
+	pending_rreq_t *entry;
+	
+	if ((entry = (pending_rreq_t *)malloc(sizeof(pending_rreq_t))) == NULL)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "failed malloc()");
+		exit(EXIT_FAILURE);
+	}
+	
+	entry->dest_addr.s_addr	= dest_addr.s_addr;
+	entry->seqnum		= seqnum;
+	entry->tries		= 0;
+	
+	dlist_add(&entry->list_head, &PENDING_RREQ);
+	
+	return entry;
+}
+
+int NS_CLASS pending_rreq_remove(pending_rreq_t *entry)
+{
+	if (!entry)
+		return 0;
+	
+	dlist_del(&entry->list_head);
+	timer_remove(&entry->timer);
+	
+	free(entry);
+	
+	return 1;
+}
+
+pending_rreq_t *NS_CLASS pending_rreq_find(struct in_addr dest_addr)
+{
+	dlist_head_t *pos;
+	
+	dlist_for_each(pos, &PENDING_RREQ)
+	{
+		pending_rreq_t *entry = (pending_rreq_t *) pos;
+		if (entry->dest_addr.s_addr == dest_addr.s_addr)
+			return entry;
+	}
+	
+	return NULL;
+}
diff -Naur ns-2.35-orig/dymoum/pending_rreq.h ns-2.35/dymoum/pending_rreq.h
--- ns-2.35-orig/dymoum/pending_rreq.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/pending_rreq.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,60 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __PENDING_RREQ_H__
+#define __PENDING_RREQ_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include "defs.h"
+#include "dlist.h"
+#include "timer_queue.h"
+
+#include <netinet/in.h>
+#include <sys/types.h>
+
+/* Here we maintain a list of those RREQs which haven't been answered with a
+   RREP yet */
+
+typedef struct pending_rreq
+{
+	dlist_head_t	list_head;
+	struct in_addr	dest_addr;
+	u_int32_t	seqnum;
+	u_int8_t	tries;
+	struct timer	timer;
+} pending_rreq_t;
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Add a new entry to the list */
+pending_rreq_t *pending_rreq_add(struct in_addr dest_addr, u_int32_t seqnum);
+
+/* Remove an entry from the list */
+int pending_rreq_remove(pending_rreq_t *entry);
+
+/* Find an entry in the list with the given destination address */
+pending_rreq_t *pending_rreq_find(struct in_addr dest_addr);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __PENDING_RREQ_H__ */
diff -Naur ns-2.35-orig/dymoum/README ns-2.35/dymoum/README
--- ns-2.35-orig/dymoum/README	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/README	2006-08-31 17:54:28.000000000 +0200
@@ -0,0 +1,258 @@
+DYMOUM 'README' file
+
+
+This information is also available from our MASIMUM website. On-line version
+could be more updated than this, check it at:
+
+                   http://masimum.inf.um.es/?Software:DYMOUM
+
+
+==============
+ Introduction
+==============
+
+DYMOUM is an implementation of the DYMO (Dynamic Manet On-demand) routing
+protocol both for Linux kernels and the ns2 network simulator. The code is
+released under the terms of the GNU General Public License (GPL).
+
+Linux and ns2 versions use almost the same code, which has been written in C
+and C++ programming languages. Linux version runs as a user space daemon which
+communicates with kernel space via netlink sockets. Only a little module is
+needed to be run in kernel space. User's kernel must have Netfilter support to
+run DYMOUM. Our code is inspired on AODVUU, a well-known AODV implementation
+for Linux and ns2.
+
+DYMOUM has been succesfully tested on real (but simple) ad hoc scenarios as
+well as on the ns2 network simulator.
+
+
+==============
+   Features
+==============
+
+* IPv4 only
+* Highly compliant with latest DYMO spec
+* Linux version
+      o Kernels 2.4 and 2.6 support
+      o Multiple network interfaces support
+      o Configurable from command line parameters
+      o Debug information through syslog and /proc systems
+   
+* ns2 version
+      o Support for latest ns2 releases
+      o MAC layer feedback support
+      o Configurable from TCL scripts
+      o Debug information
+
+
+==============
+ Installation
+==============
+
+---------------
+ Linux version
+---------------
+
+To install DYMOUM you need to have the source code of your installed kernel.
+The kernel must have Netfilter support (this is enabled by default in most
+Linux distributions; if your kernel has this feature disabled, you'll need to
+recompile it).
+
+Download the latest DYMOUM version from SourceForge.net
+(http://sourceforge.net/projects/dymoum/). Then execute the followings steps
+(substitute "0.1" for the version number of the software you have downloaded):
+
+$ tar zxvf dymoum-0.1.tgz
+$ cd dymoum-0.1
+$ make
+$ make install   # as root
+
+---------------
+  ns2 version
+---------------
+
+We assume that you have downloaded and unpackaged the allinone distribution of
+ns2 (any of the versions supported by DYMOUM). Copy dymoum-0.1.tgz to
+ns-allinone-2.28/ns-2.28/ (change "2.28" to your ns version number), and then
+do:
+
+$ cd ns-allinone-2.28/ns-2.28/
+$ tar zxvf dymoum-0.1.tgz
+$ ln -s ./dymoum-0.1 ./dymoum
+$ patch -p1 < dymoum/dymoum_ns-2.28_v0.1.patch
+
+If you haven't installed ns2 yet, then do the following:
+
+$ cd ..
+$ ./install
+
+On the other hand, if you are installing DYMOUM on a running installation of
+ns2:
+
+$ ./configure
+$ make distclean
+$ ./configure
+$ make
+
+NOTE: code should work on previous versions of ns2, but only patches for the
+latest ones are provided.
+
+
+==============
+    Using
+==============
+
+Before you learn how to use and configure DYMOUM, let's take a look to its
+default configuration.
+
+Path accumulation is enabled by default. This means that a node appends its own
+routing information to every RE it forwards. Hopefully this may avoid future
+route discoveries. However, the latest DYMO drafts advise not to activate this
+option unless there is an administrative decision behind. So, you could be
+interested in disabling this behavior following instructions in following
+subsections.
+
+When a route discovery fails (a RREQ is sent but no RREP is received), DYMOUM
+inmediately considers that there is no such route. This default behavior may be
+changed in order to retry a fixed number of route discoveries following a
+binary exponential backoff algorithm (see latest specs for further information).
+
+---------------
+ Linux version
+---------------
+
+By compiling and installing the software you get two different objects: an
+executable file called dymod which runs in user space, and a loadable kernel
+module called kdymo{.o|.ko} which deals with kernel space operations. You only
+need to launch dymod to get DYMOUM running.
+
+To get a full list of options supported by DYMOUM, execute (always as root):
+
+$ dymod -h   # or, alternatively...
+$ dymod --help
+
+Let's see some common invocations of DYMOUM. To execute the protocol on
+interface wlan0 just type:
+
+$ dymod -i wlan0
+
+If we are interested in several network interfaces, we just have to indicate
+them with a comma-separated list. See next example, where we also want to
+reissue RREQs following an exponential backoff algorithm when the first route
+discovery fails:
+
+$ dymod -r -i wlan0,eth1
+
+To put the software in daemon mode use the following command:
+
+$ dymod -d -i wlan0,wlan1
+
+Next invocation disables the path accumulation feature and enables the verbose
+mode, where lot of debugging information is generated:
+
+$ dymod -v -n -i eth1
+
+You can also avoid unidirectional links if nodes blacklist the neighbors which
+didn't send a unicast packet (ICMP ECHOREPLY messages are used within this
+implementation) when the S-bit of the DYMO header is set. To set the S-bit:
+
+$ dymod -s -i wlan0
+
+To monitor the link status with the neighbors, you must specify the interval at
+which HELLO messages are sent out:
+
+$ dymod -m 1 -i eth0
+
+Debug information is generated via syslog subsystem. Depending on your syslog
+configuration, dymod messages may be directed to /var/log/daemon.log,
+/var/log/syslog or something like that. If DYMOUM is not executed in daemon
+mode and verbose output is enabled, then debugging messages are also printed
+out to stderr.
+
+From /proc subsystem you can also obtain a little bit of information regarding
+the loadable kernel module execution. On file /proc/net/kdymo (or something
+similar, depending on your configuration) you will find the number of packet
+drops and the current number of data packets inside the queue.
+
+---------------
+  ns2 version
+---------------
+
+DYMOUM can be used like any other routing agent in ns2, so you can use
+node-config command to attach our routing agent to the mobile nodes which are
+to be created:
+
+$ns_ node-config -adhocRouting DYMOUM
+
+After creating your mobile nodes, now you can configure each DYMOUM routing
+agent individually or all at once. But first we'll see the configuration
+options of DYMOUM:
+
+    * debug_        : Print debugging messages on stdout
+    * no_path_acc_  : Disable path accumulation
+    * reissue_rreq_ : Try more route discoveries when it fails the first time
+    * s_bit_        : Set S-bit of DYMO header
+    * hello_ival_   : Specify the interval between HELLO messages. If set to 0
+                      or not indicated, neighborhood monitoring is performed
+                      via link layer feedback
+
+To configure all agents, put sentences like these:
+
+Agent/DYMOUM set debug_ true
+Agent/DYMOUM set reissue_rreq_ false
+Agent/DYMOUM set hello_ival_ 1
+
+To configure a single agent:
+
+set ra [$mobilenode agent 255]
+$ra set reissue_rreq_ true
+$ra set no_path_acc_ true
+
+Once you have performed your simulations, you get a trace file where you can
+see what happened during the execution. Let's see with some examples the format
+of the traces generated by DYMOUM. Following examples use the classic notation
+of ns2 trace files. However, tagged and new trace formats are also supported.
+
+s 6.053808264 _15_ RTR  --- 1 DYMOUM 48 [0 0 0 0] ------- [15:255 -1:255 1 0]
+        [ RE 0 0 28 10 0 1 21 0 0 [0 0 0 15 2] ]
+
+The line above indicates that node 15 is sending a DYMOUM packet (size of 48
+bytes) with a RE message. Specific information about the DYMOUM message is in
+the end of the line (from "RE" to the end): m bit, h bits, length, ttl, i bit,
+a bit, target address, target sequence number and thopcnt. Inside the final
+brackets there is a routing block with the following fields: g bit, prefix, hop
+count, node address and node sequence number. When path accumulation is
+enabled, more than one of these blocks are appended to the RE.
+
+r 10.712966365 _2_ RTR  --- 249 DYMOUM 32 [0 ffffffff 11 800] -------
+        [17:255 -1:255 1 0] [ RERR 0 0 12 10 0 [32 3] ]
+
+Now node 2 is receiving a RERR with following fields: m bit, h bits, length,
+ttl and i bit. The latest block inside the brackets contains: unode address and
+unode sequence number.
+
+s 10.007533000 _1_ RTR  --- 4 DYMOUM 28 [0 0 0 0] ------- [1:255 2:255 1 2]
+[ ECHOREPLY 8 ]
+
+When the S-bit is set in a reply (RE with A-bit disabled), the receiving node
+must send a unicast packet to the sender. This implementation uses ICMP
+ECHOREPLY messages, but for convenience we include these messages as if they
+were part of the DYMO protocol. The line above shows how node 1 is sending a
+ECHOREPLY with 8 bytes of length.
+
+
+UERR messages should not be generated right now because all message types are
+supported. Anyway, they would look like:
+
+UERR m h len target_address uelem_target_address uerr_node_address uelem_type
+
+
+==============
+   Author(s)
+==============
+
+Please send any comment or bug report to:
+
+* Francisco J. Ros <fjrm@dif.um.es>. Project administrator and main
+  developer.
+
diff -Naur ns-2.35-orig/dymoum/rtable.c ns-2.35/dymoum/rtable.c
--- ns-2.35-orig/dymoum/rtable.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/rtable.c	2006-08-29 19:52:20.000000000 +0200
@@ -0,0 +1,269 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "rtable.h"
+#include "defs.h"
+#include "debug.h"
+#include "k_route.h"
+#include "pending_rreq.h"
+#include "dymo_timeout.h"
+#include "dymo_netlink.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#endif	/* NS_PORT */
+
+void NS_CLASS rtable_init()
+{
+	INIT_DLIST_HEAD(&rtable.l);
+}
+
+void NS_CLASS rtable_destroy()
+{
+	dlist_head_t *pos, *tmp;
+	
+	dlist_for_each_safe(pos, tmp, &rtable.l)
+	{
+		rtable_entry_t *e = (rtable_entry_t *) pos;
+		rtable_delete(e);
+	}
+}
+
+rtable_entry_t *NS_CLASS rtable_find(struct in_addr dest_addr)
+{
+	dlist_head_t *pos;
+	
+	dlist_for_each(pos, &rtable.l)
+	{
+		rtable_entry_t *e = (rtable_entry_t *) pos;
+		if (e->rt_dest_addr.s_addr == dest_addr.s_addr)
+			return e;
+	}
+	return NULL;
+}
+
+rtable_entry_t *NS_CLASS rtable_insert(struct in_addr dest_addr,
+			struct in_addr nxthop_addr,
+			u_int32_t ifindex,
+			u_int32_t seqnum,
+			u_int8_t prefix,
+			u_int8_t hopcnt,
+			u_int8_t is_gw)
+{
+	rtable_entry_t *entry;
+	struct in_addr netmask;
+	
+	// Create the new entry
+	if ((entry = (rtable_entry_t *) malloc(sizeof(rtable_entry_t)))
+		== NULL)
+	{
+		dlog(LOG_ERR, errno, __FUNCTION__, "malloc() failed");
+		exit(EXIT_FAILURE);
+	}
+	memset(entry, 0, sizeof(rtable_entry_t));
+	
+	entry->rt_ifindex	= ifindex;
+	entry->rt_seqnum	= seqnum;
+	entry->rt_prefix	= prefix;
+	entry->rt_hopcnt	= hopcnt;
+	entry->rt_is_gw		= is_gw;
+	entry->rt_is_used	= 0;
+	entry->rt_state		= RT_VALID;
+	netmask.s_addr		= 0;
+	entry->rt_dest_addr.s_addr	= dest_addr.s_addr;
+	entry->rt_nxthop_addr.s_addr	= nxthop_addr.s_addr;
+	
+	timer_init(&entry->rt_validtimer, &NS_CLASS route_valid_timeout, entry);
+	timer_set_timeout(&entry->rt_validtimer, ROUTE_TIMEOUT);
+	timer_add(&entry->rt_validtimer);
+	
+	timer_init(&entry->rt_deltimer, &NS_CLASS route_del_timeout, entry);
+	/*timer_set_timeout(&entry->rt_deltimer, ROUTE_DELETE_TIMEOUT);
+	timer_add(&entry->rt_deltimer);*/
+	
+	// Add the entry to the routing table
+	dlist_add(&entry->l, &rtable.l);
+
+#ifndef NS_PORT
+	// Add route to kernel routing table
+	if (k_add_rte(dest_addr, nxthop_addr, netmask, hopcnt, ifindex) < 0)
+		dlog(LOG_WARNING, errno, __FUNCTION__,
+		"could not add kernel route");
+	netlink_add_route(dest_addr);
+#endif	/* NS_PORT */
+	
+	// If there are buffered packets for this destination
+	// now we send them
+	if (pending_rreq_remove(pending_rreq_find(dest_addr)))
+	{
+#ifdef NS_PORT
+		packet_queue_set_verdict(dest_addr, PQ_SEND);
+#endif	/* NS_PORT */
+	}
+	
+	return entry;
+}
+
+rtable_entry_t *NS_CLASS rtable_update(rtable_entry_t *entry,
+			struct in_addr dest_addr,
+			struct in_addr nxthop_addr,
+			u_int32_t ifindex,
+			u_int32_t seqnum,
+			u_int8_t prefix,
+			u_int8_t hopcnt,
+			u_int8_t is_gw)
+{
+#ifndef NS_PORT
+	struct in_addr netmask;
+	
+	netmask.s_addr = 0;
+	
+	// If this route was expired but it isn't now,
+	// a new kernel route is added
+	//if (!timer_is_queued(&entry->rt_validtimer))
+	if (entry->rt_state == RT_INVALID)
+	{
+		if (k_add_rte(dest_addr, nxthop_addr, netmask, hopcnt, ifindex) < 0)
+			dlog(LOG_WARNING, errno, __FUNCTION__,
+			"could not add kernel route");
+		netlink_add_route(dest_addr);
+	}
+	// Else the kernel route is updated
+	else
+	{
+		if (k_chg_rte(dest_addr, nxthop_addr, netmask, hopcnt, ifindex) < 0)
+			dlog(LOG_WARNING, errno, __FUNCTION__,
+			"could not add kernel route");
+		netlink_add_route(dest_addr);
+	}
+#endif	/* NS_PORT */
+	
+	entry->rt_ifindex	= ifindex;
+	entry->rt_seqnum	= seqnum;
+	entry->rt_prefix	= prefix;
+	entry->rt_hopcnt	= hopcnt;
+	entry->rt_is_gw		= is_gw;
+	entry->rt_state		= RT_VALID;
+	entry->rt_dest_addr.s_addr	= dest_addr.s_addr;
+	entry->rt_nxthop_addr.s_addr	= nxthop_addr.s_addr;
+	
+	timer_set_timeout(&entry->rt_validtimer, ROUTE_TIMEOUT);
+	timer_add(&entry->rt_validtimer);
+	
+	/*timer_set_timeout(&entry->rt_deltimer, ROUTE_DELETE_TIMEOUT);
+	timer_add(&entry->rt_deltimer);*/
+	timer_remove(&entry->rt_deltimer);
+	
+	// If there are buffered packets for this destination
+	// now we send them
+	if (pending_rreq_remove(pending_rreq_find(dest_addr)))
+	{
+#ifdef NS_PORT
+		packet_queue_set_verdict(dest_addr, PQ_SEND);
+#endif	/* NS_PORT */
+	}
+	
+	return entry;
+}
+
+void NS_CLASS rtable_delete(rtable_entry_t *entry)
+{
+	if (!entry)
+		return;
+	
+	dlist_del(&entry->l);
+	
+	free(entry);
+}
+
+void NS_CLASS rtable_invalidate(rtable_entry_t *entry)
+{
+	if (!entry)
+		return;
+	
+#ifndef NS_PORT
+	//if (timer_is_queued(&entry->rt_validtimer))
+	if (entry->rt_state == RT_VALID)
+	{
+		if (k_del_rte(entry->rt_dest_addr) < 0)
+			dlog(LOG_WARNING, errno, __FUNCTION__,
+			"could not delete kernel route");
+		netlink_del_route(entry->rt_dest_addr);
+	}
+#endif	/* NS_PORT */
+	
+	entry->rt_state = RT_INVALID;
+	
+	timer_set_timeout(&entry->rt_deltimer, ROUTE_DELETE_TIMEOUT);
+	timer_add(&entry->rt_deltimer);
+}
+
+int NS_CLASS rtable_update_timeout(rtable_entry_t *entry)
+{
+	if (entry && entry->rt_state == RT_VALID) // this comparison seems ok
+	{
+		timer_set_timeout(&entry->rt_validtimer, ROUTE_TIMEOUT);
+		timer_add(&entry->rt_validtimer);
+		
+		/*timer_set_timeout(&entry->rt_deltimer, ROUTE_DELETE_TIMEOUT);
+		timer_add(&entry->rt_deltimer);*/
+		
+		// Mark the entry as used
+		entry->rt_is_used = 1;
+		
+		return 1;
+	}
+	return 0;
+}
+
+int NS_CLASS rtable_expire_timeout(rtable_entry_t *entry)
+{
+	if (!entry)
+		return 0;
+	
+	timer_set_timeout(&entry->rt_validtimer, 0);
+	timer_add(&entry->rt_validtimer);
+	
+	return 1;
+}
+
+int NS_CLASS rtable_expire_timeout_all(struct in_addr nxthop_addr, u_int32_t ifindex)
+{
+	dlist_head_t *pos;
+	int count = 0;
+	
+	dlist_for_each(pos, &rtable.l)
+	{
+		rtable_entry_t *entry = (rtable_entry_t *) pos;
+		if (entry->rt_nxthop_addr.s_addr == nxthop_addr.s_addr &&
+			entry->rt_ifindex == ifindex)
+			count += rtable_expire_timeout(entry);
+	}
+	
+	return count;
+}
diff -Naur ns-2.35-orig/dymoum/rtable.h ns-2.35/dymoum/rtable.h
--- ns-2.35-orig/dymoum/rtable.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/rtable.h	2006-08-28 19:57:02.000000000 +0200
@@ -0,0 +1,107 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __RTABLE_H__
+#define __RTABLE_H__
+
+#ifndef NS_NO_GLOBALS
+
+#include "defs.h"
+#include "dlist.h"
+#include "timer_queue.h"
+
+#include <sys/types.h>
+#include <netinet/in.h>
+
+#define ROUTE_TIMEOUT		3000
+#define ROUTE_DELETE_TIMEOUT	(5 * ROUTE_TIMEOUT)
+
+#define RT_INVALID	0
+#define RT_VALID	1
+
+/* Routing table entry type */
+typedef struct rt_entry {
+	dlist_head_t	l;
+	struct in_addr	rt_dest_addr;
+	struct in_addr	rt_nxthop_addr;
+	struct timer	rt_deltimer;
+	struct timer	rt_validtimer;
+	u_int32_t	rt_ifindex;
+	u_int32_t	rt_seqnum;
+	u_int8_t	rt_prefix;
+	u_int8_t	rt_hopcnt;
+	u_int8_t	rt_is_gw;
+	u_int8_t	rt_is_used : 4;
+	u_int8_t	rt_state : 4;
+} rtable_entry_t;
+
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+
+/* Routing table */
+rtable_entry_t rtable;
+
+/* Initialize routing table */
+void rtable_init();
+
+/* Destroy routing table */
+void rtable_destroy();
+
+/* Find an routing entry given the destination address */
+rtable_entry_t *rtable_find(struct in_addr dest_addr);
+
+/* Insert a new entry */
+rtable_entry_t *rtable_insert(struct in_addr dest_addr,
+			struct in_addr nxthop_addr,
+			u_int32_t ifindex,
+			u_int32_t seqnum,
+			u_int8_t prefix,
+			u_int8_t hopcnt,
+			u_int8_t is_gw);
+
+/* Update an existing entry */
+rtable_entry_t *rtable_update(rtable_entry_t *entry,
+			struct in_addr dest_addr,
+			struct in_addr nxthop_addr,
+			u_int32_t  ifindex,
+			u_int32_t seqnum,
+			u_int8_t prefix,
+			u_int8_t hopcnt,
+			u_int8_t is_gw);
+
+/* Delete an entry */
+void rtable_delete(rtable_entry_t *entry);
+
+/* Mark an entry as invalid and schedule its deletion */
+void rtable_invalidate(rtable_entry_t *entry);
+
+/* Update the timeout of a valid entry */
+int rtable_update_timeout(rtable_entry_t *entry);
+
+/* Expire the timeout of a valid entry */
+int rtable_expire_timeout(rtable_entry_t *entry);
+
+/* Expire all entries which use the given next hop and interface */
+int rtable_expire_timeout_all(struct in_addr nxthop_addr, u_int32_t ifindex);
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __RTABLE_H__ */
diff -Naur ns-2.35-orig/dymoum/timer_queue.c ns-2.35/dymoum/timer_queue.c
--- ns-2.35-orig/dymoum/timer_queue.c	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/timer_queue.c	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,166 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef NS_PORT
+#include "ns/dymo_um.h"
+#else
+#include "timer_queue.h"
+
+#include <time.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+static DLIST_HEAD(TQ);
+#endif	/* NS_PORT */
+
+int NS_CLASS timer_init(struct timer *t, timeout_func_t f, void *data)
+{
+	// Sanity check
+	if (t)
+	{
+		INIT_DLIST_ELEM(&t->list_head);
+		t->used		= 0;
+		t->handler	= f;
+		t->data		= data;
+		t->timeout.tv_sec	= 0;
+		t->timeout.tv_usec	= 0;
+		
+		return 0;
+	}
+	return -1;
+}
+
+int NS_CLASS timer_is_queued(struct timer *t)
+{
+	if (t)
+		return !dlist_unattached(&t->list_head);
+	return 0;
+}
+
+int NS_CLASS timer_add(struct timer *t)
+{
+	dlist_head_t *pos;
+	
+	// Sanity checks
+	if (!t || !t->handler)
+		return -1;
+	
+	// If the timer is already in the queue we firstly remove it
+	if (t->used)
+		timer_remove(t);
+	t->used = 1;
+	
+	// Add the timer
+	if (dlist_empty(&TQ))
+		return dlist_add(&t->list_head, &TQ);
+	else
+	{
+		dlist_for_each(pos, &TQ)
+		{
+			struct timer *curr = (struct timer *) pos;
+			if (timeval_diff(&t->timeout, &curr->timeout) < 0)
+				break;
+		}
+		return dlist_add(&t->list_head, pos->prev);
+	}
+}
+
+int NS_CLASS timer_remove(struct timer *t)
+{
+	// Sanity check
+	if (!t)
+		return -1;
+	
+	t->used = 0;
+	
+	if (dlist_unattached(&t->list_head))
+		return 0;
+	else
+		return dlist_del(&t->list_head);
+}
+
+int NS_CLASS timer_set_timeout(struct timer *t, long msec)
+{
+	// Sanity checks
+	if (!t || msec < 0)
+		return -1;
+	
+	gettimeofday(&t->timeout, NULL);
+	
+	t->timeout.tv_usec += msec * 1000;
+	t->timeout.tv_sec += t->timeout.tv_usec / 1000000;
+	t->timeout.tv_usec = t->timeout.tv_usec % 1000000;
+	
+	return 0;
+}
+
+void NS_CLASS timer_timeout(struct timeval *now)
+{
+	dlist_head_t *pos, *tmp;
+	
+	dlist_for_each_safe(pos, tmp, &TQ)
+	{
+		struct timer *t = (struct timer *) pos;
+		
+		if (timeval_diff(&t->timeout, now) > 0)
+			break;
+		else
+		{
+			t->used = 0;
+			dlist_del(&t->list_head);
+			if (t->handler)
+#ifdef NS_PORT
+				(this->*t->handler)(t->data);
+#else
+				t->handler(t->data);
+#endif	/* NS_PORT */
+		}
+	}
+}
+
+struct timeval *NS_CLASS timer_age_queue()
+{
+	static struct timeval remaining;
+	struct timeval now;
+	struct timer *t;
+	
+	gettimeofday(&now, NULL);
+	
+	if (dlist_empty(&TQ))
+		return NULL;
+	
+	timer_timeout(&now);
+	
+	if (dlist_empty(&TQ))
+		return NULL;
+	
+	t = (struct timer *) TQ.next;
+	remaining.tv_usec	= (t->timeout.tv_usec - now.tv_usec);
+	remaining.tv_sec	= (t->timeout.tv_sec - now.tv_sec);
+	
+	if (remaining.tv_usec < 0)
+	{
+		remaining.tv_usec += 1000000;
+		remaining.tv_sec -= 1;
+	}
+	
+	return (&remaining);
+}
diff -Naur ns-2.35-orig/dymoum/timer_queue.h ns-2.35/dymoum/timer_queue.h
--- ns-2.35-orig/dymoum/timer_queue.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/timer_queue.h	2006-08-28 19:14:50.000000000 +0200
@@ -0,0 +1,84 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Francisco J. Ros                                *
+ *   fjrm@dif.um.es                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __TIMER_QUEUE_H__
+#define __TIMER_QUEUE_H__
+
+#ifndef NS_NO_GLOBALS
+#include "defs.h"
+#include "dlist.h"
+
+#include <sys/time.h>
+
+
+typedef void (NS_CLASS*timeout_func_t) (void *);
+
+struct timer
+{
+	dlist_head_t	list_head;
+	int		used;
+	struct timeval	timeout;
+	timeout_func_t	handler;
+	void		*data;
+};
+
+NS_STATIC NS_INLINE long timeval_diff(struct timeval *t1, struct timeval *t2)
+{
+	long long res;
+	
+	// Sanity check
+	if (t1 && t2)
+	{
+		res = t1->tv_sec;
+		res = ((res - t2->tv_sec) * 1000000 + t1->tv_usec - t2->tv_usec) / 1000;
+		return (long) res;
+	}
+	return -1;
+}
+#endif	/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+/* This should be called for every newly allocated timer */
+int timer_init(struct timer *t, timeout_func_t f, void *data);
+
+/* Check whether a timer is queued or not */
+int timer_is_queued(struct timer *t);
+
+/* Add a new timer timer to the queue (lower to higher timeout order) */
+int timer_add(struct timer *t);
+
+/* Remove a timer from the queue */
+int timer_remove(struct timer *t);
+
+/* Set the timer to timeout msec miliseconds in the future. The timer is not
+   enqueued (you must call timer_add() if you need it) */
+int timer_set_timeout(struct timer *t, long msec);
+
+/* Execute all expired timers and remove them from the queue */
+void timer_timeout(struct timeval *now);
+
+/* This function must be called by the main loop. It calls timer_timeout()
+   and returns the remaining time until the next scheduled timeout in the
+   queue */
+struct timeval *timer_age_queue();
+
+#endif	/* NS_NO_DECLARATIONS */
+
+#endif	/* __TIMER_QUEUE_H__ */
diff -Naur ns-2.35-orig/dymoum/TODO ns-2.35/dymoum/TODO
--- ns-2.35-orig/dymoum/TODO	1970-01-01 01:00:00.000000000 +0100
+++ ns-2.35/dymoum/TODO	2006-08-29 19:54:46.000000000 +0200
@@ -0,0 +1,23 @@
+==================
+ DYMOUM TODO List 
+==================
+
+
+* Currently the implementation only allows one message on a DYMO packet. When
+  supporting multiple messages we'll need to complete (at least)
+  dymo_generic.c::generic_process_message() and
+  dymo_generic.h::generic_postprocess().
+
+* Change the packet format to the new generic packetbb spec.
+
+* Prefix and gateway stuff is not supported right now. Thus,
+  rtable.c::rtable_find(addr) does not perform longest-prefix matching yet.
+
+* Change routing table data type from a double linked list to a hash table.
+
+* Actions after sequence number loss. Maybe this isn't needed or it isn't very
+  important in our case.
+
+
+ Francisco J. Ros      <fjrm@dif.um.es>
+ University of Murcia  (Spain)
diff -Naur ns-2.35-orig/Makefile.in ns-2.35/Makefile.in
--- ns-2.35-orig/Makefile.in	2014-10-18 01:50:36.000000000 +0200
+++ ns-2.35/Makefile.in	2017-04-01 01:53:15.303339584 +0200
@@ -53,13 +53,18 @@
 # for diffusion
 #DIFF_INCLUDES = "./diffusion3/main ./diffusion3/lib ./diffusion3/nr ./diffusion3/ns"
 
+# DYMO_UM
+DYMO_UM_DIR=dymoum
+DYMO_UM_LIB=libdymoum.a
+ 
+
 CCOPT	= @V_CCOPT@ 
 STATIC	= @V_STATIC@
 #LDFLAGS	= $(STATIC)
 LDFLAGS	= @LDFLAGS@ 
 LDOUT	= -o $(BLANK)
 
-DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
+DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DDYMO_UM -DNS_PORT -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
 
 INCLUDES = \
 	-I. @V_INCLUDE_X11@ \
@@ -72,14 +77,17 @@
 	-I./diffusion3/lib/nr -I./diffusion3/ns \
 	-I./diffusion3/filter_core -I./asim/ -I./qs \
 	-I./diffserv -I./satellite \
-	-I./wpan
+	-I./wpan \
+	-I./$(DYMO_UM_DIR)
 
 
 LIB	= \
 	@V_LIBS@ \
 	@V_LIB_X11@ \
 	@V_LIB@ \
-	-lm @LIBS@
+	-lm @LIBS@ \
+	-L$(DYMO_UM_DIR) \
+     	-ldymoum
 #	-L@libdir@ \
 
 CFLAGS	+= $(CCOPT) $(DEFINE) 
@@ -398,10 +406,21 @@
 
 all: $(NS) $(BUILD_NSE) $(NSTK) all-recursive Makefile
 
+# DYMO_UM
+$(DYMO_UM_DIR)/$(DYMO_UM_LIB):
+	cd $(DYMO_UM_DIR) && $(MAKE) $(DYMO_UM_LIB) NS_DEFS='$(DEFINE)' OPTS='$(CCOPT)' NS_INC='$(subst -I.,-I$(shell pwd),$(INCLUDES))'
+
+dymo_um_clean:
+	cd $(DYMO_UM_DIR) && $(MAKE) clean
+
 
 all-recursive:
 	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) all; ) done
 
+# DYMO_UM
+$(NS):	$(DYMO_UM_DIR)/$(DYMO_UM_LIB) $(OBJ) common/tclAppInit.o 
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ \
+  		common/tclAppInit.o $(OBJ) $(LIB)
 
 
 
@@ -560,12 +579,17 @@
 install-recursive: force
 	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) install; ) done
 
+# DYMO_UM
+clean: dymo_um_clean
+
 clean: clean-recursive
 	$(RM) $(CLEANFILES)
 
 clean-recursive:
 	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) clean; ) done
 
+
+
 AUTOCONF_GEN = tcl/lib/ns-autoconf.tcl
 distclean: distclean-recursive
 	$(RM) $(CLEANFILES) Makefile config.cache config.log config.status \
diff -Naur ns-2.35-orig/queue/priqueue.cc ns-2.35/queue/priqueue.cc
--- ns-2.35-orig/queue/priqueue.cc	2010-05-10 00:28:41.000000000 +0200
+++ ns-2.35/queue/priqueue.cc	2017-04-01 02:00:52.226680403 +0200
@@ -92,6 +92,9 @@
                 case PT_AODV:
 		case PT_AOMDV:
 		case PT_MDART:
+		#ifdef DYMO_UM
+		case PT_DYMOUM:
+	    #endif  /* DYMO_UM */
 			recvHighPriority(p, h);
                         break;
 
diff -Naur ns-2.35-orig/tcl/lib/ns-agent.tcl ns-2.35/tcl/lib/ns-agent.tcl
--- ns-2.35-orig/tcl/lib/ns-agent.tcl	2009-01-15 07:23:49.000000000 +0100
+++ ns-2.35/tcl/lib/ns-agent.tcl	2017-04-01 01:47:30.412889119 +0200
@@ -192,8 +192,20 @@
 Agent/AODV set sport_   0
 Agent/AODV set dport_   0
 
+
+Agent/DYMOUM instproc init args {
+
+        $self next $args
+}
+
+Agent/DYMOUM set sport_ 0
+Agent/DYMOUM set dport_ 0
+
+
 # AOMDV patch
 Agent/AOMDV set sport_   0
 Agent/AOMDV set dport_   0
 Agent/AOMDV set aomdv_prim_alt_path_len_diff_ 1
 Agent/AOMDV set aomdv_max_paths_ 3
+
+
diff -Naur ns-2.35-orig/tcl/lib/ns-default.tcl ns-2.35/tcl/lib/ns-default.tcl
--- ns-2.35-orig/tcl/lib/ns-default.tcl	2010-07-04 00:45:45.000000000 +0200
+++ ns-2.35/tcl/lib/ns-default.tcl	2017-04-01 01:47:30.412889119 +0200
@@ -1576,6 +1576,12 @@
 Agent/DCCP/TFRC set r_p_ 0.0
 Agent/DCCP/TFRC set q_min_t_ 0.2
 
+# DYMO_UM routing agent
+Agent/DYMOUM set no_path_acc_ false
+Agent/DYMOUM set reissue_rreq_ false
+Agent/DYMOUM set s_bit_ false
+Agent/DYMOUM set hello_ival_ 0
+
 Agent/TCP/Linux set rtxcur_init_ 3
 Agent/TCP/Linux set maxrto_ 120
 Agent/TCP/Linux set minrto_ 0.2
diff -Naur ns-2.35-orig/tcl/lib/ns-lib.tcl ns-2.35/tcl/lib/ns-lib.tcl
--- ns-2.35-orig/tcl/lib/ns-lib.tcl	2010-05-10 00:28:41.000000000 +0200
+++ ns-2.35/tcl/lib/ns-lib.tcl	2017-04-01 01:47:30.413889126 +0200
@@ -630,6 +630,9 @@
 		    AODV {
 			    set ragent [$self create-aodv-agent $node]
 		    }
+		    DYMOUM {
+	                     set ragent [$self create-dymoum-agent $node]
+	            }
 		    AOMDV {
 			    set ragent [$self create-aomdv-agent $node]
 		    }
@@ -859,6 +862,7 @@
         return $ragent
 }
 
+
 # AOMDV patch
 Simulator instproc create-aomdv-agent { node } {
 	set ragent [new Agent/AOMDV [$node node-addr]]
@@ -882,6 +886,22 @@
         $node set ragent_ $ragent
         return $ragent
 }
+
+Simulator instproc create-dymoum-agent { node } {
+        # Create DYMOUM routing agent
+        set ragent [new Agent/DYMOUM [$node node-addr]]
+        $self at 0.0 "$ragent start"
+        $node set ragent_ $ragent
+        return $ragent
+}
+
+Simulator instproc create-dymoum-agent { node } {
+        # Create DYMOUM routing agent
+        set ragent [new Agent/DYMOUM [$node node-addr]]
+        $self at 0.0 "$ragent start"
+        $node set ragent_ $ragent
+        return $ragent
+}
 
 Simulator instproc use-newtrace {} {
 	Simulator set WirelessNewTrace_ 1
diff -Naur ns-2.35-orig/tcl/lib/ns-mobilenode.tcl ns-2.35/tcl/lib/ns-mobilenode.tcl
--- ns-2.35-orig/tcl/lib/ns-mobilenode.tcl	2009-01-15 07:23:49.000000000 +0100
+++ ns-2.35/tcl/lib/ns-mobilenode.tcl	2017-04-01 01:47:30.414889133 +0200
@@ -167,7 +167,7 @@
 # if portnumber is 255, default target is set to the routing agent
 #
 Node/MobileNode instproc add-target { agent port } {
-	$self instvar dmux_ imep_ toraDebug_ 
+	$self instvar dmux_ imep_ toraDebug_ mac_ 
 
 	set ns [Simulator instance]
 	set newapi [$ns imep-support]
@@ -191,12 +191,24 @@
 	if {$aomdvonly != -1 } {
 		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
 	}
+
+        # Special processing for DYMOUM
+        set dymoumonly [string first "DYMOUM" [$agent info class]]
+        if {$dymoumonly != -1 } {
+                $agent install-tap $mac_(0)
+        }
 	
 	# Special processing for AODV
 	set aodvonly [string first "AODV" [$agent info class]] 
 	if {$aodvonly != -1 } {
 		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
 	}
+
+        # Special processing for DYMOUM
+        set dymoumonly [string first "DYMOUM" [$agent info class]]
+        if {$dymoumonly != -1 } {
+                $agent install-tap $mac_(0)
+        }
 	
 	#<zheng: add>
 	# Special processing for ZBR
diff -Naur ns-2.35-orig/tcl/lib/ns-packet.tcl ns-2.35/tcl/lib/ns-packet.tcl
--- ns-2.35-orig/tcl/lib/ns-packet.tcl	2011-10-15 00:11:08.000000000 +0200
+++ ns-2.35/tcl/lib/ns-packet.tcl	2017-04-01 01:47:30.414889133 +0200
@@ -179,6 +179,7 @@
 	MDART 	# routing protocol for ad-hoc networks
 	# AOMDV patch
 	AOMDV
+	DYMOUM # on-demand routing protocol
 # Other:
 	Encap 	# common/encap.cc
         IPinIP 	# IP encapsulation 
diff -Naur ns-2.35-orig/trace/cmu-trace.cc ns-2.35/trace/cmu-trace.cc
--- ns-2.35-orig/trace/cmu-trace.cc	2011-10-03 00:32:35.000000000 +0200
+++ ns-2.35/trace/cmu-trace.cc	2017-04-01 01:55:08.921147725 +0200
@@ -54,6 +54,11 @@
 #include <aomdv/aomdv_packet.h>
 #include <mdart/mdart_packet.h>
 #include <mdart/mdart_function.h>
+
+#ifdef DYMO_UM
+#include <dymoum/ns/dymo_um.h>
+#endif  /* DYMO_UM */
+
 #include <cmu-trace.h>
 #include <mobilenode.h>
 #include <simulator.h>
@@ -963,6 +968,289 @@
         }
 }
 
+#ifdef DYMO_UM
+void
+CMUTrace::format_dymoum(Packet *p, int offset) {
+	int len;
+	RE *re;
+	RERR *rerr;
+	UERR *uerr;
+	HELLO *hello;
+	hdr_dymoum *dh = HDR_DYMOUM(p);
+	
+	if (pt_->tagged()) {
+		switch (dh->type)
+		{
+			case DYMO_RE_TYPE:
+				
+				re = (RE *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"-dymoum:e RE -dymoum:m %d -dymoum:h %d "
+						"-dymoum:l %d -dymoum:c %d -dymoum:i %d "
+						"-dymoum:a %d -dymoum:t %d -dymoum:s %d "
+						"-dymoum:n %d ",
+						re->m, re->h, re->len, re->ttl, re->i,
+						re->a, re->target_addr, re->target_seqnum,
+						re->thopcnt);
+				
+				len = strlen(pt_->buffer());
+				for (int i = 0; i < NS_CLASS re_numblocks(re); i++) {
+					struct re_block block = re->re_blocks[i];
+					sprintf(pt_->buffer()  + len,
+							"[-dymoum:g %d -dymoum:p %d "
+							"-dymoum:h %d -dymoum:n %d "
+							"-dymoum:s %d] ",
+							block.g, block.prefix, block.re_hopcnt,
+							block.re_node_addr,
+							block.re_node_seqnum);
+					len = strlen(pt_->buffer());
+				}
+				break;
+				
+				
+			case DYMO_RERR_TYPE:
+				
+				rerr = (RERR *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"-dymoum:e RERR -dymoum:m %d -dymoum:h %d "
+						"-dymoum:l %d -dymoum:c %d -dymoum:i %d ",
+						rerr->m, rerr->h, rerr->len, rerr->ttl, rerr->i);
+				
+				len = strlen(pt_->buffer());
+				for (int i = 0; i < NS_CLASS rerr_numblocks(rerr); i++) {
+					struct rerr_block block = rerr->rerr_blocks[i];
+					sprintf(pt_->buffer()  + len,
+							"[-dymoum:n %d -dymoum:s %d] ",
+							block.unode_addr,
+							block.unode_seqnum);
+					len = strlen(pt_->buffer());
+				}
+				break;
+				
+				
+			case DYMO_UERR_TYPE:
+				
+				uerr = (UERR *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"-dymoum:e UERR -dymoum:m %d -dymoum:h %d "
+						"-dymoum:l %d -dymoum:t %d -dymoum:u %d "
+						"-dymoum:n %d -dymoum:y %d ",
+						uerr->m, uerr->h, uerr->len, uerr->target_addr,
+						uerr->uelem_target_addr, uerr->uerr_node_addr,
+						uerr->uelem_type);
+				break;
+				
+				
+			case DYMO_HELLO_TYPE:
+				
+				hello = (HELLO *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"-dymoum:e HELLO -dymoum:m %d -dymoum:h %d "
+						"-dymoum:l %d ",
+						hello->m, hello->h, hello->len);
+				break;
+				
+				
+			case DYMO_ECHOREPLY_TYPE:
+				
+				sprintf(pt_->buffer()  + offset,
+						"-dymoum:e ECHOREPLY -dymoum:l %d ",
+						dh->len);
+				break;
+				
+				
+			default:
+				
+				sprintf(pt_->buffer()  + offset,
+						"-dymoum:e UNKNOWN(%d) -dymoum:m %d -dymoum:h %d "
+						"-dymoum:l %d -dymoum:c %d "
+						"-dymoum:i %d -dymoum:t %d ",
+						dh->type, dh->m, dh->h, dh->len,
+						dh->ttl, dh->i, dh->target_addr);
+		}
+	}
+	else if (newtrace_) {
+		switch (dh->type)
+		{
+			case DYMO_RE_TYPE:
+				
+				re = (RE *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"-P DYMOUM(RE) -Pm %d -Ph %d "
+						"-Pl %d -Pc %d -Pi %d "
+						"-Pa %d -Pt %d -Ps %d "
+						"-Pn %d ",
+						re->m, re->h, re->len, re->ttl, re->i,
+						re->a, re->target_addr, re->target_seqnum,
+						re->thopcnt);
+				
+				len = strlen(pt_->buffer());
+				for (int i = 0; i < NS_CLASS re_numblocks(re); i++) {
+					struct re_block block = re->re_blocks[i];
+					sprintf(pt_->buffer()  + len,
+							"[-Pg %d -Pp %d -Ph %d -Pn %d -Ps %d] ",
+							block.g, block.prefix, block.re_hopcnt,
+							block.re_node_addr,
+							block.re_node_seqnum);
+					len = strlen(pt_->buffer());
+				}
+				break;
+				
+				
+			case DYMO_RERR_TYPE:
+				
+				rerr = (RERR *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"-P DYMOUM(RERR) -Pm %d -Ph %d "
+						"-Pl %d -Pc %d -Pi %d ",
+						rerr->m, rerr->h, rerr->len, rerr->ttl, rerr->i);
+				
+				len = strlen(pt_->buffer());
+				for (int i = 0; i < NS_CLASS rerr_numblocks(rerr); i++) {
+					struct rerr_block block = rerr->rerr_blocks[i];
+					sprintf(pt_->buffer() + len,
+							"[-Pn %d -Ps %d] ",
+							block.unode_addr,
+							block.unode_seqnum);
+					len = strlen(pt_->buffer());
+				}
+				break;
+				
+				
+			case DYMO_UERR_TYPE:
+				
+				uerr = (UERR *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"-P DYMOUM(UERR) -Pm %d -Ph %d "
+						"-Pl %d -Pt %d -Pu %d "
+						"-Pn %d -Py %d ",
+						uerr->m, uerr->h, uerr->len, uerr->target_addr,
+						uerr->uelem_target_addr, uerr->uerr_node_addr,
+						uerr->uelem_type);
+				break;
+				
+				
+			case DYMO_HELLO_TYPE:
+				
+				hello = (HELLO *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"-P DYMOUM(HELLO) -Pm %d -Ph %d -Pl %d ",
+						hello->m, hello->h, hello->len);
+				break;
+				
+				
+			case DYMO_ECHOREPLY_TYPE:
+				
+				sprintf(pt_->buffer()  + offset,
+						"-P DYMOUM(ECHOREPLY) -Pl %d ",
+						dh->len);
+				break;
+				
+			default:
+				
+				sprintf(pt_->buffer()  + offset,
+						"-P UNKNOWN(%d) -Pm %d -Ph %d "
+						"-Pl %d -Pc %d "
+						"-Pi %d -Pt %d ",
+						dh->type, dh->m, dh->h, dh->len,
+						dh->ttl, dh->i, dh->target_addr);
+		}
+	}
+	else {
+		switch (dh->type)
+		{
+			case DYMO_RE_TYPE:
+				
+				re = (RE *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"[ RE %d %d "
+						"%d %d %d "
+						"%d %d %d %d ",
+						re->m, re->h, re->len, re->ttl, re->i,
+						re->a, re->target_addr, re->target_seqnum,
+						re->thopcnt);
+				
+				len = strlen(pt_->buffer());
+				for (int i = 0; i < NS_CLASS re_numblocks(re); i++) {
+					struct re_block block = re->re_blocks[i];
+					sprintf(pt_->buffer()  + len,
+							"[%d %d %d %d %d] ",
+							block.g, block.prefix, block.re_hopcnt,
+							block.re_node_addr,
+							block.re_node_seqnum);
+					len = strlen(pt_->buffer());
+				}
+				
+				sprintf(pt_->buffer() + len, "]");
+				break;
+				
+				
+			case DYMO_RERR_TYPE:
+				
+				rerr = (RERR *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"[ RERR %d %d "
+						"%d %d %d ",
+						rerr->m, rerr->h, rerr->len,
+						rerr->ttl, rerr->i);
+				
+				len = strlen(pt_->buffer());
+				for (int i = 0; i < NS_CLASS rerr_numblocks(rerr); i++) {
+					struct rerr_block block = rerr->rerr_blocks[i];
+					sprintf(pt_->buffer() + len,
+							"[%d %d] ",
+							block.unode_addr,
+							block.unode_seqnum);
+					len = strlen(pt_->buffer());
+				}
+				
+				sprintf(pt_->buffer()  + len, "]");
+				break;
+				
+				
+			case DYMO_UERR_TYPE:
+				
+				uerr = (UERR *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"[ UERR %d %d "
+						"%d %d %d "
+						"%d %d ]",
+						uerr->m, uerr->h, uerr->len, uerr->target_addr,
+						uerr->uelem_target_addr, uerr->uerr_node_addr,
+						uerr->uelem_type);
+				break;
+				
+				
+			case DYMO_HELLO_TYPE:
+				
+				hello = (HELLO *) dh;
+				sprintf(pt_->buffer()  + offset,
+						"[ HELLO %d %d %d ]",
+						hello->m, hello->h, hello->len);
+				break;
+				
+				
+			case DYMO_ECHOREPLY_TYPE:
+				
+				sprintf(pt_->buffer()  + offset,
+						"[ ECHOREPLY %d ]",
+						dh->len);
+				break;
+				
+			default:
+				
+				sprintf(pt_->buffer()  + offset,
+						"[ UNKNOWN(%d) %d %d "
+						"%d %d "
+						"%d %d ]",
+						dh->type, dh->m, dh->h, dh->len,
+						dh->ttl, dh->i, dh->target_addr);
+		}
+	}
+}
+#endif  /* DYMO_UM */
+
+
 // AOMDV patch
 void
 CMUTrace::format_aomdv(Packet *p, int offset)
@@ -1454,6 +1742,12 @@
 	        case PT_DIFF:
 			break;
 		case PT_GAF:
+				break;
+		#ifdef DYMO_UM
+			case PT_DYMOUM:
+				format_dymoum(p, offset);
+				break;
+		#endif  /* DYMO_UM */
 		case PT_PING:
 			break;
 		default:
diff -Naur ns-2.35-orig/trace/cmu-trace.h ns-2.35/trace/cmu-trace.h
--- ns-2.35-orig/trace/cmu-trace.h	2010-05-10 00:28:41.000000000 +0200
+++ ns-2.35/trace/cmu-trace.h	2017-04-01 01:56:45.145855841 +0200
@@ -162,6 +162,10 @@
 	void    format_aomdv(Packet *p, int offset);
 	void    format_mdart(Packet *p, int offset);
 
+	#ifdef DYMO_UM
+	        void    format_dymoum(Packet *p, int offset);
+	#endif  /* DYMO_UM */
+
 	// This holds all the tracers added at run-time
 	static PacketTracer *pktTrc_;
 
